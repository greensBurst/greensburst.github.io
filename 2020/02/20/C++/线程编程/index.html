<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="李素晴"><meta name="copyright" content="李素晴"><meta name="generator" content="Hexo 5.1.1"><meta name="theme" content="hexo-theme-yun"><title>线程编程 | Lisuqing's Personal Website</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.21/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_2138379_1l6ur2tg9f2.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/photo/icon.png"><link rel="mask-icon" href="/photo/icon.png" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"lisuqing2020.github.io","root":"/","title":"李素晴的日记","version":"1.2.0","mode":"time","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><script data-ad-client="ca-pub-9695375546022807" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><meta name="description" content="一. 线程基本概念 线程的定义 线程是比进程更小的程序执行单位 多个线程可共享全局数据，也可使用专有数据   Linux线程支持史 1996年，LinuxThreads：基本符合POSIX标准，但效率低下，问题多多 2003年，内核2.6：提供线程支持库NPTL（Native POSIX Thread Library for Linux）   内核线程 操作系统内核支持多线程调度与执行 内核线">
<meta property="og:type" content="article">
<meta property="og:title" content="线程编程">
<meta property="og:url" content="http://lisuqing2020.github.io/2020/02/20/C++/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Lisuqing&#39;s Personal Website">
<meta property="og:description" content="一. 线程基本概念 线程的定义 线程是比进程更小的程序执行单位 多个线程可共享全局数据，也可使用专有数据   Linux线程支持史 1996年，LinuxThreads：基本符合POSIX标准，但效率低下，问题多多 2003年，内核2.6：提供线程支持库NPTL（Native POSIX Thread Library for Linux）   内核线程 操作系统内核支持多线程调度与执行 内核线">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-20T03:43:46.000Z">
<meta property="article:modified_time" content="2020-11-22T05:30:19.311Z">
<meta property="article:author" content="李素晴">
<meta property="article:tag" content="thuC++">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="李素晴"><img width="96" loading="lazy" src="/photo/avatar.jpg" alt="李素晴"></a><div class="site-author-name"><a href="/about/">李素晴</a></div><a class="site-name" href="/about/site.html">Lisuqing's Personal Website</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">230</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder--line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag--line"></use></svg></span><span class="site-state-item-count">21</span></a></div><a class="site-state-item hty-icon-button" href="/about" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=1164919034&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/lisuqing2020" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:lisuqing2020@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://juejin.im/user/676954896099847" title="掘金" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-juejin"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" target="_blank" rel="noopener" href="https://nobilta.github.io/" title="东农吴彦祖" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" target="_blank" rel="noopener" href="https://happycpp.github.io/" title="渣王" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一. 线程基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">线程的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%8F%B2"><span class="toc-number">1.0.2.</span> <span class="toc-text">Linux线程支持史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.3.</span> <span class="toc-text">内核线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%EF%BC%88lightweight-process%EF%BC%8CLWP%EF%BC%89"><span class="toc-number">1.0.4.</span> <span class="toc-text">轻量级进程（lightweight process，LWP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.5.</span> <span class="toc-text">用户线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">1.0.6.</span> <span class="toc-text">使用说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.7.</span> <span class="toc-text">进程与线程的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">二. 线程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">2.0.1.</span> <span class="toc-text">线程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">线程创建函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">线程创建流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%AF%B4%E6%98%8E"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">线程创建说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">线程退出方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.0.2.</span> <span class="toc-text">线程函数参数与返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%80%E8%88%AC%E4%B8%8D%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%BB%E4%BD%95%E8%BE%93%E5%87%BA"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">存在的问题：一般不会产生任何输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E4%BD%BF%E7%94%A8pthread-join-%E5%87%BD%E6%95%B0%EF%BC%8C%E7%AD%89%E5%BE%85%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">解决方案：使用pthread_join()函数，等待子线程结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">线程函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8BID"><span class="toc-number">2.0.3.</span> <span class="toc-text">线程ID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-equal-%E5%87%BD%E6%95%B0%EF%BC%9A%E7%A1%AE%E8%AE%A4%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">pthread_equal()函数：确认两个线程是否相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-self-%E5%87%BD%E6%95%B0%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84ID"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">pthread_self()函数：返回当前线程的ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.4.</span> <span class="toc-text">线程属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%EF%BC%9A%E7%B2%BE%E7%BB%86%E8%B0%83%E6%95%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">线程属性：精细调整线程的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">设置线程属性的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="toc-number">2.0.4.3.</span> <span class="toc-text">线程属性说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB"><span class="toc-number">2.0.4.4.</span> <span class="toc-text">线程分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-attr-setdetachstate-%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.4.5.</span> <span class="toc-text">pthread_attr_setdetachstate()函数：设置线程分离属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-attr-getdetachstate-%E5%87%BD%E6%95%B0%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.4.6.</span> <span class="toc-text">pthread_attr_getdetachstate()函数：获取线程分离属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%92%A4%E9%94%80"><span class="toc-number">2.0.5.</span> <span class="toc-text">线程撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cancel-%E5%87%BD%E6%95%B0%EF%BC%9A%E6%92%A4%E9%94%80%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">pthread_cancel()函数：撤销线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%92%A4%E9%94%80%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%8A%B6%E6%80%81"><span class="toc-number">2.0.5.2.</span> <span class="toc-text">线程撤销类型与状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-setcanceltype-%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%92%A4%E9%94%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.5.3.</span> <span class="toc-text">pthread_setcanceltype()函数：设置线程的撤销类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-setcancelstate-%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%92%A4%E9%94%80%E7%8A%B6%E6%80%81"><span class="toc-number">2.0.5.4.</span> <span class="toc-text">pthread_setcancelstate()函数：设置线程的撤销状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-testcancel-%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%92%A4%E9%94%80%E7%82%B9"><span class="toc-number">2.0.5.5.</span> <span class="toc-text">pthread_testcancel()函数：设置撤销点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%92%A4%E9%94%80%E7%8A%B6%E6%80%81%E6%9E%84%E9%80%A0%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%88critical-section%EF%BC%89"><span class="toc-number">2.0.5.6.</span> <span class="toc-text">使用撤销状态构造临界区（critical section）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">2.0.6.</span> <span class="toc-text">线程局部存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%EF%BC%88thread-local-storage%EF%BC%8CTLS%EF%BC%89%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8B%AC%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">线程局部存储（thread local storage，TLS）：每个线程的独有数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8B%A5%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%89%AF%E6%9C%AC%EF%BC%9A%E4%B8%8D%E8%83%BD%E7%AE%80%E5%8D%95%E8%B5%8B%E5%80%BC%E6%88%96%E8%AF%BB%E5%8F%96"><span class="toc-number">2.0.6.2.</span> <span class="toc-text">让线程拥有数据的独立副本：不能简单赋值或读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B8%85%E9%99%A4"><span class="toc-number">2.0.7.</span> <span class="toc-text">线程清除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%EF%BC%9A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%95void-%E5%8F%82%E6%95%B0%EF%BC%8C%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.0.7.1.</span> <span class="toc-text">线程清除函数：回调函数，单void*参数，无返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cleanup-push-%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B3%A8%E5%86%8C%E7%BA%BF%E7%A8%8B%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-number">2.0.7.2.</span> <span class="toc-text">pthread_cleanup_push()函数：注册线程清除函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cleanup-pop-%E5%87%BD%E6%95%B0%EF%BC%9A%E5%8F%96%E6%B6%88%E7%BA%BF%E7%A8%8B%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8C"><span class="toc-number">2.0.7.3.</span> <span class="toc-text">pthread_cleanup_pop()函数：取消线程清除函数注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.7.4.</span> <span class="toc-text">C++的问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">三. 线程同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89"><span class="toc-number">3.0.1.</span> <span class="toc-text">资源竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">编程任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">3.0.2.</span> <span class="toc-text">互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%EF%BC%88mutex%EF%BC%89%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%9AMUTial-EXclusion"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">互斥（mutex）定义与性质：MUTial EXclusion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-init-%E5%87%BD%E6%95%B0%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%92%E6%96%A5"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">pthread_mutex_init()函数：初始化互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-destroy-%E5%87%BD%E6%95%B0%EF%BC%9A%E9%94%80%E6%AF%81%E4%BA%92%E6%96%A5"><span class="toc-number">3.0.2.3.</span> <span class="toc-text">pthread_mutex_destroy()函数：销毁互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-lock-%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BA%92%E6%96%A5%E5%8A%A0%E9%94%81"><span class="toc-number">3.0.2.4.</span> <span class="toc-text">pthread_mutex_lock()函数：互斥加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-trylock-%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BA%92%E6%96%A5%E5%8A%A0%E9%94%81"><span class="toc-number">3.0.2.5.</span> <span class="toc-text">pthread_mutex_trylock()函数：互斥加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-unlock-%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BA%92%E6%96%A5%E8%A7%A3%E9%94%81"><span class="toc-number">3.0.2.6.</span> <span class="toc-text">pthread_mutex_unlock()函数：互斥解锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.0.2.7.</span> <span class="toc-text">使用互斥的流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">3.0.3.</span> <span class="toc-text">互斥属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5type%E5%B1%9E%E6%80%A7"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">互斥type属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%B1%9E%E6%80%A7%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">互斥属性函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.0.4.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9A%E8%B5%84%E6%BA%90%E8%A2%AB%E7%AB%9E%E4%BA%89%E5%8D%A0%E7%94%A8%EF%BC%8C%E4%B8%94%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">死锁：资源被竞争占用，且无法释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%EF%BC%9A%E6%9B%B4%E6%94%B9%E4%BA%92%E6%96%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">处理策略：更改互斥类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.0.5.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E5%81%9A%EF%BC%9F"><span class="toc-number">3.0.5.1.</span> <span class="toc-text">问题：如何确保任务队列中有任务可以做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POSIX%E6%A0%87%E5%87%86%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9A%E5%A4%B4%E6%96%87%E4%BB%B6%E2%80%9Csemaphore-h%E2%80%9D"><span class="toc-number">3.0.5.2.</span> <span class="toc-text">POSIX标准信号量：头文件“semaphore.h”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.0.5.3.</span> <span class="toc-text">初始化信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9AP%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.5.4.</span> <span class="toc-text">等待信号量：P操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9AV%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.5.5.</span> <span class="toc-text">发布信号量：V操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.0.5.6.</span> <span class="toc-text">销毁信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.6.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%9B%AE%E7%9A%84"><span class="toc-number">3.0.6.1.</span> <span class="toc-text">条件变量的功能与目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.6.2.</span> <span class="toc-text">初始化条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.6.3.</span> <span class="toc-text">销毁条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.6.4.</span> <span class="toc-text">广播条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.6.5.</span> <span class="toc-text">唤醒条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.6.6.</span> <span class="toc-text">等待条件变量</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-C-11%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">四. C++11线程库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91"><span class="toc-number">4.0.1.</span> <span class="toc-text">支持平台无关的并行程序开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%EF%BC%9Aatomic%E3%80%81thread%E3%80%81mutex%E3%80%81condition-variable%E3%80%81future"><span class="toc-number">4.0.2.</span> <span class="toc-text">库：atomic、thread、mutex、condition_variable、future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB%EF%BC%9Athread"><span class="toc-number">4.0.3.</span> <span class="toc-text">线程类：thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.4.</span> <span class="toc-text">常用线程类成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BA%8E%E5%90%8D%E7%A9%BA%E9%97%B4this-thread%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.5.</span> <span class="toc-text">定义于名空间this_thread的线程管理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%B1%BB"><span class="toc-number">4.0.6.</span> <span class="toc-text">互斥类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%92%E6%96%A5%EF%BC%9Amutex%E7%B1%BB"><span class="toc-number">4.0.6.1.</span> <span class="toc-text">基本互斥：mutex类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%EF%BC%9Arecursive-mutex%E7%B1%BB"><span class="toc-number">4.0.6.2.</span> <span class="toc-text">递归互斥：recursive_mutex类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BA%92%E6%96%A5%EF%BC%9Atimed-mutex%E7%B1%BB"><span class="toc-number">4.0.6.3.</span> <span class="toc-text">定时互斥：timed_mutex类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%EF%BC%9Arecursive-timed-mutex%E7%B1%BB"><span class="toc-number">4.0.6.4.</span> <span class="toc-text">定时递归互斥：recursive_timed_mutex类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AE%9A%E6%97%B6%E4%BA%92%E6%96%A5%EF%BC%9Ashared-timed-mutex%E7%B1%BB%EF%BC%88C-14%EF%BC%89"><span class="toc-number">4.0.6.5.</span> <span class="toc-text">共享定时互斥：shared_timed_mutex类（C++14）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AE%B9%E6%98%93%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81"><span class="toc-number">4.0.6.6.</span> <span class="toc-text">互斥的问题：容易导致死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88resource-acquisition-is-initialization-RAII%EF%BC%89"><span class="toc-number">4.0.6.7.</span> <span class="toc-text">资源获取即初始化（resource acquisition is initialization, RAII）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%94%81%E7%AE%A1%E7%90%86%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%9Astd-lock-guard"><span class="toc-number">4.0.6.8.</span> <span class="toc-text">基于作用域的锁管理类模板：std::lock_guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E4%B8%80%E9%94%81%E7%AE%A1%E7%90%86%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%9Astd-unique-lock"><span class="toc-number">4.0.6.9.</span> <span class="toc-text">独一锁管理类模板：std::unique_lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E7%AE%A1%E7%90%86%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%9Astd-shared-lock%EF%BC%88C-14%EF%BC%89"><span class="toc-number">4.0.6.10.</span> <span class="toc-text">共享锁管理类模板：std::shared_lock（C++14）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">4.0.6.11.</span> <span class="toc-text">互斥管理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E8%A7%A3%E9%94%81%E6%97%B6%E6%9C%BA"><span class="toc-number">4.0.6.12.</span> <span class="toc-text">互斥的解锁时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E4%BA%92%E6%96%A5%E7%9A%84%E7%AB%9E%E4%BA%89%E8%AE%BF%E9%97%AE"><span class="toc-number">4.0.6.13.</span> <span class="toc-text">多个互斥的竞争访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%B1%BB"><span class="toc-number">4.0.7.</span> <span class="toc-text">条件变量类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-condition-variable%E7%B1%BB"><span class="toc-number">4.0.7.1.</span> <span class="toc-text">std::condition_variable类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-condition-variable-any%E7%B1%BB"><span class="toc-number">4.0.7.2.</span> <span class="toc-text">std::condition_variable_any类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="toc-number">4.0.7.3.</span> <span class="toc-text">多线程通信同步原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0notify-one-%EF%BC%9A%E9%80%9A%E7%9F%A5%E4%B8%80%E4%B8%AA%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.0.7.4.</span> <span class="toc-text">成员函数notify_one()：通知一个等待线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0notify-all-%EF%BC%9A%E9%80%9A%E7%9F%A5%E5%85%A8%E9%83%A8%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.0.7.5.</span> <span class="toc-text">成员函数notify_all()：通知全部等待线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0wait-%EF%BC%9A%E9%98%BB%E5%A1%9E%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E8%87%B3%E8%A2%AB%E5%94%A4%E9%86%92"><span class="toc-number">4.0.7.5.1.</span> <span class="toc-text">成员函数wait()：阻塞当前线程至被唤醒</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0wait-for-%EF%BC%9A%E9%98%BB%E5%A1%9E%E8%87%B3%E8%A2%AB%E5%94%A4%E9%86%92%E6%88%96%E8%B6%85%E8%BF%87%E6%8C%87%E5%AE%9A%E6%97%B6%E9%95%BF"><span class="toc-number">4.0.7.6.</span> <span class="toc-text">成员函数wait_for()：阻塞至被唤醒或超过指定时长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0wait-until-%EF%BC%9A%E9%98%BB%E5%A1%9E%E8%87%B3%E8%A2%AB%E5%94%A4%E9%86%92%E6%88%96%E5%88%B0%E8%BE%BE%E6%8C%87%E5%AE%9A%E6%97%B6%E7%82%B9"><span class="toc-number">4.0.7.7.</span> <span class="toc-text">成员函数wait_until()：阻塞至被唤醒或到达指定时点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%9E%8B%E5%BC%8F"><span class="toc-number">4.0.8.</span> <span class="toc-text">原子型式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.8.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E4%B9%89%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%EF%BC%8C%E6%94%AF%E6%8C%81%E5%8D%95%E5%8F%98%E9%87%8F%E4%B8%8A%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">4.0.8.2.</span> <span class="toc-text">意义：轻量级，支持单变量上的原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%9F%E8%AE%B8%E4%B8%8E%E6%89%BF%E8%AF%BA"><span class="toc-number">4.0.9.</span> <span class="toc-text">期许与承诺</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.0.9.1.</span> <span class="toc-text">线程返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.0.9.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%9E%8B%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">4.0.10.</span> <span class="toc-text">指针型式参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%9F%E8%AE%B8"><span class="toc-number">4.0.11.</span> <span class="toc-text">期许</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-future%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.0.11.1.</span> <span class="toc-text">std::future类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.0.11.2.</span> <span class="toc-text">使用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BF%E8%AF%BA"><span class="toc-number">4.0.12.</span> <span class="toc-text">承诺</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-promise%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.0.12.1.</span> <span class="toc-text">std::promise类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">4.0.12.2.</span> <span class="toc-text">使用方法</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://lisuqing2020.github.io/2020/02/20/C++/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="李素晴"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Lisuqing's Personal Website"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">线程编程</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-02-20 11:43:46" itemprop="dateCreated datePublished" datetime="2020-02-20T11:43:46+08:00">2020-02-20</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2020-11-22 13:30:19" itemprop="dateModified" datetime="2020-11-22T13:30:19+08:00">2020-11-22</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/C/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">C++</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/thuC/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">thuC++</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><a id="more"></a>

<h1 id="一-线程基本概念"><a href="#一-线程基本概念" class="headerlink" title="一. 线程基本概念"></a>一. 线程基本概念</h1><ol>
<li><h3 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h3><ul>
<li>线程是比进程更小的程序执行单位</li>
<li>多个线程可共享全局数据，也可使用专有数据</li>
</ul>
</li>
<li><h3 id="Linux线程支持史"><a href="#Linux线程支持史" class="headerlink" title="Linux线程支持史"></a>Linux线程支持史</h3><ul>
<li>1996年，LinuxThreads：基本符合POSIX标准，但效率低下，问题多多</li>
<li>2003年，内核2.6：提供线程支持库NPTL（Native POSIX Thread Library for Linux）</li>
</ul>
</li>
<li><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><ul>
<li>操作系统内核支持多线程调度与执行</li>
<li>内核线程使用资源较少，仅包括内核栈和上下文切换时需要的保存寄存器内容的空间</li>
</ul>
</li>
<li><h3 id="轻量级进程（lightweight-process，LWP）"><a href="#轻量级进程（lightweight-process，LWP）" class="headerlink" title="轻量级进程（lightweight process，LWP）"></a>轻量级进程（lightweight process，LWP）</h3><ul>
<li>由内核支持的独立调度单元，调度开销小于普通的进程</li>
<li>系统支持多个轻量级进程同时运行，每个都与特定的内核线程相关联</li>
</ul>
</li>
<li><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><ul>
<li>建立在用户空间的多个用户级线程，映射到轻量级进程后调度执行</li>
<li>用户线程在用户空间创建、同步和销毁，开销较低</li>
<li>每个线程具有独特的ID</li>
</ul>
</li>
<li><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul>
<li>线程功能不属于C/C++标准库，链接时需用-pthread选项</li>
<li>线程功能属于C++11标准库，可用C++11提供的thread类定义线程对象，C++11标准库同时提供基本的线程同步机制</li>
</ul>
</li>
<li><h3 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h3><ul>
<li>线程空间不独立，有问题的线程会影响其他线程；进程空间独立，有问题的进程一般不会影响其他进程</li>
<li>创建进程需要额外的性能开销</li>
<li>线程用于开发细颗粒度并行性，进程用于开发粗颗粒度并行性</li>
<li>线程容易共享数据，进程共享数据必须使用进程间通讯机制</li>
</ul>
</li>
</ol>
<h1 id="二-线程管理"><a href="#二-线程管理" class="headerlink" title="二. 线程管理"></a>二. 线程管理</h1><ol>
<li><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol>
<li><h4 id="线程创建函数"><a href="#线程创建函数" class="headerlink" title="线程创建函数"></a>线程创建函数</h4><ul>
<li>头文件：“pthread.h”</li>
<li>原型：<code>int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void *), void * arg);</code></li>
</ul>
</li>
<li><h4 id="线程创建流程"><a href="#线程创建流程" class="headerlink" title="线程创建流程"></a>线程创建流程</h4><ul>
<li>定义指向pthread_t对象的指针对象，pthread_t对象用于存储新线程的ID</li>
<li>定义指向线程属性pthread_attr_t对象的指针对象；线程属性对象控制线程与程序其他部分（可能是其他线程）的交互；如果传递NULL，则使用缺省属性构造新线程</li>
<li>定义指向线程函数的指针对象，使其指向固定格式的线程函数</li>
<li>实现线程函数；线程函数的参数和返回值均为哑型指针；需要传递多个参数时，打包成单个void*型的指针对象</li>
<li>线程退出时使用返回值将数据传递给主调线程；多个结果同样可以打包传递</li>
</ul>
</li>
<li><h4 id="线程创建说明"><a href="#线程创建说明" class="headerlink" title="线程创建说明"></a>线程创建说明</h4><ul>
<li>pthread_create()函数在线程创建完毕后立即返回，它并不等待线程结束</li>
<li>原线程与新线程如何执行与调度有关，程序不得依赖线程先后执行的关系</li>
<li>可以使用同步机制确定线程的先后执行关系</li>
</ul>
</li>
<li><h4 id="线程退出方式"><a href="#线程退出方式" class="headerlink" title="线程退出方式"></a>线程退出方式</h4><ul>
<li>线程函数结束执行</li>
<li>调用pthread_exit()函数显式结束</li>
<li>被其他线程撤销<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintAs</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintZs</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, &amp;PrintAs, <span class="literal">NULL</span>);</span><br><span class="line">    PrintZs(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="线程函数参数与返回值"><a href="#线程函数参数与返回值" class="headerlink" title="线程函数参数与返回值"></a>线程函数参数与返回值</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoPrinted</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InfoPrinted(<span class="keyword">char</span> c, <span class="keyword">int</span> n) : _c(c), _n(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n; i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; _c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> _c;</span><br><span class="line">    <span class="keyword">int</span> _n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintInfo</span><span class="params">(<span class="keyword">void</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InfoPrinted *p = <span class="keyword">reinterpret_cast</span>&lt;InfoPrinted *&gt;(info);</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        p-&gt;Show();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  注意：本程序大部分情况下不会输出任何结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//  构造InfoPrinted类的动态对象，作为线程函数参数传递给线程tid1</span></span><br><span class="line">    <span class="comment">//  输出100个‘a’</span></span><br><span class="line">    InfoPrinted *p = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(p));</span><br><span class="line">    <span class="comment">//  构造InfoPrinted类的动态对象，作为线程函数参数传递给线程tid2</span></span><br><span class="line">    <span class="comment">//  输出100个‘z’</span></span><br><span class="line">    InfoPrinted *q = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;z&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(q));</span><br><span class="line">    <span class="comment">//  使用本注释行替换上述线程，可以看到输出结果，可能仅有部分输出</span></span><br><span class="line">    <span class="comment">//  PrintInfo( reinterpret_cast&lt;void *&gt;( q ) );</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><h4 id="存在的问题：一般不会产生任何输出"><a href="#存在的问题：一般不会产生任何输出" class="headerlink" title="存在的问题：一般不会产生任何输出"></a>存在的问题：一般不会产生任何输出</h4><ul>
<li>子线程需要使用主线程的数据，如果主线程结束，子线程如何访问这些数据？</li>
</ul>
</li>
<li><h4 id="解决方案：使用pthread-join-函数，等待子线程结束"><a href="#解决方案：使用pthread-join-函数，等待子线程结束" class="headerlink" title="解决方案：使用pthread_join()函数，等待子线程结束"></a>解决方案：使用pthread_join()函数，等待子线程结束</h4><ul>
<li>原型：<code>int pthread_join(pthread_t thread, void ** retval);</code></li>
<li>参数：thread为pthread_t类型的线程ID；retval接收线程返回值，不需要接收返回值时传递NULL<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  注意：无法确定两个线程的执行顺序，多次输出结果可能不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    InfoPrinted *p = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(p));</span><br><span class="line"></span><br><span class="line">    InfoPrinted *q = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;z&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(q));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  等待子线程结束</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="线程函数返回值"><a href="#线程函数返回值" class="headerlink" title="线程函数返回值"></a>线程函数返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">IsPrime</span><span class="params">(<span class="keyword">void</span> *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">3u</span>, t = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">sqrt</span>(p) + <span class="number">1u</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2u</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (p % <span class="number">2u</span> == <span class="number">0u</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p % i == <span class="number">0u</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">false</span>);</span><br><span class="line">        i += <span class="number">2u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  使用g++ main.cpp –pthread –lm –fpermissive编译</span></span><br><span class="line"><span class="comment">//  以防止编译器将void*到int的转型当作错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">bool</span> primalities[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        pthread_create(&amp;tids[i], <span class="literal">NULL</span>, &amp;IsPrime, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(i + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        pthread_join(tids[i], <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(&amp;primalities[i]));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; primalities[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><ol>
<li><h4 id="pthread-equal-函数：确认两个线程是否相同"><a href="#pthread-equal-函数：确认两个线程是否相同" class="headerlink" title="pthread_equal()函数：确认两个线程是否相同"></a>pthread_equal()函数：确认两个线程是否相同</h4><ul>
<li>原型：<code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li>
</ul>
</li>
<li><h4 id="pthread-self-函数：返回当前线程的ID"><a href="#pthread-self-函数：返回当前线程的ID" class="headerlink" title="pthread_self()函数：返回当前线程的ID"></a>pthread_self()函数：返回当前线程的ID</h4><ul>
<li>原型：<code>pthread_t pthread_self();</code></li>
<li>示例：<code>if( !pthread_equal(pthread_self(), other_tid)) pthread_join(other_tid, NULL);</code></li>
</ul>
</li>
</ol>
</li>
<li><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ol>
<li><h4 id="线程属性：精细调整线程的行为"><a href="#线程属性：精细调整线程的行为" class="headerlink" title="线程属性：精细调整线程的行为"></a>线程属性：精细调整线程的行为</h4></li>
<li><h4 id="设置线程属性的流程"><a href="#设置线程属性的流程" class="headerlink" title="设置线程属性的流程"></a>设置线程属性的流程</h4><ul>
<li>创建pthread_attr_t类型的对象</li>
<li>调用pthread_attr_init()函数初始化线程的缺省属性，传递指向该线程属性对象的指针<ul>
<li>原型：<code>int pthread_attr_init(pthread_attr_t * attr);</code></li>
</ul>
</li>
<li>对线程属性进行必要修改</li>
<li>调用pthread_create()函数时传递指向线程属性对象的指针</li>
<li>调用pthread_attr_destroy()函数清除线程属性对象， pthread_attr_t对象本身没有被销毁，因而可以调用pthread_attr_init()函数再次初始化<ul>
<li>原型：<code>int pthread_attr_destroy(pthread_attr_t * attr);</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="线程属性说明"><a href="#线程属性说明" class="headerlink" title="线程属性说明"></a>线程属性说明</h4><ul>
<li>单一线程属性对象可以用于创建多个线程</li>
<li>线程创建后，继续保留线程属性对象本身并没有意义</li>
<li>对大多数Linux程序，线程最重要的属性为分离状态（detach state）</li>
</ul>
</li>
<li><h4 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h4><ul>
<li>可联线程（joinable thread）：缺省设置，终止时并不自动清除（类似僵尸进程），主线程必须调用pthread_join()获取其返回值，此后才能清除</li>
<li>分离线程（detached thread）：结束时自动清除，不能调用pthread_join()进行线程同步</li>
<li>可联线程可通过pthread_detach()函数分离，分离线程不能再次联结<ul>
<li>原型：<code>int pthread_detach(pthread_t thread);</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="pthread-attr-setdetachstate-函数：设置线程分离属性"><a href="#pthread-attr-setdetachstate-函数：设置线程分离属性" class="headerlink" title="pthread_attr_setdetachstate()函数：设置线程分离属性"></a>pthread_attr_setdetachstate()函数：设置线程分离属性</h4><ul>
<li>原型：<code>int pthread_attr_setdetachstate (pthread_attr_t * attr, int detachstate);</code></li>
<li>传递线程属性对象指针和分离线程设置参数PTHREAD_CREATE_DETACHED</li>
</ul>
</li>
<li><h4 id="pthread-attr-getdetachstate-函数：获取线程分离属性"><a href="#pthread-attr-getdetachstate-函数：获取线程分离属性" class="headerlink" title="pthread_attr_getdetachstate()函数：获取线程分离属性"></a>pthread_attr_getdetachstate()函数：获取线程分离属性</h4><ul>
<li>原型：<code>int pthread_attr_getdetachstate (pthread_attr_t * attr, int * detachstate);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//  线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="comment">//  初始化线程属性</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">//  设置线程属性的分离状态</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="comment">//  创建线程</span></span><br><span class="line">    pthread_create(&amp;thread, &amp;attr, &amp;ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//  清除线程属性对象</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="comment">//  无需联结该线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="线程撤销"><a href="#线程撤销" class="headerlink" title="线程撤销"></a>线程撤销</h3><ol>
<li><h4 id="pthread-cancel-函数：撤销线程"><a href="#pthread-cancel-函数：撤销线程" class="headerlink" title="pthread_cancel()函数：撤销线程"></a>pthread_cancel()函数：撤销线程</h4><ul>
<li>原型：<code>int pthread_cancel(pthread_t thread);</code></li>
<li>已撤销的线程可以联结，且必须联结，以释放其资源，除非其为分离线程</li>
</ul>
</li>
<li><h4 id="线程撤销类型与状态"><a href="#线程撤销类型与状态" class="headerlink" title="线程撤销类型与状态"></a>线程撤销类型与状态</h4><ul>
<li>异步可撤销：在其执行的任何时刻都可撤销</li>
<li>同步可撤销：线程可撤销，但撤销操作首先进入队列排队，在线程执行到特定撤销点时才可撤销</li>
<li>不可撤消：撤销不可撤消线程的企图被系统忽略，且没有任何消息反馈</li>
</ul>
</li>
<li><h4 id="pthread-setcanceltype-函数：设置线程的撤销类型"><a href="#pthread-setcanceltype-函数：设置线程的撤销类型" class="headerlink" title="pthread_setcanceltype()函数：设置线程的撤销类型"></a>pthread_setcanceltype()函数：设置线程的撤销类型</h4><ul>
<li>原型：<code>int pthread_setcanceltype(int type, int * oldtype);</code></li>
<li>参数：type为撤销类型，oldtype用于保存原始线程撤销类型，NULL表示不保存</li>
<li>PTHREAD_CANCEL_ASYNCHRONOUS：线程异步可撤销</li>
<li>PTHREAD_CANCEL_DEFERRED：线程同步可撤销，即延迟到下一撤销点时撤销</li>
</ul>
</li>
<li><h4 id="pthread-setcancelstate-函数：设置线程的撤销状态"><a href="#pthread-setcancelstate-函数：设置线程的撤销状态" class="headerlink" title="pthread_setcancelstate()函数：设置线程的撤销状态"></a>pthread_setcancelstate()函数：设置线程的撤销状态</h4><ul>
<li>原型：<code>int pthread_setcancelstate(int state, int * oldstate);</code></li>
<li>第一个参数state为可撤销状态，第二个参数oldstate用于保存原始线程可撤销状态，NULL表示不保存</li>
<li>PTHREAD_CANCEL_ENABLE：线程可撤销</li>
<li>PTHREAD_CANCEL_DISABLE：线程不可撤销</li>
<li>线程的撤销状态可多次设置</li>
</ul>
</li>
<li><h4 id="pthread-testcancel-函数：设置撤销点"><a href="#pthread-testcancel-函数：设置撤销点" class="headerlink" title="pthread_testcancel()函数：设置撤销点"></a>pthread_testcancel()函数：设置撤销点</h4><ul>
<li>原型：<code>void pthread_testcancel();</code></li>
<li>在线程函数中调用pthread_testcancel()函数设置撤销点</li>
<li>建议：周期性地设置撤销点，保证线程函数内部每隔一些代码就有一个撤销点，以保证资源能够正确释放</li>
</ul>
</li>
<li><h4 id="使用撤销状态构造临界区（critical-section）"><a href="#使用撤销状态构造临界区（critical-section）" class="headerlink" title="使用撤销状态构造临界区（critical section）"></a>使用撤销状态构造临界区（critical section）</h4><ul>
<li>临界区：要么全部执行，要么一条都不执行的代码段</li>
<li>设置线程的撤销状态，线程一旦进入临界区，就必须等到离开临界区，才可以被撤销<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  账户转账</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transfer</span><span class="params">(<span class="keyword">double</span> *accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ocs;</span><br><span class="line">    <span class="comment">//  数据有效性检查代码在此，确保转账操作合法有效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将线程设置为不可撤销的，进入临界区</span></span><br><span class="line">    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;ocs);</span><br><span class="line"></span><br><span class="line">    accounts[to] += amount;</span><br><span class="line">    accounts[from] -= amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  恢复线程的撤销状态，离开临界区</span></span><br><span class="line">    pthread_setcancelstate(ocs, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h3><ol>
<li><h4 id="线程局部存储（thread-local-storage，TLS）：每个线程的独有数据"><a href="#线程局部存储（thread-local-storage，TLS）：每个线程的独有数据" class="headerlink" title="线程局部存储（thread local storage，TLS）：每个线程的独有数据"></a>线程局部存储（thread local storage，TLS）：每个线程的独有数据</h4><ul>
<li>线程特定数据（thread-specific data）</li>
<li>进程的多个线程通过全局堆共享全局数据对象</li>
<li>每个线程拥有独立的栈</li>
</ul>
</li>
<li><h4 id="让线程拥有数据的独立副本：不能简单赋值或读取"><a href="#让线程拥有数据的独立副本：不能简单赋值或读取" class="headerlink" title="让线程拥有数据的独立副本：不能简单赋值或读取"></a>让线程拥有数据的独立副本：不能简单赋值或读取</h4><ul>
<li>pthread_key_create()函数：为线程特定数据创建一个键</li>
<li>参数：第一个为指向pthread_key_t类型变量的指针（每个线程都可以使用它访问自己的独立数据副本）；第二个参数为指向线程清除函数的指针，如果不存在，传递NULL</li>
<li>pthread_setspecific()函数：设置对应键的值</li>
<li>pthread_getspecific()函数：读取对应键的值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> tlk; <span class="comment">//  关联线程日志文件指针的键</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToThreadLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = (FILE *)pthread_getspecific(tlk);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d: %s\n&quot;</span>, (<span class="keyword">int</span>)pthread_self(), msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseThreadLog</span><span class="params">(<span class="keyword">void</span> *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose((FILE *)fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">255</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">//  生成与线程ID配套的日志文件名</span></span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">&quot;thread%d.log&quot;</span>, (<span class="keyword">int</span>)pthread_self());</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">//  设置线程日志文件指针与键的局部存储关联</span></span><br><span class="line">    pthread_setspecific(tlk, fp);</span><br><span class="line">    <span class="comment">//  向日志中写入数据，不同的线程会写入不同的文件</span></span><br><span class="line">    WriteToThreadLog(<span class="string">&quot;Thread starting...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//  创建键，使用CloseThreadLog()函数作为其清除程序</span></span><br><span class="line">    pthread_key_create(&amp;tlk, CloseThreadLog);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_key_delete(tlk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="线程清除"><a href="#线程清除" class="headerlink" title="线程清除"></a>线程清除</h3><ol>
<li><h4 id="线程清除函数：回调函数，单void-参数，无返回值"><a href="#线程清除函数：回调函数，单void-参数，无返回值" class="headerlink" title="线程清除函数：回调函数，单void*参数，无返回值"></a>线程清除函数：回调函数，单void*参数，无返回值</h4><ul>
<li>目的：销毁线程退出或被撤销时未释放的资源</li>
</ul>
</li>
<li><h4 id="pthread-cleanup-push-函数：注册线程清除函数"><a href="#pthread-cleanup-push-函数：注册线程清除函数" class="headerlink" title="pthread_cleanup_push()函数：注册线程清除函数"></a>pthread_cleanup_push()函数：注册线程清除函数</h4><ul>
<li>原型：<code>void pthread_cleanup_push(void (*routine)(void*), void * arg);</code></li>
<li>参数：routine为指向线程清除函数的函数指针，arg为传递给回调函数的附加数据对象</li>
</ul>
</li>
<li><h4 id="pthread-cleanup-pop-函数：取消线程清除函数注册"><a href="#pthread-cleanup-pop-函数：取消线程清除函数注册" class="headerlink" title="pthread_cleanup_pop()函数：取消线程清除函数注册"></a>pthread_cleanup_pop()函数：取消线程清除函数注册</h4><ul>
<li>原型：<code>void pthread_cleanup_pop(int execute);</code></li>
<li>参数：整型值，非0调用回调函数释放资源，0不释放<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *  <span class="title">AllocateBuffer</span><span class="params">( <span class="keyword">size_t</span> size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>( size );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DeallocateBuffer</span><span class="params">( <span class="keyword">void</span> * buffer )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>( buffer );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DoSomeWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *  temp_buffer = AllocateBuffer( <span class="number">1024</span> );</span><br><span class="line"><span class="comment">//  注册清除处理函数</span></span><br><span class="line">pthread_cleanup_push( DeallocateBuffer, temp_buffer );</span><br><span class="line"><span class="comment">//  此处可以调用pthread_exit()退出线程或者撤销线程</span></span><br><span class="line"><span class="comment">//  取消注册，传递非0值，实施清除任务</span></span><br><span class="line">pthread_cleanup_pop( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="C-的问题"><a href="#C-的问题" class="headerlink" title="C++的问题"></a>C++的问题</h4><ul>
<li>对象的析构函数在线程退出时可能没有机会被调用，因而线程栈上的数据未清除</li>
<li>如何保证线程资源被正确释放？</li>
<li>解决方法<ul>
<li>定义异常类，线程在准备退出时引发异常，然后在异常处理中退出线程执行</li>
<li>引发异常时，C++确保析构函数被调用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EThreadExit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EThreadExit(<span class="keyword">void</span> *ret_val) : _thread_ret_val(ret_val) &#123;&#125;</span><br><span class="line">    <span class="comment">//  实际退出线程，使用对象构造时的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">DoThreadExit</span><span class="params">()</span> </span>&#123; pthread_exit(_thread_ret_val); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> *_thread_ret_val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (线程需要立即退出)</span><br><span class="line">            <span class="keyword">throw</span> EThreadExit(线程返回值);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> EThreadExit &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.DoThreadExit(); <span class="comment">//  执行线程实际退出动作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="三-线程同步机制"><a href="#三-线程同步机制" class="headerlink" title="三. 线程同步机制"></a>三. 线程同步机制</h1><ol>
<li><h3 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h3><ol>
<li><h4 id="编程任务"><a href="#编程任务" class="headerlink" title="编程任务"></a>编程任务</h4><ul>
<li>存在一个任务队列，多个并发线程同时处理这些任务。每个线程在完成某项任务后，检查任务队列中是否有新任务。如果有，就处理该任务，并将该任务从任务队列中删除。</li>
<li>假设：两个线程碰巧完成各自任务，但队列中只有一个任务。</li>
<li>可能发生的情况：第一个线程发现任务队列非空，准备接收该任务，但没有完成全部设置。此时，操作系统碰巧中断该线程。第二个线程获得了执行，也发现任务队列非空，同样准备接收该任务，但发现已无法正确设置任务队列。</li>
<li>最坏情况：第一个线程已经从队列中摘取了任务，但是还没有将任务队列设置为空，第二个线程对任务队列的访问导致段错误，系统崩溃。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  有问题的程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span>;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Job *&gt; job_queue;</span><br><span class="line"><span class="comment">//  线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DequeueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = job_queue.front();</span><br><span class="line">        job_queue.pop_front();</span><br><span class="line">        ProcessJob(job);</span><br><span class="line">        <span class="keyword">delete</span> job, job = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ol>
<li><h4 id="互斥（mutex）定义与性质：MUTial-EXclusion"><a href="#互斥（mutex）定义与性质：MUTial-EXclusion" class="headerlink" title="互斥（mutex）定义与性质：MUTial EXclusion"></a>互斥（mutex）定义与性质：MUTial EXclusion</h4><ul>
<li>相互独占锁，与二元信号量类似</li>
<li>一次只有一个线程可以锁定一个数据对象，并访问</li>
<li>只有该线程释放锁定，其他线程才能访问该数据对象</li>
</ul>
</li>
<li><h4 id="pthread-mutex-init-函数：初始化互斥"><a href="#pthread-mutex-init-函数：初始化互斥" class="headerlink" title="pthread_mutex_init()函数：初始化互斥"></a>pthread_mutex_init()函数：初始化互斥</h4><ul>
<li>原型：<code>int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * mutexattr);</code></li>
<li>参数： mutex为互斥对象，mutexattr为互斥属性对象，NULL表示使用缺省属性</li>
<li>可使用预定义宏PTHREAD_MUTEX_INITIALIZER初始化互斥</li>
</ul>
</li>
<li><h4 id="pthread-mutex-destroy-函数：销毁互斥"><a href="#pthread-mutex-destroy-函数：销毁互斥" class="headerlink" title="pthread_mutex_destroy()函数：销毁互斥"></a>pthread_mutex_destroy()函数：销毁互斥</h4><ul>
<li>原型：<code>int pthread_mutex_destroy(pthread_mutex_t * mutex);</code></li>
</ul>
</li>
<li><h4 id="pthread-mutex-lock-函数：互斥加锁"><a href="#pthread-mutex-lock-函数：互斥加锁" class="headerlink" title="pthread_mutex_lock()函数：互斥加锁"></a>pthread_mutex_lock()函数：互斥加锁</h4><ul>
<li>原型：<code>int pthread_mutex_lock(pthread_mutex_t * mutex);</code></li>
<li>如果无法锁定，则调用将阻塞，至该互斥被解除锁定状态</li>
</ul>
</li>
<li><h4 id="pthread-mutex-trylock-函数：互斥加锁"><a href="#pthread-mutex-trylock-函数：互斥加锁" class="headerlink" title="pthread_mutex_trylock()函数：互斥加锁"></a>pthread_mutex_trylock()函数：互斥加锁</h4><ul>
<li>原型：<code>int pthread_mutex_trylock(pthread_mutex_t * mutex);</code></li>
<li>如果无法锁定，则立即返回，不阻塞</li>
</ul>
</li>
<li><h4 id="pthread-mutex-unlock-函数：互斥解锁"><a href="#pthread-mutex-unlock-函数：互斥解锁" class="headerlink" title="pthread_mutex_unlock()函数：互斥解锁"></a>pthread_mutex_unlock()函数：互斥解锁</h4><ul>
<li>原型：<code>int pthread_mutex_unlock(pthread_mutex_t * mutex);</code></li>
</ul>
</li>
<li><h4 id="使用互斥的流程"><a href="#使用互斥的流程" class="headerlink" title="使用互斥的流程"></a>使用互斥的流程</h4><ul>
<li>定义pthread_mutex_t类型的变量，将其地址作为第一个参数传给pthread_mutex_init()函数；初始化函数只需调用一次</li>
<li>锁定或尝试锁定该互斥；获得访问权后，执行正常程序代码；并在执行完毕后解锁</li>
</ul>
</li>
<li><h3 id="互斥属性"><a href="#互斥属性" class="headerlink" title="互斥属性"></a>互斥属性</h3><ul>
<li>pshared属性：进程共享属性</li>
<li>取值：PTHREAD_PROCESS_SHARED（跨进程共享），PTHREAD_PROCESS_PRIVATE（本进程内部共享）</li>
<li>type属性：互斥类型</li>
</ul>
</li>
<li><h4 id="互斥type属性"><a href="#互斥type属性" class="headerlink" title="互斥type属性"></a>互斥type属性</h4><ul>
<li>PTHREAD_MUTEX_NORMAL：普通锁<ul>
<li>被某个线程锁定后，其他请求加锁的线程将等待</li>
<li>容易导致死锁</li>
<li>解锁被其他线程锁定或已解锁的互斥，将导致不可预期的后果</li>
</ul>
</li>
<li>PTHREAD_MUTEX_ERRORCHECK：检错锁<br>  被其他线程锁定的互斥加锁，将返回EDEADLK</li>
<li>PTHREAD_MUTEX_RECURSIVE：递归锁<br>   允许线程对互斥多次加锁；解锁次数必须与加锁次数匹配</li>
<li>PTHREAD_MUTEX_DEFAULT：默认锁<ul>
<li>实现上可能为上述三种之一</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="互斥属性函数"><a href="#互斥属性函数" class="headerlink" title="互斥属性函数"></a>互斥属性函数</h4><ul>
<li>初始化互斥属性对象：<code>int pthread_mutexattr_init(pthread_mutexatt_t * attr);</code></li>
<li>销毁互斥属性对象：<code>int pthread_mutexattr_destroy(pthread_mutexatt_t * attr);</code></li>
<li>获取pshared属性：<code>int pthread_mutexattr_getpshared(const pthread_mutex_t * mutex, int * pshared);</code></li>
<li>设置pshared属性：<code>int pthread_mutexattr_setpshared(pthread_mutex_t * mutex, int pshared);</code></li>
<li>获取type属性：<code>int pthread_mutexattr_gettype(const pthread_mutex_t * mutex, int * type);</code></li>
<li>设置type属性：<code>int pthread_mutexattr_settype(pthread_mutex_t * mutex, int type);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  完整程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Job(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  一般要求临界区代码越短越好，执行时间越短越好，使用C++ STL可能并不是好选择</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Job *&gt; job_queue;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> job_queue_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//  此处作业处理工作仅为示例，简单输出线程ID和作业内容信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessJob</span><span class="params">(Job *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; processing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  处理作业时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DequeueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            job = job_queue.front(); <span class="comment">//  获取表头元素</span></span><br><span class="line">            job_queue.pop_front();	 <span class="comment">//  删除表头元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ProcessJob(job);</span><br><span class="line">        <span class="keyword">delete</span> job, job = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  作业入队时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">EnqueueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Job *job = <span class="keyword">reinterpret_cast</span>&lt;Job *&gt;(arg);</span><br><span class="line">    pthread_mutex_lock(&amp;job_queue_mutex); <span class="comment">//  锁定互斥</span></span><br><span class="line">    job_queue.push_back(job);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  入队时也输出线程ID和作业内容信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; enqueueing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;job_queue_mutex); <span class="comment">//  解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = <span class="keyword">new</span> Job(i + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, EnqueueJob, job);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, DequeueJob, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li><h4 id="死锁：资源被竞争占用，且无法释放"><a href="#死锁：资源被竞争占用，且无法释放" class="headerlink" title="死锁：资源被竞争占用，且无法释放"></a>死锁：资源被竞争占用，且无法释放</h4></li>
<li><h4 id="处理策略：更改互斥类型"><a href="#处理策略：更改互斥类型" class="headerlink" title="处理策略：更改互斥类型"></a>处理策略：更改互斥类型</h4><ul>
<li>创建互斥属性pthread_mutexattr_t型的对象</li>
<li>调用pthread_mutexattr_init()函数初始化互斥属性对象，传递其地址</li>
<li>调用pthread_mutexattr_setkind_np()函数设置互斥类型，函数第一个参数为指向互斥属性对象的指针，第二个参数为PTHREAD_MUTEX_RECURSIVE_NP（递归互斥）或PTHREAD_MUTEX_ERRORCHECK_NP（检错互斥）</li>
<li>调用pthread_mutexattr_destroy()函数销毁互斥属性对象</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol>
<li><h4 id="问题：如何确保任务队列中有任务可以做？"><a href="#问题：如何确保任务队列中有任务可以做？" class="headerlink" title="问题：如何确保任务队列中有任务可以做？"></a>问题：如何确保任务队列中有任务可以做？</h4><ul>
<li>如果队列中没有任务，线程可能退出，后续任务出现时，没有线程可以执行它</li>
</ul>
</li>
<li><h4 id="POSIX标准信号量：头文件“semaphore-h”"><a href="#POSIX标准信号量：头文件“semaphore-h”" class="headerlink" title="POSIX标准信号量：头文件“semaphore.h”"></a>POSIX标准信号量：头文件“semaphore.h”</h4><ul>
<li>用于多个线程的同步操作</li>
<li>操作方法比进程信号量简单</li>
</ul>
</li>
<li><h4 id="初始化信号量"><a href="#初始化信号量" class="headerlink" title="初始化信号量"></a>初始化信号量</h4><ul>
<li>原型：<code>int sem_init(sem_t * sem, int pshared, unsigned int value);</code></li>
<li>参数：sem为信号量对象，pshared为共享属性，value为信号量初始值</li>
</ul>
</li>
<li><h4 id="等待信号量：P操作"><a href="#等待信号量：P操作" class="headerlink" title="等待信号量：P操作"></a>等待信号量：P操作</h4><ul>
<li>原型：<code>int sem_wait(sem_t * sem);</code></li>
<li>原型：<code>int sem_trywait(sem_t * sem);</code></li>
<li>原型：<code>int sem_timewait(sem_t * sem, const struct timespec * abs_timeout);</code></li>
<li>说明：sem_wait()在无法操作时阻塞， sem_trywait()则立即返回，sem_timewait()与sem_wait()类似，但有时间限制</li>
</ul>
</li>
<li><h4 id="发布信号量：V操作"><a href="#发布信号量：V操作" class="headerlink" title="发布信号量：V操作"></a>发布信号量：V操作</h4><ul>
<li>原型：<code>int sem_post(sem_t * sem);</code></li>
</ul>
</li>
<li><h4 id="销毁信号量"><a href="#销毁信号量" class="headerlink" title="销毁信号量"></a>销毁信号量</h4><ul>
<li>原型：<code>int sem_destroy(sem_t * sem);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  完整程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Job(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Job *&gt; job_queue;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> job_queue_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  控制作业数目的信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> job_queue_count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessJob</span><span class="params">(Job *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; processing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  处理作业时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DequeueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = <span class="literal">NULL</span>;</span><br><span class="line">        sem_wait(&amp;job_queue_count); <span class="comment">//  等待作业队列中有新作业</span></span><br><span class="line">        pthread_mutex_lock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            job = job_queue.front(); <span class="comment">//  获取表头元素</span></span><br><span class="line">            job_queue.pop_front();	 <span class="comment">//  删除表头元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ProcessJob(job);</span><br><span class="line">        <span class="keyword">delete</span> job, job = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  作业入队时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">EnqueueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Job *job = <span class="keyword">reinterpret_cast</span>&lt;Job *&gt;(arg);</span><br><span class="line">    pthread_mutex_lock(&amp;job_queue_mutex); <span class="comment">//  锁定互斥</span></span><br><span class="line">    job_queue.push_back(job);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  新作业入队，递增信号量</span></span><br><span class="line">    sem_post(&amp;job_queue_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  入队时也输出线程ID和作业内容信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; enqueueing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;job_queue_mutex); <span class="comment">//  解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">        job_queue.clear();</span><br><span class="line">    sem_init(&amp;job_queue_count, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//  初始化，非进程共享，初始值0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *p = <span class="keyword">new</span> Job(i + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, EnqueueJob, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, DequeueJob, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>); <span class="comment">//  等待线程终止，无作业时线程被阻塞</span></span><br><span class="line">    sem_destroy(&amp;job_queue_count);		<span class="comment">//  销毁作业信号量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ol>
<li><h4 id="条件变量的功能与目的"><a href="#条件变量的功能与目的" class="headerlink" title="条件变量的功能与目的"></a>条件变量的功能与目的</h4><ul>
<li>互斥用于同步线程对共享数据对象的访问</li>
<li>条件变量用于在线程间同步共享数据对象的值</li>
</ul>
</li>
<li><h4 id="初始化条件变量"><a href="#初始化条件变量" class="headerlink" title="初始化条件变量"></a>初始化条件变量</h4><ul>
<li>原型：<code>int pthread_cond_init(pthread_cond_t * cond, const pthread_condattr_t * cond_attr);</code></li>
<li>可使用宏PTHREAD_COND_INITIALIZER代替</li>
</ul>
</li>
<li><h4 id="销毁条件变量"><a href="#销毁条件变量" class="headerlink" title="销毁条件变量"></a>销毁条件变量</h4><ul>
<li>原型：<code>int pthread_cond_destroy(pthread_cond_t * cond);</code></li>
</ul>
</li>
<li><h4 id="广播条件变量"><a href="#广播条件变量" class="headerlink" title="广播条件变量"></a>广播条件变量</h4><ul>
<li>原型：<code>int pthread_cond_broadcast(pthread_cond_t * cond);</code></li>
<li>以广播方式唤醒所有等待目标条件变量的线程</li>
</ul>
</li>
<li><h4 id="唤醒条件变量"><a href="#唤醒条件变量" class="headerlink" title="唤醒条件变量"></a>唤醒条件变量</h4><ul>
<li>原型：<code>int pthread_cond_signal(pthread_cond_t * cond);</code></li>
</ul>
</li>
<li><h4 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h4><ul>
<li>原型：<code>int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex);</code></li>
<li>参数：mutex为互斥，以确保函数操作的原子性</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="四-C-11线程库"><a href="#四-C-11线程库" class="headerlink" title="四. C++11线程库"></a>四. C++11线程库</h1><ol>
<li><h3 id="支持平台无关的并行程序开发"><a href="#支持平台无关的并行程序开发" class="headerlink" title="支持平台无关的并行程序开发"></a>支持平台无关的并行程序开发</h3></li>
<li><h3 id="库：atomic、thread、mutex、condition-variable、future"><a href="#库：atomic、thread、mutex、condition-variable、future" class="headerlink" title="库：atomic、thread、mutex、condition_variable、future"></a>库：atomic、thread、mutex、condition_variable、future</h3><ul>
<li>thread：std::thread类与std::this_thread名空间</li>
<li>mutex：互斥相关类，包括std::mutex系列类，std::lock_guard类、std::unique_lock类及其他型式和函数</li>
<li>condition_variable：条件变量类，包括 std::condition_variable类与std::condition_variable_any类</li>
<li>atomic：std::atomic类与std::atomic_flag类，另外还有一套C风格的原子型式和原子操作函数</li>
<li>future：包含两个承诺类（std::promise类、std::packaged_task类）、两个期许类（std::future类、std::shared_future类）及相关型式和函数</li>
</ul>
</li>
<li><h3 id="线程类：thread"><a href="#线程类：thread" class="headerlink" title="线程类：thread"></a>线程类：thread</h3><ul>
<li>支持的线程函数无参数和返回值型式的特别要求，有无参数均可，返回值有无亦可</li>
<li>与Linux线程机制相比，C++11线程类更易用</li>
<li>线程局部存储使用thread_local关键字</li>
<li>可派生自己的thread类，但实现上需特别注意</li>
<li>线程类应支持移动语义，但不应支持拷贝语义</li>
</ul>
</li>
<li><h3 id="常用线程类成员函数"><a href="#常用线程类成员函数" class="headerlink" title="常用线程类成员函数"></a>常用线程类成员函数</h3><ul>
<li>判断线程是否可联：bool thread::joinable();</li>
<li>等待线程结束：void thread::join();</li>
<li>分离线程：void thread::detach();</li>
</ul>
</li>
<li><h3 id="定义于名空间this-thread的线程管理函数"><a href="#定义于名空间this-thread的线程管理函数" class="headerlink" title="定义于名空间this_thread的线程管理函数"></a>定义于名空间this_thread的线程管理函数</h3><ul>
<li>获取线程ID：thread::id get_id();</li>
<li>在处于等待状态时，让调度器选择其他线程执行：void yield();</li>
<li>阻塞当前线程指定时长：<code>template&lt;typename _Rep, typename _Period&gt; void sleep_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime);</code></li>
<li>阻塞当前线程至指定时点：<code>template&lt;typename _Clock, typename _Duration&gt; void sleep_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  无参数线程函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(&amp;ThreadFunc)</span></span>; <span class="comment">//  创建线程对象并运行</span></span><br><span class="line">    t.join();										<span class="comment">//  等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  带双参数的线程函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//  C++11标准库使用可变参数的模板形式参数列表，线程函数参数个数任意</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(&amp;ThreadFunc, m, n)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  带双参数的函子对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(Functor(), m, n)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用std::bind()函数绑定对象及其普通成员函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Worker(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) : _a(a), _b(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span> </span>&#123;  …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a, _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Worker <span class="title">worker</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::bind(&amp;Worker::ThreadFunc, &amp;worker))</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="互斥类"><a href="#互斥类" class="headerlink" title="互斥类"></a>互斥类</h3><ol>
<li><h4 id="基本互斥：mutex类"><a href="#基本互斥：mutex类" class="headerlink" title="基本互斥：mutex类"></a>基本互斥：mutex类</h4><ul>
<li>核心成员函数lock()、try_lock()和unlock()</li>
<li>上述成员函数无参数，无返回值</li>
</ul>
</li>
<li><h4 id="递归互斥：recursive-mutex类"><a href="#递归互斥：recursive-mutex类" class="headerlink" title="递归互斥：recursive_mutex类"></a>递归互斥：recursive_mutex类</h4><ul>
<li>允许单个线程对互斥进行多次加锁与解锁处理</li>
</ul>
</li>
<li><h4 id="定时互斥：timed-mutex类"><a href="#定时互斥：timed-mutex类" class="headerlink" title="定时互斥：timed_mutex类"></a>定时互斥：timed_mutex类</h4><ul>
<li>在某个时段里或者某个时刻前获取互斥</li>
<li>当线程在临界区操作的时间非常长，可以用定时锁指定时间</li>
</ul>
</li>
<li><h4 id="定时递归互斥：recursive-timed-mutex类"><a href="#定时递归互斥：recursive-timed-mutex类" class="headerlink" title="定时递归互斥：recursive_timed_mutex类"></a>定时递归互斥：recursive_timed_mutex类</h4><ul>
<li>综合timed_mutex和recursive_mutex</li>
</ul>
</li>
<li><h4 id="共享定时互斥：shared-timed-mutex类（C-14）"><a href="#共享定时互斥：shared-timed-mutex类（C-14）" class="headerlink" title="共享定时互斥：shared_timed_mutex类（C++14）"></a>共享定时互斥：shared_timed_mutex类（C++14）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.lock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; is entering...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; is leaving...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    x.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread *&gt; <span class="title">v</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        v[i] = <span class="keyword">new</span> <span class="built_in">std</span>::thread(ThreadFunc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        v[i]-&gt;join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="互斥的问题：容易导致死锁"><a href="#互斥的问题：容易导致死锁" class="headerlink" title="互斥的问题：容易导致死锁"></a>互斥的问题：容易导致死锁</h4><ul>
<li>若某个线程在临界区内的操作导致异常，有可能无法解锁，从而导致其他线程被永久阻塞</li>
<li>若临界区代码有多路分支，其中部分分支提前结束，但没有执行解锁操作，其他线程依然被永久阻塞</li>
<li>当多个线程同时申请多个资源时，加锁次序不同也可能导致死锁</li>
</ul>
</li>
<li><h4 id="资源获取即初始化（resource-acquisition-is-initialization-RAII）"><a href="#资源获取即初始化（resource-acquisition-is-initialization-RAII）" class="headerlink" title="资源获取即初始化（resource acquisition is initialization, RAII）"></a>资源获取即初始化（resource acquisition is initialization, RAII）</h4><ul>
<li>使用互斥对象管理类模板自动管理资源</li>
</ul>
</li>
<li><h4 id="基于作用域的锁管理类模板：std-lock-guard"><a href="#基于作用域的锁管理类模板：std-lock-guard" class="headerlink" title="基于作用域的锁管理类模板：std::lock_guard"></a>基于作用域的锁管理类模板：std::lock_guard</h4><ul>
<li>构造时是否加锁可选，不加锁时假定当前线程已获得锁的所有权，析构时自动解锁，所有权不可转移，对象生存期内不允许手动加锁和解锁</li>
</ul>
</li>
<li><h4 id="独一锁管理类模板：std-unique-lock"><a href="#独一锁管理类模板：std-unique-lock" class="headerlink" title="独一锁管理类模板：std::unique_lock"></a>独一锁管理类模板：std::unique_lock</h4><ul>
<li>构造时是否加锁可选，对象析构时如果持有锁会自动解锁，所有权可转移，对象生存期内允许手动加锁和解锁</li>
</ul>
</li>
<li><h4 id="共享锁管理类模板：std-shared-lock（C-14）"><a href="#共享锁管理类模板：std-shared-lock（C-14）" class="headerlink" title="共享锁管理类模板：std::shared_lock（C++14）"></a>共享锁管理类模板：std::shared_lock（C++14）</h4><ul>
<li>用于管理可转移和共享所有权的互斥对象</li>
</ul>
</li>
<li><h4 id="互斥管理策略"><a href="#互斥管理策略" class="headerlink" title="互斥管理策略"></a>互斥管理策略</h4><ul>
<li>延迟：std::defer_lock，构造互斥管理对象时延迟加锁操作</li>
<li>尝试：std::try_to_lock，构造互斥管理对象时尝试加锁操作，但不阻塞线程，互斥不可用时立即返回</li>
<li>接收：std::adopt_lock，假定当前线程已获得互斥所有权，不再加锁</li>
<li>缺省行为：构造互斥管理对象时没有传递管理策略标签参数，阻塞当前线程至成功获得互斥</li>
</ul>
</li>
<li><h4 id="互斥的解锁时机"><a href="#互斥的解锁时机" class="headerlink" title="互斥的解锁时机"></a>互斥的解锁时机</h4><ul>
<li>当使用C++11的互斥自动管理策略时，只有析构互斥管理对象时才自动释放互斥，因此要特别注意互斥的持有时间；若线程持有互斥的时间过长，有可能极大降低程序效率</li>
<li>解决方案：使用复合语句块或专用辅助函数封装临界区操作；动态创建互斥管理对象，并尽早动态释放</li>
</ul>
</li>
<li><h4 id="多个互斥的竞争访问"><a href="#多个互斥的竞争访问" class="headerlink" title="多个互斥的竞争访问"></a>多个互斥的竞争访问</h4><ul>
<li>多个线程对多个互斥加锁时保持顺序一致性，以避免可能的死锁</li>
<li>使用std::lock()或std::try_lock()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用互斥管理策略类重新实现线程函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Worker(int no, T a = 0, T b = 0) : _no(no), _a(a), _b(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(T *r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;																				 <span class="comment">// 使用复合语句块封装临界区操作，块结束时即释放局部对象</span></span><br><span class="line">            <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(x)</span></span>; <span class="comment">//  构造对象的同时加锁</span></span><br><span class="line">            *r = _x + _y;</span><br><span class="line">        &#125; <span class="comment">//  无需手工解锁，locker对象在析构时自动解锁</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread No: &quot;</span> &lt;&lt; _no &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; _a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; _b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; _a + _b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    T _a, _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  转账处理示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> balance)</span> : _<span class="title">balance</span><span class="params">(balance)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetBalance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _balance; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Increase</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123; _balance += amount; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Decrease</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123; _balance -= amount; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mutex &amp;<span class="title">GetMutex</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> _balance;</span><br><span class="line">    <span class="built_in">std</span>::mutex _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  避免死锁，使用std::lock()函数锁定多个互斥，不同的锁定顺序不会导致死锁</span></span><br><span class="line"><span class="comment">//  加锁时有可能引发异常，std::lock()函数会处理该异常</span></span><br><span class="line"><span class="comment">//  将解锁此前已加锁的部分互斥，然后重新引发该异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transfer</span><span class="params">(Account &amp;from, Account &amp;to, <span class="keyword">double</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker1</span><span class="params">(from.GetMutex(), <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker2</span><span class="params">(to.GetMutex(), <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::lock(from.GetMutex(), to.GetMutex());</span><br><span class="line">    from.Decrease(amount);</span><br><span class="line">    to.Increase(amount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a1(100.0), a2(200.0);</span><br><span class="line">    <span class="comment">//  线程参数采用值传递机制，如果要传递引用，调用std::ref()函数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(Transfer, <span class="built_in">std</span>::ref(a1), <span class="built_in">std</span>::ref(a2), <span class="number">10.0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(Transfer, <span class="built_in">std</span>::ref(a2), <span class="built_in">std</span>::ref(a1), <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="条件变量类"><a href="#条件变量类" class="headerlink" title="条件变量类"></a>条件变量类</h3><ol>
<li><h4 id="std-condition-variable类"><a href="#std-condition-variable类" class="headerlink" title="std::condition_variable类"></a>std::condition_variable类</h4><ul>
<li>必须与std::unique_lock配合使用</li>
</ul>
</li>
<li><h4 id="std-condition-variable-any类"><a href="#std-condition-variable-any类" class="headerlink" title="std::condition_variable_any类"></a>std::condition_variable_any类</h4><ul>
<li>更加通用的条件变量，可以与任意型式的互斥锁配合使用，相比前者使用时会有额外的开销</li>
</ul>
</li>
<li><h4 id="多线程通信同步原语"><a href="#多线程通信同步原语" class="headerlink" title="多线程通信同步原语"></a>多线程通信同步原语</h4><ul>
<li>阻塞一个或多个线程至收到来自其他线程的通知，超时或发生虚假唤醒</li>
<li>两者具有同样的成员函数，且在等待条件变量前都必须要获得相应的锁</li>
</ul>
</li>
<li><h4 id="成员函数notify-one-：通知一个等待线程"><a href="#成员函数notify-one-：通知一个等待线程" class="headerlink" title="成员函数notify_one()：通知一个等待线程"></a>成员函数notify_one()：通知一个等待线程</h4><ul>
<li>原型：<code>void motify_one() noexcept;</code></li>
</ul>
</li>
<li><h4 id="成员函数notify-all-：通知全部等待线程"><a href="#成员函数notify-all-：通知全部等待线程" class="headerlink" title="成员函数notify_all()：通知全部等待线程"></a>成员函数notify_all()：通知全部等待线程</h4><ul>
<li>原型：<code>void motify_one() noexcept;</code></li>
</ul>
</li>
<li><h5 id="成员函数wait-：阻塞当前线程至被唤醒"><a href="#成员函数wait-：阻塞当前线程至被唤醒" class="headerlink" title="成员函数wait()：阻塞当前线程至被唤醒"></a>成员函数wait()：阻塞当前线程至被唤醒</h5><ul>
<li>原型：<code>template&lt;typename Lock&gt; void wait(Lock &amp; lock);</code></li>
<li>原型：<code>template&lt;typename Lock, typename Predicate&gt; void wait(Lock &amp; lock, Predicate p);</code></li>
</ul>
</li>
<li><h4 id="成员函数wait-for-：阻塞至被唤醒或超过指定时长"><a href="#成员函数wait-for-：阻塞至被唤醒或超过指定时长" class="headerlink" title="成员函数wait_for()：阻塞至被唤醒或超过指定时长"></a>成员函数wait_for()：阻塞至被唤醒或超过指定时长</h4><ul>
<li>原型：<code>template&lt;typename Lock, typename Rep, typename _Period&gt; cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rtime);</code></li>
<li>原型：<code>template&lt;typename Lock, typename Rep, typename Period, typename Predicate&gt; bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rtime, Predicate p);</code></li>
</ul>
</li>
<li><h4 id="成员函数wait-until-：阻塞至被唤醒或到达指定时点"><a href="#成员函数wait-until-：阻塞至被唤醒或到达指定时点" class="headerlink" title="成员函数wait_until()：阻塞至被唤醒或到达指定时点"></a>成员函数wait_until()：阻塞至被唤醒或到达指定时点</h4><ul>
<li>原型：<code>template&lt;typename Lock, typename Clock, typename Duration&gt; cv_status wait_until(Lock &amp; lock,  const chrono::time_point&lt;Clock, Duration&gt;&amp; atime);</code></li>
<li>原型：<code>template&lt;typename Lock, typename Clock, typename Duration, typename Predicate&gt; bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; atime, Predicate p);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex x;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsReady</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ready; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready)			 <span class="comment">//  若标志位非true，阻塞当前线程</span></span><br><span class="line">        cond.wait(locker); <span class="comment">//  解锁并睡眠，被唤醒后重新加锁</span></span><br><span class="line">    <span class="comment">//  以上两行代码等价于cond.wait( locker, &amp;IsReady );</span></span><br><span class="line">    <span class="comment">//  第二个参数为谓词，亦可使用函子实现</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(Run, i);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;8 threads ready...\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(x)</span></span>; <span class="comment">//  互斥加锁</span></span><br><span class="line">        ready = <span class="literal">true</span>;														<span class="comment">//  设置全局标志位为true</span></span><br><span class="line">        cond.notify_all();											<span class="comment">//  唤醒所有线程</span></span><br><span class="line">    &#125;																					<span class="comment">//  离开作用域，自动解锁；可将此复合语句块实现为函数</span></span><br><span class="line">    <span class="comment">//  基于区间的循环结构，对属于threads数组的所有元素t，执行循环体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads)</span><br><span class="line">        t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="原子型式"><a href="#原子型式" class="headerlink" title="原子型式"></a>原子型式</h3><ol>
<li><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>使用atomic模板定义原子对象</li>
<li>使用预定义标准原子型式：atomic_bool、atomic_char、atomic_int、atomic_uint、atomic_long、atomic_wchar_t等等</li>
</ul>
</li>
<li><h4 id="意义：轻量级，支持单变量上的原子操作"><a href="#意义：轻量级，支持单变量上的原子操作" class="headerlink" title="意义：轻量级，支持单变量上的原子操作"></a>意义：轻量级，支持单变量上的原子操作</h4></li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">atomic_flag</th>
<th align="center">atomic<bool></th>
<th align="center">atomic<int_t></th>
<th align="center">atomic&lt;T*&gt;</th>
<th align="center">atomic<other_t></th>
</tr>
</thead>
<tbody><tr>
<td align="center">test_and_set</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">clear</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">is_lock_free</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">store</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">exchange</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">compare_exchange_weak, compare_exchange_strong</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">fetch_add, +=</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">fetch_sub, -=</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">fetch_or, |=</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">fetch_and, &amp;=</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">fetch_xor, ^=</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">++, –</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddAtomically</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">		a.fetch_add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">		++n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::thread ts1[<span class="number">8</span>], ts2[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts1)</span><br><span class="line">		t = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(AddAtomically, <span class="number">1000000</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts2)</span><br><span class="line">		t = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(Add, <span class="number">1000000</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts1)</span><br><span class="line">		t.join();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts2)</span><br><span class="line">		t.join();</span><br><span class="line">	<span class="comment">//  输出结果：a值固定，而n值多次运行结果可能不同</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><h3 id="期许与承诺"><a href="#期许与承诺" class="headerlink" title="期许与承诺"></a>期许与承诺</h3><ol>
<li><h4 id="线程返回值"><a href="#线程返回值" class="headerlink" title="线程返回值"></a>线程返回值</h4><ul>
<li>为支持跨平台，thread类无属性字段保存线程函数的返回值</li>
</ul>
</li>
<li><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>使用指针型式的函数参数</li>
<li>使用期许：std::future类模板</li>
<li>使用承诺：std::promise类模板</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="指针型式参数"><a href="#指针型式参数" class="headerlink" title="指针型式参数"></a>指针型式参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//  定义能够存储8个三元组的向量v，元组首元素为指向劳工对象的指针</span></span><br><span class="line">	<span class="comment">//  次元素保存该劳工对象计算后的结果数据，尾元素为指向劳工线程对象的指针</span></span><br><span class="line">	<span class="comment">//  向量中的每个元素都表示一个描述线程运行的线程对象，</span></span><br><span class="line">	<span class="comment">//  该线程对象对应的执行具体任务的劳工对象，及该劳工对象运算后的返回值</span></span><br><span class="line">	std::vector&lt;std::tuple&lt;Worker&lt;int&gt; *, int, std::thread *&gt;&gt; v(8);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  构造三元组向量，三元编号顺次为0、1、2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		v[i] = <span class="built_in">std</span>::make_tuple(<span class="keyword">new</span> Worker&lt;<span class="keyword">int</span>&gt;(i, i + <span class="number">1</span>, i + <span class="number">2</span>), <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  输出处理前结果；使用std::get&lt;n&gt;(v[i])获取向量的第i个元组的第n个元素</span></span><br><span class="line">	<span class="comment">//  三元编号顺次为0、1、2，因而1号元保存的将是劳工对象运算后的结果</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No. &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: result = &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(v[i]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//  创建8个线程分别计算</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//  将劳工类成员函数绑定为线程函数，对应劳工对象绑定为执行对象</span></span><br><span class="line">		<span class="comment">//  将构造线程对象时传递的附加参数作为被绑定的线程函数的第一个参数</span></span><br><span class="line">		<span class="comment">//  auto表示由编译器自动推断f的型式</span></span><br><span class="line">		<span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;Worker&lt;<span class="keyword">int</span>&gt;::ThreadFunc,</span><br><span class="line">											 <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v[i]), <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//  动态构造线程对象，并保存到向量的第i个三元组中</span></span><br><span class="line">		<span class="comment">//  传递三元组的1号元地址，即将该地址作为线程函数的参数</span></span><br><span class="line">		<span class="comment">//  线程将在执行时将结果写入该地址</span></span><br><span class="line">		<span class="comment">//  此性质由绑定函数std::bind()使用占位符std::placeholders::_1指定</span></span><br><span class="line">		<span class="comment">//  线程对象为2号元，即三元组的最后一个元素</span></span><br><span class="line">		<span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i]) = <span class="keyword">new</span> <span class="built_in">std</span>::thread(f, &amp;<span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(v[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//  等待线程结束</span></span><br><span class="line">		<span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i])-&gt;join();</span><br><span class="line">		<span class="comment">//  销毁劳工对象</span></span><br><span class="line">		<span class="keyword">delete</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v[i]), <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v[i]) = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">//  销毁线程对象</span></span><br><span class="line">		<span class="keyword">delete</span> <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i]), <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i]) = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  输出线程计算后的结果</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No. &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: result = &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(v[i]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="期许"><a href="#期许" class="headerlink" title="期许"></a>期许</h3><ol>
<li><h4 id="std-future类模板"><a href="#std-future类模板" class="headerlink" title="std::future类模板"></a>std::future类模板</h4><ul>
<li>目的：获取异步操作结果，延迟引发线程的异步操作异常</li>
</ul>
</li>
<li><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>定义期许模板类的期许对象</li>
<li>使用std::async()函数的返回值初始化</li>
<li>调用期许对象的成员函数get()获取线程返回值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用期许对象获取线程返回值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">CalculateFactorial</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::range_error(<span class="string">&quot;The number is too big.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        r *= i;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//  启动异步线程，执行后台计算任务，并返回std::future对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; f = <span class="built_in">std</span>::async(CalculateFactorial, n);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  获取线程返回值，若线程已结束，立即返回，否则等待该线程计算完毕</span></span><br><span class="line">        <span class="comment">//  若线程引发异常，则延迟到std::future::get()或std::future::wait()调用时引发</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = f.get();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::range_error &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><ol>
<li><h4 id="std-promise类模板"><a href="#std-promise类模板" class="headerlink" title="std::promise类模板"></a>std::promise类模板</h4><ul>
<li>目的： 承诺对象允许期许对象获取线程对象创建的线程返回值</li>
</ul>
</li>
<li><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>创建承诺std::promise<T>对象</li>
<li>获取该承诺对象的相关期许std::future<T>对象</li>
<li>创建线程对象，并传递承诺对象</li>
<li>线程函数内部通过承诺模板类的成员函数set_value()、set_value_at_thread_exit()、set_exception()或set_exception_at_thread_exit()设置值或异常</li>
<li>通过期许对象等待并获取异步操作结果<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用承诺对象设置线程返回值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">CalculateFactorial</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::range_error(<span class="string">&quot;The number is too big.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        r *= i;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  CalculateFactorial()函数的包装函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCalculateFactorial</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::promise&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; &amp;&amp;promise, <span class="keyword">short</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; p;								 <span class="comment">//  创建承诺对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; f = p.get_future(); <span class="comment">//  获取相关期许对象</span></span><br><span class="line">    <span class="comment">//  启动线程，执行CalculateFactorial()函数的包装函数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(DoCalculateFactorial, <span class="built_in">std</span>::move(p), n)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = f.get();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::range_error &amp;e)</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cerr</span></span><br><span class="line">            &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  CalculateFactorial()函数的包装函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCalculateFactorial</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::promise&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; &amp;&amp;promise, <span class="keyword">short</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  设置线程返回值，供期许对象获取</span></span><br><span class="line">        promise.set_value(CalculateFactorial(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  捕获全部异常，并在期许获取线程返回值时重新引发</span></span><br><span class="line">        promise.set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>李素晴</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://lisuqing2020.github.io/2020/02/20/C++/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="线程编程">http://lisuqing2020.github.io/2020/02/20/C++/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless stating additionally.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/02/20/C++/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="prev" title="网络编程"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">网络编程</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/02/18/C++/%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="next" title="进程编程"><span class="post-nav-text">进程编程</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/lisuqing2020/lisuqing2020.github.io/issues?q=is:issue+线程编程">GitHub Issues</a></div><div id="valine-container"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function initValine() {
  const valineConfig = {"enable":true,"appId":null,"appKey":null,"placeholder":"你看一晃两三年，匆匆又夏天","avatar":null,"pageSize":10,"visitor":false,"highlight":true,"recordIP":false,"enableQQ":true,"appid":"p14aECEQvrlk4brHLOn0nij4-gzGzoHsz","appkey":"J93LFcbKRj9xFjUo40L5y1sj","meta":["nick","mail","link"],"el":"#valine-container","lang":"en"}
  valineConfig.path = window.location.pathname
  new Valine(valineConfig)
}
setTimeout(initValine, 1000)</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 李素晴</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.1.1</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.2.0</span></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="Total Visitors"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>