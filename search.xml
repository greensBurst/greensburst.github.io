<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>滑动窗口协议</title>
      <link href="2020/11/24/net/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE/"/>
      <url>2020/11/24/net/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>预备知识：<a href="https://juejin.im/post/6886088987878883336">可靠数据传输协议</a></p></blockquote><p>首先回顾一下rdt3.0协议，在rdt3.0中虽然实现了可靠数据传输，但它的性能问题在于它是一个停等协议，一个简单的解决办法是让它不以停等的方式运行，允许发送方发送多个分组而无须等待确认。</p><p>该技术称为流水线技术，相应也会带来一些问题。</p><ol><li>必须增加序号范围（rdt3.0中序号只有0和1），因为每个输送中的分组必须有一个唯一的序号。</li><li>发送端和接收端不得不缓存多个分组，因为必须保证交付给上层应用的数据是正确有序的。</li><li>协议必须能够处理分组丢失、损坏和延时过大的问题。两种解决方式分别为<strong>回退N步</strong>和<strong>选择重传</strong>。</li></ol><p>本文讲述<strong>回退N步（GBN）协议</strong>，也称作<strong>滑动窗口协议</strong>。</p><a id="more"></a><p>每个要发送的分组都需要被分配一个序号，下图是发送端维护的序号空间图示。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/749be9f5070f42158073e97874c1cb43~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>其中黄色区段和蓝色区段长度加和是一个固定的值，称为<strong>窗口长度</strong>。如果你理解了<a href="https://juejin.im/post/6888152283280850952">流量控制</a>和<a href="https://juejin.im/post/6888258656341606408">拥塞控制</a>就不难理解为什么要限制已发送但未被确认的分组数量。</p><blockquote><p>我们知道，分组的序号是承载在运输层协议首部字段里的，该字段的长度是固定的，那么序号的范围即序号空间也就是有限的，因此窗口无法一直向前推进，所以序号的运算需要使用模运算，对空间长度取余。即序号空间可以看做一个环。</p></blockquote><p><strong>GBN协议发送方的行为</strong></p><ul><li>当收到上层应用的数据，发送方检查是否有可用序号，有则会产生一个分组发送，并更新相应变量。无则将数据返还上层应用，或缓存数据，或要求上层仅当有可用序号才发送等等。</li><li>当收到序号n的ACK时，由于GBN协议采用<strong>累积确认</strong>，故所有序号小于等于n的分组已全部被正确接收，因此窗口会向前推进。</li><li>当超时事件发生（rdt3.0中的定时器机制），发送方会重传所有已发送但未被确认的分组，这也就是<strong>回退N步</strong>的含义。</li></ul><p><strong>GBN协议接收方的行为</strong></p><ul><li>接收到一个正确且有序的分组，发送一个ACK。</li><li>除了上面的其他所有情况，丢弃该分组，并为最近的正确且有序接收的分组重新发送ACK。</li></ul><blockquote><p>关于GBN协议接收方的第二条行为，你或许会问，如果接收方接收到了一个正确但失序的分组，假设它的序号是n+1，此时接收方缺少序号为n的分组。为什么不将n+1号分组缓存起来，等待n号分组接收成功，再将它们一起交付给上层应用？</p><p>注意发送方的第三条行为，如果发送方在超时时间内未收到n号分组的ACK，会重传所有已发送但未被确认的分组，其中就包括n+1号分组，因此接收方直接丢弃n+1号分组即可。</p></blockquote><p>在GBN协议中，发送方必须维护序号空间的三个分界点，但是接收方需要维护的唯一信息就是下一个按序接收的分组的序号。</p><p>GBN协议虽然避免了停等协议中的信道利用率问题，但GBN协议本身也有一些情况存在着性能问题，单个分组的差错就能引起GBN重传大量分组，随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。这个问题将会在<strong>选择重传（SR）协议</strong>中得到解决。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp拥塞控制</title>
      <link href="2020/11/22/net/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>2020/11/22/net/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>我们知道分组交换机在做分组转发也是需要时间的，所以在分组交换机中也有相应的缓存，用于存储到达的分组。很明显分组交换机中的缓存大小是有限的，那么当网络中的分组过多时，分组交换机中的缓存满，就会导致分组丢失。</p><blockquote><p>网络拥塞的代价：</p><ul><li>当分组到达速率接近链路容量时，分组经历巨大的排队时延。、</li><li>发送方必须执行重传以补偿因为缓存溢出而丢失的分组。</li><li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。</li><li>当一个分组沿一条路径被丢失时，每个上游路由器用于转发该分组而使用的传输容量最终被浪费掉了。</li></ul></blockquote><p>TCP提供了<strong>端到端拥塞控制</strong>，端系统通过对网络行为的观察，判断网络的拥塞。</p><a id="more"></a><blockquote><p>端到端拥塞控制指网络层不能为运输层拥塞控制提供显式帮助，反之称为网络辅助的拥塞控制。</p></blockquote><h2 id="如何限制发送速率？"><a href="#如何限制发送速率？" class="headerlink" title="如何限制发送速率？"></a>如何限制发送速率？</h2><p>类似<a href="https://juejin.im/post/6888152283280850952">TCP流量控制</a>，发送方维护了一个变量，称为<strong>拥塞窗口</strong>，通过控制<code>LastByteSent - LastByteAcked &lt;= min(cwnd, rwnd)</code>，即已发送未被确认数据量小于拥塞窗口和接收窗口，来限制发送速率。</p><p>忽略rwnd(接收窗口)的情况下，通过调节cwnd(拥塞窗口)的值，调整发送方向连接发送数据的速率。</p><h2 id="如何感知网络拥塞？"><a href="#如何感知网络拥塞？" class="headerlink" title="如何感知网络拥塞？"></a>如何感知网络拥塞？</h2><p>我们将一个TCP发送方的<strong>丢包事件</strong>定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。也就是说没有丢包事件发生，则网络良好；出现丢包事件，则网络拥塞。</p><h2 id="如何调节发送速率？"><a href="#如何调节发送速率？" class="headerlink" title="如何调节发送速率？"></a>如何调节发送速率？</h2><p>TCP发送方希望以尽量高的速率发送而不会使网络拥塞。</p><ul><li>一个丢包事件意味着拥塞，因此当丢失 报文段时应当降低发送速率。</li><li>一个先前未确认报文段的确认到达时，能够增加发送方的速率。</li><li>发送方会试探拥塞开始出现的速率，并从该速率后退，继续开始试探。</li></ul><h2 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h2><p>TCP拥塞控制算法包括三个部分：①慢启动；②拥塞避免；③快速恢复。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36c459e3a55c471ba1601d3b202145a5~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>慢启动以一个低速率开始，进行指数增长，如果快要到拥塞发生的速率了（通过慢启动阈值感知，即ssthresh变量），就进入拥塞避免，停止指数增长，转为线性增长。</p><p>且TCP拥塞控制算法对待超时和收到3个冗余ACK的态度是不一样的，虽然他们都标识着分组丢失，但是超时会比收到3个冗余ACK意味着更大的网络拥塞，因此超时都会重新开始慢启动，而收到3个冗余ACK则会进入快速恢复。</p><p>在快速恢复中，会探测是不是轻度拥塞（不需要把速率打到低谷），因此每收到一个冗余ACK会指数增加发送速率，直到超时（重度拥塞，重新开始慢启动）或收到新的ACK（轻度拥塞，拥塞解除了，进入拥塞避免线性增加发送速率）。</p><p>整个拥塞控制用一句话总结就是：TCP发送方希望以尽量高的速率发送而不会使网络拥塞。因此发送方的发送速率会随着时间呈现锯齿状。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a740c00e0e2a4227adaf9ea2f1219f71~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp流量控制</title>
      <link href="2020/11/03/net/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>2020/11/03/net/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>预备知识：<a href="https://juejin.im/post/6886088987878883336">可靠数据传输原理</a></p></blockquote><p>我们都知道TCP是面向连接的可靠传输协议，这个<strong>连接</strong>的意思就是在两个进程通讯之前需要相互发送某些预备报文段，以建立确保数据传输的参数。连接的双方都将初始化一些与连接相关的<strong>缓存</strong>、<strong>变量</strong>，这些都是TCP连接的组成部分。</p><p>其中之一就是<strong>接收缓存</strong>，当TCP连接接收到正确、按序的字节后，它就将数据放入接收缓存，上层应用会从该缓存中读数据。如果上层应用读取速率慢，发送方发送速率快，就会导致<strong>接收缓存溢出</strong>。TCP为了解决该问题，提供了<strong>流量控制服务</strong>。</p><p>流量控制即让发送方的发送速率和接收方应用进程读取速率相匹配，因此流量控制服务是一个<strong>速度匹配服务</strong>。TCP让<strong>发送方</strong>维护了一个变量，称为<strong>接收窗口</strong>，该变量指示了接收方还有多少可用的接收缓存空间。</p><p>TCP是<strong>全双工</strong>的，也就是说连接的两端都有各自的接收缓存和接收窗口。一方在向另一方发送报文段时，就会将自己可用的接收缓存空间大小放入接收窗口字段中。</p><blockquote><p>全双工：双向两车道。半双工：双向单车道。单工：单向单车道。</p></blockquote><p>发送端会维护两个变量：<strong>LastByteSent</strong>、<strong>LastByteAcked</strong>，通过控制<code>LastByteSent - LastByteAcked &lt;= rwnd</code>即已发送未被确认数据量小于等于接收窗口，就可以保证发送端不会使接收端接收缓存溢出。</p><p>还有一个需要注意的小问题是，某一时刻接收端告知发送端接收缓存已满，因此发送端不会再向接收端发送数据。如果此时接收端接收缓存有可用空间，但是接收端没有数据要发送给发送端，发送端也就无法更新接收窗口，就会被阻塞而不能再发送数据。</p><p>因此TCP要求当发送端接收窗口为0时，发送端会继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认，当接收端应用进程开始读取数据时，接收端就会回复发送端一个确认报文，该报文段会包含一个非0的接收窗口。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解kmp</title>
      <link href="2020/11/01/algo/%E5%9B%BE%E8%A7%A3kmp/"/>
      <url>2020/11/01/algo/%E5%9B%BE%E8%A7%A3kmp/</url>
      
        <content type="html"><![CDATA[<p>考虑一个字符串<code>string = &#39;baabaccbaabaabac&#39;</code>。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f6687d0ca24fcc8cc41a63120f4381~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>当前下标<code>i = 11</code>，从上图可以看到，i之前的字符串<code>string[:i] = &#39;baabaccbaab&#39;</code>的<strong>最长公共前后缀</strong>为<code>&#39;baab&#39;</code>，长度为4，我们用一个名为next的数组记录该长度，<code>next[i-1] = 4</code>。</p><p>可以看到上图中下标<code>j = 4</code>与下标<code>i = 11</code>处字符相等，我们可以由此推断出字符串<code>string[:i+1] = &#39;baabaccbaaba&#39;</code>的<strong>最长公共前后缀</strong>的长度值为5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = next[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">    next[i] = next[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那如果i和j处字符不等呢？</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5559aba86647bd815fe3b30b797e7f~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>此时当前下标来到<code>i = 12</code>的位置，此时i和j处字符不等，上面的代码自然也就不成立了。</p><p>想象让j处于i的身份…</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5f63249acd3437b9febbabde0e9fac4~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>既然<code>next[i]</code>不能由<code>next[i-1]</code>直接得到，那么不如试着从<code>next[j-1]</code>下手。</p><p>通过上图不难看出<code>next[j-1]</code>即<code>string[:j] = &#39;baaba&#39;</code>的<strong>最长公共前后缀</strong>的长度为2，且下标<code>k = 2</code>与下标<code>i = 12</code>处字符相等，我们可以由此推断出字符串<code>string[:i+1] = &#39;baabaccbaaba&#39;</code>的<strong>最长公共前后缀</strong>的长度值为3。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = next[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> k = next[j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">    next[i] = next[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; elif(s[i] == s[k]) &#123;</span><br><span class="line">    next[i] = next[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这种方法，我们可以求出整个next数组的值，<code>next[i]</code>的值表示从0开始以i结尾的字符串的<strong>最长公共前后缀</strong>的长度。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6139554760e54d2c95025c04c36d9325~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>给出代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = str[<span class="number">0</span>] == str[<span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = next[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] == str[i]) &#123;</span><br><span class="line">                next[i] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    j = next[j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那我们搞来这个next数组是为了啥呢？</strong></p><p>我们在一个长串中寻找<code>string = &#39;baabaccbaabaabac&#39;</code>，下图中绿色表示匹配成功，红色表示匹配失败，蓝色表示尚未匹配。</p><p>考虑匹配中的一个中间状态如下图。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ace647355d145848864389c63230492~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>在字符<code>&#39;a&#39;</code>的位置上匹配失败，我们并没有让短串向右错一个位置继续从头匹配，而是从<strong>最长公共前后缀</strong>的下一位开始匹配。这就是kmp较暴力匹配来的更快的地方。</p><p>在实际写代码的时候，我们需要对next数组稍作修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetNext()补充</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">next[i] = next[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>于是我们得到如下图所示的新next数组。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d633afd925034381b7baefa5fccc3983~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>给出代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>* str1, <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="built_in">strlen</span>(str1) &amp;&amp; j &lt; <span class="built_in">strlen</span>(str2)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i] == str2[j]) &#123;</span><br><span class="line">            ++i, ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="built_in">strlen</span>(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="built_in">strlen</span>(str2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在<a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode 28.实现 strStr()</a>尝试提交，通过了记得点个赞哦。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cc20</title>
      <link href="2020/10/30/C++/cc20/"/>
      <url>2020/10/30/C++/cc20/</url>
      
        <content type="html"><![CDATA[<p>C++20环境配置</p><a id="more"></a><blockquote><p>系统环境：deepin 15.11（ubuntu也是可以的）</p><p>GCC版本：GCC 10.2</p></blockquote><h2 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h2><p>首先我们进入<a href="https://gcc.gnu.org/">GCC官网</a>，找到下面这个看上去最新的版本。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/869bb3f6e3bb42adbe4852eb3e1a2e31~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>接着我们找到镜像站。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75aab6c205344ea08f873a9d0e7e2c25~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>然后发现没有中国的，不要紧，去俄国的就行。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddfaa789b8da4dfcba4a9126b51bcbac~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>找到<a href="http://mirror.linux-ia64.org/gnu/gcc/releases/gcc-10.2.0/gcc-10.2.0.tar.gz">gcc-10.2.0.tar.gz</a>，点击下载，然后解压就好了，镜像地址在<a href="http://mirror.linux-ia64.org/gnu/gcc/releases/gcc-10.2.0/">这里</a>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d2ce61857c4262b83f3c528245d386~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><h2 id="2-编译源码"><a href="#2-编译源码" class="headerlink" title="2. 编译源码"></a>2. 编译源码</h2><p>到此我们得到了<code>gcc-10.2.0</code>文件夹，我这里假设你将它放进了家目录。我们再创建一个<code>objdir</code>文件夹，用于存放编译源码得到的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/objdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/objdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ~/gcc-10.2.0/configure --disable-multilib</span></span><br></pre></td></tr></table></figure><p>接着configure脚本会提示你让你去一个<a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/">ftp</a>上下载相应的依赖（<a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2">GMP</a>、<a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2">MPFR</a>、<a href="ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz">MPC</a>），下载最新版并解压到<code>gcc-10.2.0</code>目录下。</p><p>重新执行configure脚本，等待编译完成后，使用<code>make</code>构建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/gcc-10.2.0/configure --disable-multilib</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3. 环境配置"></a>3. 环境配置</h2><p>执行<code>make install</code>，安装后，头文件在<code>/usr/local/include</code>，可执行文件在<code>/usr/local/bin</code>，库文件在<code>/usr/local/lib</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure><p>执行<code>gcc --version</code>，输出如下即安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc (GCC) 10.2.0</span><br><span class="line">Copyright © 2020 Free Software Foundation, Inc.</span><br></pre></td></tr></table></figure><p>我们去<a href="https://en.cppreference.com/w/cpp/container/span">cppreference</a>找一段C++20标准的代码编译试试！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;span&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> N&gt; [[nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">slide</span><span class="params">(<span class="built_in">std</span>::span&lt;T,N&gt; s, <span class="built_in">std</span>::<span class="keyword">size_t</span> offset, <span class="built_in">std</span>::<span class="keyword">size_t</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.subspan(offset, offset + width &lt;= s.size() ? width : <span class="number">0U</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> N, <span class="built_in">std</span>::<span class="keyword">size_t</span> M&gt; [[nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="built_in">std</span>::span&lt;T,N&gt; data, <span class="built_in">std</span>::span&lt;T,M&gt; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.size() &gt;= prefix.size() </span><br><span class="line">        &amp;&amp; <span class="built_in">std</span>::equal(prefix.begin(), prefix.end(), data.begin());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> N, <span class="built_in">std</span>::<span class="keyword">size_t</span> M&gt; [[nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">ends_with</span><span class="params">(<span class="built_in">std</span>::span&lt;T,N&gt; data, <span class="built_in">std</span>::span&lt;T,M&gt; suffix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.size() &gt;= suffix.size() </span><br><span class="line">        &amp;&amp; <span class="built_in">std</span>::equal(data.end() - suffix.size(), data.end(), </span><br><span class="line">                      suffix.end() - suffix.size());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> N, <span class="built_in">std</span>::<span class="keyword">size_t</span> M&gt; [[nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="built_in">std</span>::span&lt;T,N&gt; span, <span class="built_in">std</span>::span&lt;T,M&gt; sub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::search(span.begin(), span.end(), sub.begin(), sub.end())</span><br><span class="line">        != span.end();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; seq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : seq) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> a[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> b[] &#123; <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> offset&#123;&#125;; ; ++offset) &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> width&#123;<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> s = slide(<span class="built_in">std</span>::span&#123;a&#125;, offset, width);</span><br><span class="line">        <span class="keyword">if</span> (s.empty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        print(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static_assert</span>(starts_with(<span class="built_in">std</span>::span&#123;a&#125;, <span class="built_in">std</span>::span&#123;a,<span class="number">4</span>&#125;)</span><br><span class="line">        &amp;&amp; starts_with(<span class="built_in">std</span>::span&#123;a+<span class="number">1</span>, <span class="number">4</span>&#125;, <span class="built_in">std</span>::span&#123;a+<span class="number">1</span>,<span class="number">3</span>&#125;)</span><br><span class="line">        &amp;&amp; !starts_with(<span class="built_in">std</span>::span&#123;a&#125;, <span class="built_in">std</span>::span&#123;b&#125;)</span><br><span class="line">        &amp;&amp; !starts_with(<span class="built_in">std</span>::span&#123;a,<span class="number">8</span>&#125;, <span class="built_in">std</span>::span&#123;a+<span class="number">1</span>,<span class="number">3</span>&#125;)</span><br><span class="line">        &amp;&amp; ends_with(<span class="built_in">std</span>::span&#123;a&#125;, <span class="built_in">std</span>::span&#123;a+<span class="number">6</span>,<span class="number">3</span>&#125;)</span><br><span class="line">        &amp;&amp; !ends_with(<span class="built_in">std</span>::span&#123;a&#125;, <span class="built_in">std</span>::span&#123;a+<span class="number">6</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        &amp;&amp; contains(<span class="built_in">std</span>::span&#123;a&#125;, <span class="built_in">std</span>::span&#123;a+<span class="number">1</span>,<span class="number">4</span>&#125;)</span><br><span class="line">        &amp;&amp; !contains(<span class="built_in">std</span>::span&#123;a,<span class="number">8</span>&#125;, <span class="built_in">std</span>::span&#123;a,<span class="number">9</span>&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令&amp;执行结果如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ test20.cc --std=c++20</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out</span></span><br><span class="line">0 1 2 3 4 5 </span><br><span class="line">1 2 3 4 5 6 </span><br><span class="line">2 3 4 5 6 7 </span><br><span class="line">3 4 5 6 7 8</span><br></pre></td></tr></table></figure><p>至此我们C++20的环境就安装成功了！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> environ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可靠数据传输</title>
      <link href="2020/10/28/net/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
      <url>2020/10/28/net/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<p>网络层服务（IP服务）是不可靠的，IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性和正确性。运输层报文段是被IP数据报携带着在网络中传输的，因此运输层的报文段具有同样的问题。</p><p>我们试着用伪代码来实现可靠数据传输(reliable data transfer)。</p><a id="more"></a><h2 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h2><blockquote><p>前提：下层信道是完全可靠的，且收发速率一致。</p></blockquote><p>在这个简单协议中，接收端不需要提供任何反馈信息给发送方，因为下层信道是完全可靠的。也不需要请求发送方慢一点，因为收发速率是一致的。</p><p><strong>发送端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept(); <span class="comment">// 阻塞函数，等待上层数据</span></span><br><span class="line">    message = pack(data); <span class="comment">// 封装上层数据</span></span><br><span class="line">    transfer(message); <span class="comment">// 将数据报交付给下层信道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept(); <span class="comment">// 阻塞函数，等待下层数据</span></span><br><span class="line">    message = unpack(data); <span class="comment">// 拆分下层数据</span></span><br><span class="line">    deliver(message); <span class="comment">// 将数据报交付给上层应用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h2><blockquote><p>前提：分组可能会出现比特受损，但依旧保证分组有序到达。</p></blockquote><p>我们需要引入控制报文，让发送方知道哪些内容被正确接收，哪些内容有误并因此需要重复。基于这样重传机制的可靠数据传输协议称为<strong>自动重传请求(Automatic Repeat reQuest, ARQ)协议</strong>。</p><blockquote><p>ARQ协议有三种机制</p><ul><li>差错检测：tcp/udp报文段有一个16bits字段称为<strong>检验和</strong>。</li><li>接收方反馈：肯定确认(ACK)/否定确认(NAK)。</li><li>重传：接收方收到出错分组(发送方收到NAK)，重传该分组。</li></ul></blockquote><p>需要注意的是：当发送方处于等待ACK或NAK的状态时（recv），它不能从上层获取到更多的数据，由于这种行为，rdt2.0这样的协议被称为<strong>停等协议</strong>。</p><p><strong>发送端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept();<span class="comment">// 阻塞函数，等待上层数据</span></span><br><span class="line">    message = pack(data);<span class="comment">// 封装上层数据</span></span><br><span class="line">    transfer(message);<span class="comment">// 将数据报交付给下层信道</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    result = recv();<span class="comment">// 阻塞函数，等待收方反馈</span></span><br><span class="line">        <span class="keyword">if</span> result &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// ACK</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transfer(message);<span class="comment">// NAK</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept(); <span class="comment">// 阻塞函数，等待下层数据</span></span><br><span class="line">    <span class="keyword">if</span> check(data) &#123;</span><br><span class="line">        message = unpack(data); <span class="comment">// 拆分下层数据</span></span><br><span class="line">        deliver(message); <span class="comment">// 将数据报交付给上层应用</span></span><br><span class="line">        reply = pack(ACK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reply = pack(NAK);</span><br><span class="line">    &#125;</span><br><span class="line">    transfer(reply);<span class="comment">// 回复确认报文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h3><p>rdt2.0的一个问题是，如果确认报文受损，发送方无法知道接收方是否正确接收了刚刚发送的数据。考虑处理受损ACK/NAK的三种可能。</p><ol><li>发方询问，收方回复。但这之间依旧可能分组受损。</li><li>增加足够的比特使发方可以修复受损的比特，这对不会丢失分组的信道来说是可行的。</li><li>重传该分组，但接收方不知道收到的是新分组还是重传分组。</li></ol><p>可能3的解决办法是引入<strong>序号</strong>机制，对于停等协议来说，1bit的序号字段就足够了（接收到和上个分组一样序号的分组，就是重传分组，序号不一样的分组就是新分组）。</p><p><strong>发送端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept();<span class="comment">// 阻塞函数，等待上层数据</span></span><br><span class="line">    number ^= <span class="number">1</span>;</span><br><span class="line">    message = pack(data, number);<span class="comment">// 封装上层数据</span></span><br><span class="line">    transfer(message);<span class="comment">// 将数据报交付给下层信道</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    result = recv();<span class="comment">// 阻塞函数，等待收方反馈</span></span><br><span class="line">        <span class="keyword">if</span> result &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// ACK</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transfer(message);<span class="comment">// NAK</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept(); <span class="comment">// 阻塞函数，等待下层数据</span></span><br><span class="line">    <span class="keyword">if</span> check(data) &#123;</span><br><span class="line">        message = unpack(data); <span class="comment">// 拆分下层数据</span></span><br><span class="line">        <span class="keyword">if</span> message.number != number &#123;</span><br><span class="line">            deliver(message); <span class="comment">// 将数据报交付给上层应用</span></span><br><span class="line">            number = message.number;</span><br><span class="line">        &#125;</span><br><span class="line">        reply = pack(ACK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reply = pack(NAK);</span><br><span class="line">    &#125;</span><br><span class="line">    transfer(reply);<span class="comment">// 回复确认报文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h3><p>rdt2.1引入序号机制后，可以利用ACK实现和NAK一样的效果，当发送方接收到的是上一个分组序号的ACK，那么说明接收方没有成功接收当前分组。</p><p>rdt2.2是在有比特差错信道上实现的一个无NAK的可靠数据传输协议。</p><p><strong>发送端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept();<span class="comment">// 阻塞函数，等待上层数据</span></span><br><span class="line">    number ^= <span class="number">1</span>;</span><br><span class="line">    message = pack(data, number);<span class="comment">// 封装上层数据</span></span><br><span class="line">    transfer(message);<span class="comment">// 将数据报交付给下层信道</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    result = recv();<span class="comment">// 阻塞函数，等待收方反馈</span></span><br><span class="line">        <span class="keyword">if</span> result == number &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// ACK</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transfer(message);<span class="comment">// duplicate ACK</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept(); <span class="comment">// 阻塞函数，等待下层数据</span></span><br><span class="line">    reply = pack(ACK, number);</span><br><span class="line">    <span class="keyword">if</span> check(data) &#123;</span><br><span class="line">        message = unpack(data); <span class="comment">// 拆分下层数据</span></span><br><span class="line">        <span class="keyword">if</span> message.number != number &#123;<span class="comment">// 无损且新分组</span></span><br><span class="line">            deliver(message); <span class="comment">// 将数据报交付给上层应用</span></span><br><span class="line">            reply = pack(ACK, message.number);</span><br><span class="line">            number = message.number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    transfer(reply);<span class="comment">// 回复确认报文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h2><blockquote><p>前提：分组可能会出现比特受损，且下层信道还会丢包。</p></blockquote><p>无论是发送的分组或是响应的分组丢失，都会导致发送方收不到响应，发送方就会阻塞在<code>result = recv();</code>这里。因此无论是数据分组丢失，还是ACK分组丢失，发送方在等待一段时间（一个往返时延+接收方处理一个分组的时间）后就该重传分组。</p><p>为了实现基于时间的重传机制，需要一个<strong>定时器</strong>，每次发送一个分组（新分组或重传分组）便启动一个定时器，定时器在给定的时间量到达后中断发送方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    data = accept();<span class="comment">// 阻塞函数，等待上层数据</span></span><br><span class="line">    number ^= <span class="number">1</span>;</span><br><span class="line">    message = pack(data, number);<span class="comment">// 封装上层数据</span></span><br><span class="line">    transfer(message);<span class="comment">// 将数据报交付给下层信道</span></span><br><span class="line">    timer.start();</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    result = recv(timeout = []()&#123;</span><br><span class="line">            transfer(message);<span class="comment">// 超时重传</span></span><br><span class="line">            timer.start();</span><br><span class="line">        &#125;);<span class="comment">// 阻塞函数，等待收方反馈</span></span><br><span class="line">        <span class="keyword">if</span> result == number &#123;</span><br><span class="line">            timer.stop();</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// ACK</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为分组序号在0和1之间交替，因此rdt3.0有时被称为比特交替协议。</p><p>本文提到了多种保证可靠数据传输的机制：<strong>检验和、序号、定时器、肯定确认</strong>，每种机制都在协议的运行中起到了必不可少的作用，至此我们得到了一个可靠数据传输协议。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多路复用和多路分解</title>
      <link href="2020/10/23/net/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3/"/>
      <url>2020/10/23/net/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>运输层协议工作在主机内。从紧邻其下的网络层接收数据，并交付给相应的应用进程称为<strong>多路分解</strong>；从不同的应用进程收集数据，并交付给网络层称为<strong>多路复用</strong>。</p><p>学习过网络编程我们知道进程是通过套接字来进行网络通讯的，主机上每一个套接字都有唯一的标识符，使得运输层协议能够将从网络层接收的数据准确的交付给相应的进程。</p><p>多路分解中，运输层检查报文中相应字段，定向到唯一的套接字；多路复用中，为每个应用层数据封装首部信息后，交付到网络层。</p><a id="more"></a><p>一个udp套接字由一个二元组标识：(目的ip地址，目的端口号)。</p><p>一个tcp套接字由一个四元组标识：(源ip地址，源端口号，目的ip地址，目的端口号)。</p><p><strong>udp报文段结构</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5747daab45684378a176053bdc167d8a~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p><strong>tcp报文段结构</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccb0ead29bf6463da25b241ad35d5fdf~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p><strong>ipv4数据报格式</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81b7d63008344a278806bf311ca744b5~tplv-k3u1fbpfcp-watermark.image" loading="lazy"></p><p>上面给出了udp、tcp、ip的报文格式，可以看到(源ip地址，目的ip地址)在网络层获取，(源端口号，目的端口号)在运输层获取。</p><p>udp报文段的源端口号用作“返回地址”的一部分，即当收方需要回发时，报文段中的目的端口号便从发方到收方的报文段中的源端口号中取值。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kruskal</title>
      <link href="2020/10/18/algo/kruskal/"/>
      <url>2020/10/18/algo/kruskal/</url>
      
        <content type="html"><![CDATA[<p>kruskal是个贪心算法，对于n个节点的图，最小生成树有n-1条边。</p><p>初始设所有点为孤立点，我们每次取权值最小的边，如果该边两端点尚未连通，那么该边就是最小生成树的一条边，接着连通两点。</p><p>节点是否连通用到了并查集。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_root</span>(<span class="params">i, root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root[i] != i:</span><br><span class="line">        root[i] = find_root(root[i], root)</span><br><span class="line">    <span class="keyword">return</span> root[i]</span><br></pre></td></tr></table></figure><p>使用root数组记录节点i的祖先节点，如果两个节点拥有共同的祖先，则说明两节点连通。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造图，使用edges存储所有的边</span></span><br><span class="line">n, m = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">edges, mst = [], []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    x, y, z = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    edges.append((x, y, z))<span class="comment"># 节点1、节点2、权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有边按权值排序</span></span><br><span class="line">edges.sort(key = <span class="keyword">lambda</span> item: item[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造最小生成树(mst)</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mst) == n-<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    x, y, z = e</span><br><span class="line">    rx = find_root(x, root)</span><br><span class="line">    ry = find_root(y, root)</span><br><span class="line">    <span class="keyword">if</span> rx == ry:<span class="comment"># 如果两个节点连通</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    mst.append(e)</span><br><span class="line">    root[rx] = root[ry]<span class="comment"># 连通两个节点</span></span><br></pre></td></tr></table></figure><p>你可以在<a href="https://www.luogu.com.cn/problem/P3366#submit">洛谷 P3366</a>练习kruskal算法。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="2020/10/18/algo/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>2020/10/18/algo/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>众所周知，冒泡、选择、插入是三种简单排序，冒泡和选择排序的时间复杂度都是O(N^2)，但插入排序不一样，它的最好时间复杂度为O(N)，最坏时间复杂度为O(N^2)。</p><p>我们可以利用插入排序这个特点，想办法让数组变的基本有序，这样插入就变得快了起来。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr = &#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>我们现在有这样一个数组，长度为8，我们对它进行分组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">part1 = &#123;<span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">part2 = &#123;<span class="number">0</span>, <span class="number">9</span>&#125;;</span><br><span class="line">part3 = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">part4 = &#123;<span class="number">7</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>容易看出分组规则：将下标间隔为4的元素分到一组。我们利用插入排序让每个分组有序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>接着我们继续分组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">part1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">part2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>容易看出分组规则：将下标间隔为2的元素分到一组。我们利用插入排序让每个分组有序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>现在数组已经有序了，但是我们分组流程依旧要进行下去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>此时只有一个分组，下标间隔为1，我们对其做插入排序，时间复杂度为O(N)。</p><p>至此，希尔排序结束，给出代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step = size &gt;&gt; <span class="number">1</span>; step &gt; <span class="number">0</span>; step &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> begin = <span class="number">0</span>; begin &lt; step; ++begin) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = begin + step; i &lt; size; i += step) &#123;</span><br><span class="line">                <span class="keyword">int</span> j, basic = arr[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i - step; j &gt;= begin &amp;&amp; arr[j] &gt; basic; j -= step) &#123;</span><br><span class="line">                    arr[j+step] = arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+step] = basic;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了便于理解，附上插入排序实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, basic = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; basic; --j) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = basic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序之所以会快，核心在于<strong>无序时元素少，元素多时基本有序</strong>，但是这个基本到底有多基本其实并不确定，所以希尔排序的时间复杂度是依赖于样本数据的，最坏可以到达O(N^2)。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="2020/10/11/algo/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>2020/10/11/algo/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>考虑一个数组，我们有两个需求：①区间更新；②区间和查询。</p><p><strong>方案1</strong></p><p>最朴素的想法，时间复杂度都是O(n)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r):<span class="comment"># 区间更新</span></span><br><span class="line">    arr[i] += value</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r):<span class="comment"># 区间和查询</span></span><br><span class="line">    <span class="built_in">sum</span> += arr[i]</span><br></pre></td></tr></table></figure><p><strong>方案2</strong></p><p>高级点的想法，时间复杂度都是O(1)。这里用到了前缀数组和差分数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line">prefix, diff = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">19</span>], [<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,-<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">diff[l] += value<span class="comment"># 区间更新</span></span><br><span class="line">diff[r] -= value</span><br><span class="line"><span class="built_in">sum</span> = prefix[r] - prefix[l]<span class="comment"># 区间和查询</span></span><br></pre></td></tr></table></figure><p>还有点小问题，区间和查询的O(1)是建立在arr不会更新的前提上，如果arr是动态更新的，那么arr每更新一次，就需要重建prefix，代价是O(n)的时间复杂度。</p><p><strong>树状数组</strong></p><p>下面代码给出了树状数组的初始化，arr和tree的下标从1开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr  = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line">tree = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">i, value</span>):</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        tree[i] += value</span><br><span class="line">        i += i&amp;(-i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">    add(i, a[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> tree<span class="comment"># [0,2,2,1,10,0,9]</span></span><br></pre></td></tr></table></figure><p><code>i=i&amp;(-i)</code>将保留i的最低位的1，其余所有位置0。</p><p>那么我们如何基于树状数组做区间和查询？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">while</span> i:</span><br><span class="line">        <span class="built_in">sum</span> += tree[i]</span><br><span class="line">        i -= i&amp;(-i)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">    <span class="built_in">print</span> ask(i)<span class="comment"># 2 2 3 10 10 19</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = ask(r) - ask(l)</span><br></pre></td></tr></table></figure><p>add()时间复杂度为O(log(n))，ask()时间复杂度为O(log(n))。</p><p>若以add()做区间更新，承担O(nlog(n))的时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">    add(i, value)</span><br></pre></td></tr></table></figure><p>上面提到了区间更新可以使用差分数组优化时间，但是树状数组却是基于原数组建立的，如果我们基于原数组的差分数组建立树状数组，会是什么样子？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr &#x3D; [0,2,0,1,7,0,9]</span><br><span class="line">diff, tree &#x3D; [0,2,-2,1,6,-7,9], [0,0,0,0,0,0,0]</span><br><span class="line"></span><br><span class="line">for i in range(1, len(arr)):</span><br><span class="line">    add(i, diff[i])</span><br><span class="line"></span><br><span class="line">print tree# [0,2,0,1,7,-7,2]</span><br><span class="line"></span><br><span class="line">for i in range(1, len(arr)):</span><br><span class="line">    print ask(i)# 2 0 1 7 0 9</span><br></pre></td></tr></table></figure><p>可以看到基于差分数组建立树状数组，ask(i)的返回值为arr[i]，因此该方法适用于<strong>区间更新，单点查询</strong>，而上面的方法适用于<strong>单点更新，区间查询</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dijkstra</title>
      <link href="2020/10/09/algo/dijkstra/"/>
      <url>2020/10/09/algo/dijkstra/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>考虑一个有权图，一个源点，dj算法可以求出图中的所有点到源点的最短路径。</p><p>为了实现dj算法，我们需要维护3个数据结构，一个用于记录未确定到源点最短路径的点集upss，一个用于记录源点到该点的最短路径长度dist，一个用于记录最短路径中该点的上一个点prev。</p><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91ba0ebd7f74b87a6be410740a9136e~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy"></p><p>此处以<a href="https://leetcode-cn.com/problems/network-delay-time/">leetcode 743.网络延迟时间为例</a>，源点为2，初始数据结构如下。</p><table><thead><tr><th align="center">upss</th><th align="center">dist</th><th align="center">prev</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">inf</td><td align="center">-1</td></tr><tr><td align="center">2</td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center">3</td><td align="center">inf</td><td align="center">-1</td></tr><tr><td align="center">4</td><td align="center">inf</td><td align="center">-1</td></tr></tbody></table><p>初始当前节点为2.我们从upss中找到当前节点的一步可达节点1、3，如果经过当前节点到达1、3的距离小于现有源点到1、3的距离，就更新dist和prev，并将2从upss移除。</p><table><thead><tr><th align="center">upss</th><th align="center">dist</th><th align="center">prev</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center"><del>2</del></td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">inf</td><td align="center">-1</td></tr></tbody></table><p>找到upss中目前距离源点最近的节点1作为当前节点，从upss中找到当前节点的一步可达节点，没有找到，将1从upss移除。</p><table><thead><tr><th align="center">upss</th><th align="center">dist</th><th align="center">prev</th></tr></thead><tbody><tr><td align="center"><del>1</del></td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center"><del>2</del></td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">inf</td><td align="center">-1</td></tr></tbody></table><p>找到upss中目前距离源点最近的节点3作为当前节点，从upss中找到当前节点的一步可达节点4，如果经过当前节点到达4的距离小于现有源点到4的距离，就更新dist和prev，并将3从upss移除。</p><table><thead><tr><th align="center">upss</th><th align="center">dist</th><th align="center">prev</th></tr></thead><tbody><tr><td align="center"><del>1</del></td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center"><del>2</del></td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center"><del>3</del></td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">3</td></tr></tbody></table><p>找到upss中目前距离源点最近的节点4作为当前节点，从upss中找到当前节点的一步可达节点，没有找到，将4从upss移除。</p><table><thead><tr><th align="center">upss</th><th align="center">dist</th><th align="center">prev</th></tr></thead><tbody><tr><td align="center"><del>1</del></td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center"><del>2</del></td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center"><del>3</del></td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center"><del>4</del></td><td align="center">2</td><td align="center">3</td></tr></tbody></table><p>upss为空，循环终止。dist记录了对应点到源点的最短路径长度，prev记录了最短路径经过的点。</p><ul><li>2到1的最短路径为:2-&gt;1，长度为1。</li><li>2到3的最短路径为:2-&gt;3，长度为1。</li><li>2到4的最短路径为:2-&gt;3-&gt;4，长度为2。</li></ul><p>最后回到题目，我们只需要返回dist中的最大值的即为本题答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span>(<span class="params">self, times: List[List[<span class="built_in">int</span>]], N: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    npss, dist, prev = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)], [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*(N+<span class="number">1</span>), [-<span class="number">1</span>]*(N+<span class="number">1</span>)</span><br><span class="line">    cur, dist[K] = K, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(npss):</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> times:</span><br><span class="line">            <span class="keyword">if</span> edge[<span class="number">0</span>] == cur <span class="keyword">and</span> edge[<span class="number">1</span>] <span class="keyword">in</span> npss <span class="keyword">and</span> dist[cur]+edge[<span class="number">2</span>] &lt; dist[edge[<span class="number">1</span>]]:</span><br><span class="line">                dist[edge[<span class="number">1</span>]] = dist[cur]+edge[<span class="number">2</span>]</span><br><span class="line">                prev[edge[<span class="number">1</span>]] = cur</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> npss: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        npss.remove(cur)</span><br><span class="line">        minn = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> pnt <span class="keyword">in</span> npss:</span><br><span class="line">            <span class="keyword">if</span> dist[pnt] &lt; minn:</span><br><span class="line">                minn = dist[pnt]</span><br><span class="line">                cur = pnt</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dist[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>需要注意的是，题目并不能保证所有节点都收到信号。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>核心级线程</title>
      <link href="2020/10/08/os/%E6%A0%B8%E5%BF%83%E7%BA%A7%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/10/08/os/%E6%A0%B8%E5%BF%83%E7%BA%A7%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 7</p><a id="more"></a><p>多处理器架构每个处理器都有自己的Cache和MMU(逻辑地址到物理地址的映射)，多核心架构多个核心共享同一个Cache和MMU，系统只有支持核心级线程，才能发挥多核心的作用。</p><p>创建内核级线程的create是系统调用，<strong>内核管理TCB</strong>，内核负责线程切换。</p><p>每个内核级线程都有两个栈，一个用户栈，一个内核栈。TCB关联内核栈，内核栈关联用户栈，因此内核级线程的切换是内核栈与用户栈的切换。</p><p>用户程序通过中断进入内核，硬件会在内核栈中记录用户栈的sp和pc，这样就将内核栈和用户栈关联到一起了。中断返回(iret)将相应寄存器从内核栈弹出就退回到用户态了。</p><p><a href="https://juejin.im/post/6877432553189015566">system call</a>进入中断处理，假设此处是sys_read()，开始读磁盘，内核线程阻塞，系统进行线程调度，找到next_tcb，switch_to另一个内核线程。</p><p>switch_to和<a href="https://juejin.im/post/6880402610101157901">用户线程</a>类似，切换tcb，从而切换内核栈指针，然后ret到另一个内核程序。</p><p>总结一下就是内核级的线程也需要在用户态执行，需要内核操作时就中断，将控制权交给内核，内核在多个从用户态发起的中断任务中切换，如果某个中断完成了，就返回用户态继续执行。</p><p>内核栈底是sp和pc等用户栈信息，接着是iret的指令，每一次switch_to的ret会弹出要切换的栈的栈顶，从那里继续执行切换到的内核程序，如果弹出的是iret的指令地址，那么切过去就中断返回。</p><p>内核线程的create就是准备好用户栈和内核栈的内容，再准备好tcb，接着将tcb加入就绪队列。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户级线程</title>
      <link href="2020/10/06/os/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/10/06/os/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 6</p><a id="more"></a><p>考虑两个进程的切换除了把指令切过去，还要切换内存映射的关系，我们能不能只切换指令序列呢？线程保留了并发的优点，避免了进程切换的代价（多个执行序列、一个地址空间）。</p><p>create让多个线程同时出发，yield让多个线程交替执行。用户级线程不会进入内核，因此线程切换不是交由操作系统调度，需要用户程序主动让出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">1</span>   线程<span class="number">2</span></span><br><span class="line">------------------------------------------</span><br><span class="line">|<span class="number">100</span>: A() &#123;||<span class="number">300</span>: C() &#123;|</span><br><span class="line">|B();||D();|</span><br><span class="line">|<span class="number">104</span>:||<span class="number">304</span>:|</span><br><span class="line">|&#125;||&#125;|</span><br><span class="line">|<span class="number">200</span>: B() &#123;||<span class="number">400</span>: D() &#123;|</span><br><span class="line">|yield();||yield();|</span><br><span class="line">|<span class="number">204</span>:||<span class="number">404</span>:|</span><br><span class="line">|&#125;||&#125;|</span><br><span class="line">------------------------------------------</span><br></pre></td></tr></table></figure><p>初始从A函数开始执行，每次函数调用都需要将函数返回地址压栈。我们这里假设两个yield分别执行<code>jmp 300</code>和<code>jmp 204</code>。</p><ol><li>A()调用B()，104入栈。</li><li>B()调用yield()，204入栈。</li><li>C()调用D()，304入栈。</li><li>D()调用yield()，404入栈。</li><li>B()返回，404弹出。</li><li>D()返回，304弹出。</li><li>C()返回，204弹出。</li><li>B()返回，104弹出。</li><li>A()返回，到调用A()的地址。</li></ol><p>很明显上述执行顺序并不是我们想要的，两个线程共用一个栈会出现问题，那如果每个进程都有自己的栈呢？</p><ol><li>A()调用B()，104入栈1。</li><li>B()调用yield()，204入栈1。</li><li>C()调用D()，304入栈2。</li><li>D()调用yield()，404入栈2。</li><li>B()返回，204弹出。</li><li>B()返回，104弹出。</li><li>A()返回，到调用A()的地址。</li></ol><p>虽然第5、6步看上去还是有点问题，但起码执行顺序是我们期望的了。还有一点需要注意的是，在第2、3步，esp已经改变了。这里我们考虑从线程1切换到线程2的yield的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">yield() &#123;</span><br><span class="line">tcb1.esp = cpu.esp;</span><br><span class="line">    cpu.esp = tcb2.esp;</span><br><span class="line">    jmp <span class="number">300</span>;<span class="comment">// 不应该有这一条指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同进程类似，线程有自己的线程控制块（TCB），线程切换的核心是TCB和栈相互配合。</p><p><code>jmp 300</code>绕开了yield的ret，也就不会从栈中弹出返回地址，因此调用yield压入栈中的返回地址会从其他函数返回，不妨不让yield执行jmp，而是通过返回地址跳转。</p><ol><li>A()调用B()，104入栈1。</li><li>B()调用yield()，204入栈1。</li><li>C()调用D()，304入栈2。</li><li>D()调用yield()，404入栈2。</li><li>D()返回，204弹出。</li><li>B()返回，104弹出。</li><li>A()返回，到调用A()的地址。</li></ol><p>如此一来，执行顺序符合我们的预期，我们可以得出yield函数是通过栈的切换，实现了线程间的切换。</p><p>create函数就是做出TCB和栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码</span><br><span class="line">create(func) &#123;</span><br><span class="line">    stack &#x3D; Stack();</span><br><span class="line">    tcb &#x3D; Tcb();</span><br><span class="line">    stack.push(func);</span><br><span class="line">    tcb.esp &#x3D; stack.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create、yield都是用户程序，因此线程切换包括TCB全部在用户态，假设线程需要进入内核（例如网卡IO），如果阻塞了，内核并不能感知到其他线程，就会切到另一个进程，因此其他的线程也会阻塞。如果没有其他进程了，CPU就会慢慢的等待IO完成。就好像如果浏览器的每个标签都是用户级线程，那么一个标签页卡住，其他标签页也会卡住。</p><p>有时候我们也将用户级线程称为协程。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多进程</title>
      <link href="2020/10/06/os/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>2020/10/06/os/%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 5</p><a id="more"></a><p>操作系统将所有进程记录好，按照合理的次序推进（资源分配、进程调度），就是多进程图像。</p><p>多进程图像在整个操作系统的生命周期中存在，是操作系统最核心的图像。</p><p>main.c中的main函数的最后<code>if(!fork()) &#123;init();&#125;</code>，创建了子进程，在子进程中打开了shell。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        exec(cmd);</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd2e0c273c7461cbd56415cc6c546a0~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy"></p><p><strong>多进程如何组织？</strong></p><p>操作系统感知进程与组织进程全部依赖于PCB。任一时刻，操作系统只有1个正在执行的进程，即运行态的进程，其PCB信息存在于CPU中。</p><p>操作系统维护了1个就绪队列，n个等待队列（例如磁盘等待队列、打印机等待队列等）。就绪队列的元素是处于就绪态的进程的PCB结构体，等待队列的元素是处于阻塞态的进程的PCB结构体。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17dbe5f192af416a95b9e6e97d02b0de~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy"></p><p><strong>多进程如何交替？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"></span><br><span class="line">cur_pcb.state = <span class="string">&#x27;W&#x27;</span>;<span class="comment">// 启动磁盘读写，把自己的状态置为阻塞态</span></span><br><span class="line">disk_wait_queue.append(cur_pcb);<span class="comment">// 将cur_pcb放入磁盘等待队列</span></span><br><span class="line">schedule();</span><br><span class="line"></span><br><span class="line">schedule() &#123;</span><br><span class="line">new_pcb = get_next(ready_queue);<span class="comment">// 从就绪队列拿出一个new_pcb，进程调度</span></span><br><span class="line">    switch_to(cur_pcb, new_pcb);<span class="comment">// 切换到new_pcb，保存现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch_to(cur_pcb, new_pcb) &#123;</span><br><span class="line">cur_pcb.ax = cpu.ax;</span><br><span class="line">    cur_pcb.bx = cpu.bx;</span><br><span class="line">    ...</span><br><span class="line">    cur_pcb.cs = cpu.cs;</span><br><span class="line">    </span><br><span class="line">cpu.ax = new_pcb.ax;</span><br><span class="line">    cpu.bx = new_pcb.bx;</span><br><span class="line">    ...</span><br><span class="line">    cpu.cs = new_pcb.cs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多进程如何影响？</strong></p><p>考虑下面代码带来的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 进程<span class="number">1</span>; 进程<span class="number">2</span></span><br><span class="line">mov [<span class="number">100</span>], ax <span class="number">100</span>: ...</span><br></pre></td></tr></table></figure><p>进程1会不会修改到进程2代码所在的内存空间？答案是不会，每个进程有一个自己的地址空间，100是逻辑地址会映射到一个物理地址。进程管理带动内存管理。</p><p><strong>多进程如何合作？</strong></p><p>考虑两个进程向待打印队列中添加文件，如果没有适当的同步机制，那么在进程切换时，会导致打印队列中文件的错乱。进程管理还带来了进程同步的问题。</p><p><strong>如何形成多进程图像？</strong></p><p>①读写PCB，OS中最重要的结构，贯穿始终；②操作寄存器完成切换；③书写进程调度程序；④要有进程同步与合作；⑤要有逻辑地址到物理地址的映射。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="2020/10/04/os/%E8%BF%9B%E7%A8%8B/"/>
      <url>2020/10/04/os/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 4</p><a id="more"></a><p>考虑我们该如何管理CPU？</p><p>计算机的原理是取址执行，我们只需要给PC一个值，CPU就可以开始工作了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">50</span>: mov ax, [<span class="number">100</span>]</span><br><span class="line"><span class="number">51</span>: mov bx, [<span class="number">101</span>]</span><br><span class="line"><span class="number">52</span>: add ax, bx</span><br><span class="line">...</span><br><span class="line"><span class="number">100</span>: <span class="number">0</span></span><br><span class="line"><span class="number">101</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>初始另PC等于50，CPU把地址50发给内存，内存把指令发给CPU，PC可以自动增加。该段代码执行完毕，ax为1，bx为1。</p><p>所以置PC初值是管理CPU最直观的方法。</p><p>考虑地址53开始IO操作（比如说打印），CPU是否要等待IO操作的完成？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; 程序<span class="number">1</span>   ; 程序<span class="number">2</span></span><br><span class="line"><span class="number">50</span>: mov ax, <span class="number">1</span><span class="number">200</span>: mov ax, <span class="number">10</span></span><br><span class="line"><span class="number">51</span>: mov bx, <span class="number">1</span><span class="number">201</span>: mov bx, <span class="number">10</span></span><br><span class="line"><span class="number">52</span>: add ax, bx<span class="number">202</span>: add ax, bx</span><br><span class="line"><span class="number">53</span>: IO...</span><br></pre></td></tr></table></figure><p>让CPU更高效的方式是让CPU走完52后，我们修改PC为200，此时CPU与打印机并行，程序1的IO操作完成后发起中断，CPU继续回到程序1执行。</p><p>让CPU执行程序，CPU就工作起来了；让CPU<strong>并发</strong>的执行程序，CPU就很好的工作起来了。</p><p><strong>并发：多道程序，同时出发，交替执行。</strong></p><p>我们如何控制并发？只是修改PC就可以了么？</p><p>考虑程序1执行52后寄存器的状况：ax为2，bx为1；程序2执行202后寄存器的状况：ax为20，bx为10。</p><p>假设CPU执行202后跳转回程序1，此时ax为20，bx为10。</p><p>我们需要在从程序1切出去的时候记录程序1的信息，包括ax=2，bx=1，PC=53，每一个运行中的程序都需要这么一个存放信息的结构称为<strong>进程控制块（PCB）</strong>。</p><p>运行的程序和静态的程序是不一样的。程序 + PCB -&gt; 进程。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp</title>
      <link href="2020/10/03/net/tcp/"/>
      <url>2020/10/03/net/tcp/</url>
      
        <content type="html"><![CDATA[<p>自顶向下方法第3章</p><a id="more"></a><p>在讲解TCP之前，我们需要明确几个概念。</p><p>最大报文段长度(MSS)：MSS是指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度。通常根据最初确定的由本地主机发送的最大链路层帧长度（即所谓的最大传输单元MTU）来设置。</p><p>TCP连接的组成：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。两端都有各自的发送缓存和接收缓存。在这两台主机之间的网络元素（路由器、交换机、中继器），没有为该连接分配任何缓存和变量。</p><p>全双工服务：TCP提供的是全双工服务，可以类比为双向通行的道路。</p><h2 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h2><p>TCP报文段分为首部字段和数据字段，数据字段包含一块应用数据，MSS限制了报文段数据字段的最大长度。当TCP传送大文件时，会将该文件划分为长度为MSS的若干块。</p><p>TCP首部包含字段如下。</p><ol><li>源端口号(16b)&amp;目的端口号(16b)：用于多路复用/分解来自或送到上层应用的数据。</li><li>检验和字段(16b)：用于差错校验。</li><li>序号字段(32b)&amp;确认号字段(32b)：用于实现可靠数据传输服务。</li><li>接收窗口字段(16b)：用于流量控制，指示接收方愿意接受的字节数量。</li><li>首部长度字段(4b)：用于指示以32比特的字为单位的TCP首部长度。</li><li>可选与变长的选项字段：用于发送方与接收方协商最大报文长度(MSS)时，或在高速网络环境下用于窗口调节因子时使用。</li><li>标志字段(8b)：<ul><li>ACK：用于指示确认字段中的值是有效的。</li><li>RST、SYN、FIN：用于连接的建立和拆除。</li><li>CWR、ECE：用于明确拥塞通告。</li><li>PSH：用于指示接收方应立即将数据交给上层。</li><li>URG：用于指示报文段里存在着被发送端的上层实体置为紧急的数据。</li></ul></li><li>紧急数据指针字段(16b)：当紧急数据存在，TCP必须通知接收端的上层实体。</li></ol><h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h3><p>TCP把数据看成无结构的、有序的字节流。序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。</p><p>假设主机A上一个进程想通过TCP连接向主机B上的一个进程发送一个数据流，主机A中的TCP隐式的对数据流中的每一个字节编号。假定数据流由一个包含1000字节的文件组成，其MSS为100字节。TCP将为该数据流构建10个报文段，第一个报文段的序号是0，第二个报文段的序号是100，以此类推。每一个序号被填入到相应的TCP报文段中（这里我们假设了初始序号为0，但实际上TCP连接的双方可以随机选取初始序号，这样做可以减少仍在网络中存在的两台主机之间先前已经终止的连接的报文段误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性）。</p><p>主机A填充进报文段的确认号是主机A期望从主机B接收到的下一字节的序号。</p><p>假设主机A已收到一个来自主机B的包含字节0-535的报文段，以及另一个包含字节900-1000的报文段，由于某种原因，主机A还没有收到字节536-899的报文段。在这个例子中，主机A为了重构主机B的数据流，仍在等待字节536及其后面的字节。因为A到B的下一个报文段将在确认号字段中包含536。因为TCP值确认该流中到第一个丢失字节为止的字节，所以TCP被称为提供累积确认。</p><p>考虑这个例子中第三个报文段先于第二个报文段失序到达，对于失序报文段TCP并没有明确规定处理方式，而是留给TCP的编程人员处理。处理方式：①接收方立即丢弃失序报文段；②接收方保留失序字节，并等待缺少的字节以填补该间隔。后一种方式是实践中采用的方法。</p><h2 id="RTT的估计与超时"><a href="#RTT的估计与超时" class="headerlink" title="RTT的估计与超时"></a>RTT的估计与超时</h2><p>TCP采用超时/重传机制来处理报文段的丢失问题，超时时间间隔必须大于该连接的往返时间(RTT)，否则会造成不必要的重传。</p><p>报文段的样本RTT（SampleRTT）就是从某报文段被发出到对该报文段的确认被收到之间的时间量，由于路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT的值会随之波动。TCP维持了一个SampleRTT均值（EstimatedRTT），一旦获得一个新的SampleRTT时，TCP就会更新EstimatedRTT。</p><p>RTT偏差（DevRTT）用于估算SampleRTT一般会偏离EstimatedRTT的程度。</p><p>超时时间间隔应该大于EstimatedRTT，否则会造成不必要的重传，但也不能比EstimatedRTT大太多，否则会导致数据传输时延大。因此当SampleRTT的波动较大时，加上的余量应该大一些，反之则小一些，这时就需要DevRTT了。</p><p>推荐的初始TimeoutInterval值为1秒，当出现超时后，TimeoutInterval值将加倍，然而只要收到报文段并更新EstimatedRTT，就重新计算TimeoutInterval。</p><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>在之前讲述可靠数据传输时，假定每一个已发送但未被确认的报文段都与一个定时器相关联，但定时器的管理却需要相当大的开销。因此推荐的定时器管理过程仅使用单一的重传定时器，即使有多个已发送但还未被确认的报文段。TCP协议遵循了这种单一定时器的推荐。</p><p>TCP发送方有3个与发送和重传有关的主要事件：①从上层应用接收数据；②定时器超时；③收到ACK。</p><p>一旦①发生，TCP从应用程序接收数据，并封装在报文段中，并把该报文段交给网络层。如果定时器还没有为某些其他报文段而运行，则当报文段被传给网络层时，TCP就启动该定时器。（将定时器关联到最早的未被确认的报文段）。该定时器的过期时间间隔是TimeoutInterval。</p><p>一旦②发生，TCP通过重传引起超时的报文段来响应超时事件，然后TCP重启定时器。</p><p>一旦③发生，TCP将ACK的值y与它的SendBase（最早未被确认字节序号，即窗口开始）比较。y确认了字节编号在y之前的所有字节都以收到，如果y&gt;SendBase，则更新SendBase。如果当前有未被确认的报文段，TCP还要重启定时器。</p><h3 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h3><p>TCP重传具有最小序号的还未被确认的报文段，每次重传都会将下一次的超时间隔设为先前值的两倍，直到再次<strong>收到ACK或收到上层应用的数据</strong>时会重新计算超时间隔。因此超时间隔在每次重传后会呈指数型增长。</p><p>这种机制提供了一个形式受限的拥塞控制，定时器过期很可能是由网络拥塞引起的，在拥塞的时候如果持续重传分组，会使拥塞更加严重。相反TCP提供了更加文雅的方式，每个发送方的重传都是经过越来越长的时间间隔后进行的。</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>超时触发重传的问题之一超时周期可能相对较长。幸运的是发送方通常可在超时发生之前通过冗余ACK来较好的检测到丢包的情况。冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经受到对该报文段的确认。</p><p>TCP不使用否定确认，只是对已经接受到的最后一个按序字节进行重复确认，即产生一个冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK，说明跟在这个已经被确认过3次的报文段之后的报文段已经丢失。一但收到3个冗余ACK，TCP就执行快速重传，即在该报文段的<strong>定时器过期之前重传</strong>丢失的报文段。</p><h3 id="GNB-or-SR"><a href="#GNB-or-SR" class="headerlink" title="GNB or SR ?"></a>GNB or SR ?</h3><p>TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的。因此TCP发送方仅需维持已发送过但未被确认的字节的最小序号和下一个要发送的字节的序号，不同于GBN的是TCP会将正确接收但失序的报文段缓存起来。</p><p>对TCP提出的一种修改意见是所谓的<strong>选择确认</strong>，允许TCP接收方有选择的确认失序报文段，而不会累积的确认最后一个正确接收的有序报文段，当该机制与选择重传机制结合起来使用时，TCP就看起来很像SR协议。因此TCP的差错机制可以看做GBN和SR的混合体。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP连接的两端都为该连接设置了接收缓存，当TCP收到正确按序的字节后，就将数据放入接收缓存。相关联的应用程序从缓存中读取数据。事实上应用程序也许正忙于其他任务，如果应用程序读数据相对缓慢，而发送方发送的数据太多太快，就会很容易的导致接收缓存溢出。</p><p>TCP为了解决该问题提供了流量控制服务。流量控制是一个速度匹配服务，即发送方的发送速率与接收方的接收速率相匹配。为了易于理解我们假设TCP接收方会丢弃失序报文段。</p><p>通过让发送方维护一个<strong>接收窗口</strong>的变量来提供流量控制。接收窗口用于告知发送方该接收方还有多少可以的缓存空间。</p><p>假设主机A通过一条TCP连接向主机B发送一个大文件，主机B为该连接分配了一个接收缓存，用RcvBuffer表示其大小。主机B上的应用进程不时从该缓存读取数据。</p><p>定义有如下变量。</p><ul><li>LastByteRead：主机B上的应用程序从缓存读出的数据流的最后一个字节的编号。</li><li>LastByteRcvd：从网络到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。</li><li>rwnd：接收窗口。</li></ul><p>rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</p><p>主机B通过把当前的rwnd放入它发给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。</p><p>LastByteRcvd - LastByteRead就是主机A发送到连接中但是未被确认的数据量。通过将该值控制在rwnd内，就可以保证主机A不会使主机B的接收缓存溢出，因此主机A在该连接的整个生命周期必须保证：LastByteRcvd - LastByteRead &lt;= rwnd。</p><p>一个小问题是，当主机B发送了rwnd=0后，没有再发送新的报文段，接着主机B的接收缓存有空间，但是主机A不知道，即主机A被阻塞而不能再发送新数据。因此TCP规定：当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认。最后缓存开始清空，并且确认报文里将包含一个非0的rwnd值。</p><p>UDP没有提供流量控制，因此接收方缓存可能会溢出，并且丢失报文段。</p><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一步：客户端的TCP首先向服务端的TCP发送一个特殊的TCP报文段。该报文段不包含应用层数据。但是在报文段的首部SYN被置1.因此该特殊的报文段被称为<strong>SYN报文段</strong>。另外客户端会随机选择一个初始序号（client_isn），并将此编号放置于该起始的SYN报文段的序号中，该报文段会被分装在一个IP数据报中，并发送给服务器。</p><p>第二步：一旦SYN报文段的IP数据到达服务器，服务器会为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是首部包含3个重要信息：①SYN置1；②确认号置为client_isn+1；③服务器选择初始序号（server_isn），并放置到序号字段。该允许连接的报文段被称为<strong>SYNACK报文段</strong>。</p><p>第三步：收到SYNACK报文段后，客户也要给该连接分配缓存和变量，客户主机向服务器发送另外一个报文段。这最后一个报文段对服务器的允许连接报文段进行了确认（确认号server_isn+1）。因为连接已经建立了，所以SYN置0。该报文段可以携带应用层数据。</p><p>一旦完成这3个步骤，客户端和服务端就可以相互发送包括数据的报文段了。以后每一个报文段中，SYN都置0。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当连接结束后，主机中的缓存和变量将被释放。</p><p>第一步：客户进程发出一个关闭连接命令，引起客户TCP向服务器进程发送一个特殊的TCP报文段，首部FIN置1。</p><p>第二步：服务器接收FIN报文段后，会送一个确认报文段。</p><p>第三步：服务器发送它自己的FIN报文段。</p><p>第四步：客户对该服务器的FIN报文段进行确认。</p><p>在一个TCP连接的生命周期内，运行在每台主机的TCP协议在各种<strong>TCP状态</strong>之间变迁。</p><h3 id="TCP状态"><a href="#TCP状态" class="headerlink" title="TCP状态"></a>TCP状态</h3><p><strong>客户端：</strong></p><p>客户TCP开始时处于CLOSED状态。发送SYN报文段后，客户TCP进入了SYN_SENT状态。收到SYNACK报文段后，客户TCP进入了ESTABLISHED状态，该状态下TCP客户就能发送和接收包含应用层数据的TCP报文段了。</p><p>客户TCP发送FIN报文段，进入FIN_WAIT_1状态。收到确认报文段后进入FIN_WAIT_2状态。收到FIN报文段并确认后进入TIME_WAIT状态。假定ACK丢失，TIME_WAIT状态使客户TCP重传最后的确认报文。TIME_WAIT时间与具体实现有关，典型的值为30秒、1分钟或2分钟。经过等待后进入CLOSED状态，连接正式关闭，客户端所有资源（包括端口号）将被释放。</p><p><strong>服务端：</strong></p><p>服务TCP开始时处于CLOSED状态。创建监听套接字后处于LISTEN状态。接收SYN发送SYNACK后处于SYN_RCVD状态。接收ACK后处于ESTABLISHED状态。</p><p>服务TCP接收FIN发送ACK后处于CLOSE_WAIT状态。发送FIN后处于LAST_ACK状态。接收ACK后处于CLOSED状态，连接正式关闭，服务端所有资源（包括端口号）将被释放。</p><p>客户SYN发出后可能会接收到一个RST报文段（即RST标志位置1），表示当前服务端并没有运行在目的端口上的应用程序。当然客户也可能什么都收不到，这很可能表示SYN报文段被防火墙阻挡，无法到达目标主机。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞控制通过遏制发送方来缓解IP网络拥塞。网络拥塞会导致路由器缓存溢出，接着导致分组重传。在最宽泛的级别上，我们可以根据网络层是否为运输层拥塞控制提供了显示帮助来区分拥塞控制方法。</p><ol><li>端到端拥塞控制：网络层没有为运输层拥塞控制提供显示支持，即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断。<strong>TCP采用端到端的方法解决拥塞控制</strong>，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（超时或3次冗余ACK）被认为是网络拥塞的迹象，TCP会相应的减小其窗口长度。</li><li>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显示反馈信息。这种反馈可以简单的用一个比特来指示链路中的拥塞情况。</li></ol><p>TCP的一个关键部分是可靠传输，另一个关键部分就是拥塞控制。</p><p>TCP让每一个发送方根据感知到的网络拥塞程度在限制其能向连接发送流量的速率，如果一个TCP发送方感知从它到目的地之间的路劲上没有什么拥塞，则TCP发送方增加其发送速率。反之则降低其发送速率。</p><p>三个问题：①如何限制发送速率；②如何感知网络拥塞；③如何确定发送速率。</p><p>对于①，TCP连接的每一端都是由一个接收缓存，一个发送缓存和几个变量（LastByteRead、rwnd等）组成。运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即<strong>拥塞窗口</strong>，表示为cwnd，它对一个发送方能向网络中发送流量的速率进行了限制。</p><p>LastByteSent - LastByteAcked(发送方未被确认的数据量) &lt;= min(cwnd, rwnd)</p><p>对于②，定义TCP发送方丢包事件为超时或收到3个冗余ACK，当发生丢包事件时，发送方就认为路径上出现了拥塞。</p><p>对于③，一个丢失的报文段意味着拥塞，因此当丢失报文段时应降低TCP发送方的速率；一个确认报文段指示该网络正向接收方交付发送方的报文段，因此当对先前未确认报文段的确认到达时，能够增加发送方的速率。</p><h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p>该算法包含三个主要部分：①慢启动；②拥塞避免；③快速恢复。慢启动和拥塞避免是TCP的强制部分，两者的差异在于对于收到的ACK做出反应时增加cwnd的长度，慢启动比拥塞避免能更快的增加cwnd的长度。快速恢复是推荐部分，对TCP发送方并非是必须的。</p><p><strong>慢启动</strong></p><p>当一条TCP连接开始时，cwnd的值通常初始置为一个MSS的较小值。在慢启动中，cwnd的值以1个MSS开始，并且每当传输的报文段首次被确认cwnd就翻一倍（增加一个MSS）。因此TCP发送速率起始慢，但在慢启动阶段以指数增长。从而以更快的速度找到合适的发送速率。</p><p>那么何时结束指数增长？首先，如果存在一个由超时指示的丢包事件，TCP发送方另第二个状态变量ssthresh=cwnd/2,再将cwnd置1并重新开始慢启动。慢启动结束的第二种方式是直接与ssthresh相关联，因为当检测到拥塞时ssthresh设为cwnd的一半，当到达或超过ssthresh时，就结束慢启动转到拥塞避免模式。进入拥塞避免模式后，TCP会更加谨慎的增加cwnd。最后一种方式是检测到三个冗余ACK，TCP执行快速重传并进入快速恢复状态。</p><p><strong>拥塞避免</strong></p><p>一旦进入拥塞避免，cwnd的值大约是上次遇到拥塞时值的一半，即距离拥塞并不遥远，在该状态下，每个RTT只将cwnd的值增加一个MSS（一个RTT可能有多个ACK，所以和慢启动不一样）。一种通用的方法是对于TCP发送方无论何时到达一个新的确认，都将cwnd增加一个MSS字节。</p><p>何时结束线性增长？当出现超时时，cwnd的值被设置为一个MSS，ssthresh的值被更新为cwnd的值的一半。当收到3个冗余ACK，cwnd值减半，ssthresh记录为cwnd的一半。接下来进入快速恢复状态。</p><p><strong>快速恢复</strong></p><p>对于引起TCP进入快速恢复状态的报文段，对每个冗余的ACK，cwnd增加一个MSS，最终，当对丢失报文段的一个ACK到达时，降低cwnd进入拥塞避免状态。如果出现超时事件，快速恢复在执行如同在慢启动和拥塞避免中相同的动作后迁移到慢启动状态。当接收3个冗余ACK，cwnd被置为一个MSS，ssthresh置为cwnd的一半。</p><p>综合来说这三个部分就是让cwnd尽量处于一个不拥塞状态的最大的值。TCP拥塞控制常常被称为<strong>加性增、乘性减（AIMD）</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层</title>
      <link href="2020/10/03/net/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>2020/10/03/net/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>自顶向下方法第3章</p><a id="more"></a><h2 id="如何理解运输层？"><a href="#如何理解运输层？" class="headerlink" title="如何理解运输层？"></a>如何理解运输层？</h2><p>现在考虑有两个家庭，H1和H2，两个家庭有12个孩子喜欢互相写信，H1家庭的孩子C1与H2家庭的孩子C2负责收集信件送到邮局，再从邮局拿信件分发给其他人。</p><p>在这里例子中，应用层报文 = 信封上的字符、进程 = 孩子们、主机 = 家庭、运输层协议 = C1 and C2、网络层协议 = 邮政服务。</p><p>运输层协议为运行在不同端系统上的应用进程之间提供了逻辑通信，并且运输层协议只工作在端系统中，在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（网络层），反之亦然。</p><p>运输层协议有UDP（用户数据报协议）和TCP（传输控制协议），负责将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。</p><p><strong>进程到进程的数据交付</strong>和<strong>差错检查</strong>是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。TCP在此基础上还提供了<strong>可靠数据传输</strong>和<strong>拥塞控制</strong>。</p><h2 id="多路复用-amp-多路分解"><a href="#多路复用-amp-多路分解" class="headerlink" title="多路复用&amp;多路分解"></a>多路复用&amp;多路分解</h2><p>多路复用与多路分解就是将由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。</p><p>当C1从邮递员处收到一批信件，并通过查看收信人名字而将信件亲手交给它的兄弟姐妹时，执行的就是多路分解操作；当C2从兄弟姐妹那里收集信件并交给邮递员时，执行的就是多路复用操作。</p><p>一个进程有一个或多个套接字，在接收主机中的运输层实际上并没有将数据直接交付给进程，而是将数据交给了一个中间的套接字。任意时刻，接受主机上可能有不止一个套接字，所以每个套接字都有一个唯一的标识符，标识符的格式取决于TCP还是UDP。</p><p>将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>，在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong>。</p><p>UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。TCP套接字是由一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识的。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP首部有4个字段（源端口号、目的端口号、长度、检验和），每个字段占2个字节，长度指的是整个UDP报文段（首部+数据）的字节数，接收方使用检验和来检查在该报文段中是否出现了差错。</p><p>虽然UDP提供差错检测，但它对差错恢复无能为力。UDP的某种实现只是丢弃受损的报文段，其他实现是将受损的报文段交给应用程序并给出警告。</p><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p><strong>自动重传请求</strong>（ARQ）协议，通过控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。</p><p>ARQ还需要差错检测（比特差错、检验和）、接收方反馈（肯定确认ACK、否定确认NAK）、重传三种协议来处理存在比特差错的情况。</p><p><strong>停等协议</strong>：当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据，仅当接收到ACK并离开该状态时才能发生这样的事件。因此发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。</p><p>一个比较严重的问题是，ACK或NAK分组受损的可能，解决该问题的一个简单方法，是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号放在该字段，于是接收方只需检查序号即可确定收到的分组是否一次重传。</p><p>对于停等协议，发送方无法理解接收方的ACK/NAK时，就重传分组，接收方通过序号判断该分组是一个重传分组还是一个新分组。</p><p>但是除了解决比特受损的问题外，我们还要考虑底层信道的丢包问题，即怎样检测丢包以及发生丢包后该做些什么？</p><p>我们让发送方负责检测和恢复丢包工作，假设发送的分组丢失或者接收方ACK丢失，发送方收不到应当到来的接收方的响应，我们可以让发送方等待一个往返+分组处理的时延，但是这个时延在最坏情况下意味着发送方要等待很长时间。</p><p>因此需要设置一个超时时间，如果在这个时间内没有收到ACK，则重传该分组，即使接收方已经收到了这个分组。这也就意味着在发送方到接收方的信道中引入了<strong>冗余数据分组</strong>。对于冗余数据分组，我们依旧可以通过上文的序号机制来处理。</p><p>对于发送方来说，无论是一个数据分组丢失，还是一个ACK丢失，或者只是分组或ACK超时，都通过重传来解决，为了实现基于时间的重传机制，需要一个倒计数定时器：①每次发送一个分组（包括新分组和重传分组）时，启动一个定时器；②响应定时器中断；③终止定时器。</p><p>通过检验和、序号、定时器、肯定和否定确认分组这些技术，我们得到了一个可靠数据传输协议，我们称之为rdt3.0或<strong>比特交替协议</strong>。</p><h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>rdt3.0性能问题的核心在于其是一个停等协议，还有发送方和接收方的底层协议处理时间，以及可能出现在发送方与接收方之间的任何中间路由器的处理与排队时延。</p><p>解决办法是不以停等的方式运行，允许发送方发送多个分组而无须等待确认，因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，因此这种技术被称之为<strong>流水线</strong>。</p><ul><li>必须增加序号范围，因为每个输送中的分组（不算重传）必须有一个唯一的序号，而且也许有多个在输送中的未确认报文。</li><li>协议的发送方和接收方两端也许不得不缓存多个分组，发送方最低限度应当能缓冲那些已发送但没有确认的分组，接收方或许也需要缓存那些已正确接受的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏及延时过大的分组，解决流水线的差错恢复有两种基本方法：<strong>回退N步</strong>和<strong>选择重传</strong>。</li></ul><h3 id="回退N步-GBN-协议"><a href="#回退N步-GBN-协议" class="headerlink" title="回退N步(GBN)协议"></a>回退N步(GBN)协议</h3><p>GBN协议允许发送方发送多个分组，而不需等待确认，但也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p><p>假设GBN协议的序号范围为0-K，那么该序号范围可以被划分为4段（已发送并被确认的分组、已发送但未被确认的分组、即将被发送的分组、不可使用的序号）。</p><p>其中已发送但未被确认的分组与即将被发送的分组的长度为窗口长度N，随着协议的运行，该窗口在序号空间向前滑动，因此GBN协议也常被称为<strong>滑动窗口协议</strong>。</p><p>一个分组的序号承载在分组首部的一个固定长度的字段中，如果该字段长k位，则序号范围[0, 2^k-1]，所有涉及序号的运算必须使用模2^k运算，因此序号空间可被看作是一个长度为2^k的环。</p><p>GBN的发送方必须响应三种类型的事件。</p><ul><li>上层的调用。只有窗口未满才产生一个分组并发送，以及更新相应的变量。</li><li>收到一个ACK。对序号为n的分组采用<strong>累积确认</strong>的方式，表明接收方已正确接收到序号为n及n之前的所有分组。</li><li>超时事件。“回退n步”来源于出现丢失和时延过长分组时发送方的行为，如果超时，发送方重传所有已发送但还未被确认过的分组。</li></ul><p>GBN的接收方如果一个序号为n的分组被正确接收到，并且按序，则接收方为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为上一个按序接收的分组重新发送ACK。看上去丢弃一个正确接收但失序的分组有些愚蠢，但是接收方不需要缓存一个失序分组，因为这个被丢弃的分组会因为重传规则再次被发送方发送。</p><h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>GBN协议允许发送多个分组，避免了停等协议中的信道利用率问题，但是在GBN协议中，单个分组的差错就能够引起大量分组的重传，许多分组根本没必要重传，随着差错率的增加，流水线可能会被这些不必要重传的分组充斥。</p><p>选择重传（SR）协议通过让发送方仅重传怀疑在接收方出错的分组，从而避免不必要的重传。SR接收方将确认一个正确接收的分组而不管其是否有序，失序的分组将被缓存直到之前所有丢失分组（序号更小的分组）都被收到为止，此时才可以将一批分组按序交付给上层。</p><p><strong>SR发送方动作：</strong></p><ol><li>从上层接收到数据后，SR发送发检查下一个可用于该分组的序号。如果序号位于窗口内，则打包数据发送。否则就像GBN一样缓存数据或者返回给上层以便以后传输。</li><li>定时器再次被用来防止丢失分组，但现在对每个分组都要有其自己的逻辑定时器，因为超时发生后只发送单个分组。</li><li>如果收到ACK，且分组序号在窗口内，则标记该分组为已接收。如果序号位于窗口开始，那么窗口右移到具有最小序号的未确认分组处，如果窗口移动了且有序号落在窗口的未发送分组，则发送这些分组。</li></ol><p><strong>SR接收方动作：</strong></p><ol><li>序号在窗口内的分组被正确接收，此时收到的分组落在接收方的窗口内，一个选择ACK回给发送方。如果该分组之前没收到过，则缓存该分组。如果该分组序号位于窗口开始，则该分组以及以前缓存的序号连续的分组交付给上层，接着窗口向右移动。</li><li>上一个窗口内的分组被正确收到，需要产生一个ACK，即使该分组之前确认过。</li><li>其他情况忽略该分组。</li></ol><p>对于序号空间的一个现实问题是，序号的范围是有限的，这对接收方的问题就在于无法确定一个分组是新的分组还是重传的分组，因此对于SR协议窗口长度必须小于或等于最大序号的一半，这样才不会在连续的两个窗口内出现拥有同一个序号的分组。</p><h3 id="可靠机制总结"><a href="#可靠机制总结" class="headerlink" title="可靠机制总结"></a>可靠机制总结</h3><ul><li>检验和：用于检测在一个传输分组中的比特错误。</li><li>定时器：用于超时重传，数据分组超时，或者ACK分组超时（接收方会有冗余副本）。</li><li>序号：为发送的分组按序编号，接收分组序号间的空隙使得接收方可以检测出丢失的分组，具有相同序号的分组可以使接收方检测出一个分组的冗余副本。</li><li>确认：接收方用于告诉发送方一个分组或一组分组已被正确的接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以逐个或累积，取决于协议的类型。</li><li>否定确认：接收方用于告诉发送方一个分组或一组分组未被正确的接收。否定确认报文通常携带着未被正确接收的分组的序号。</li><li>窗口、流水线：发送方也许被限制仅发送那些序号落在一个指定范围内的分组。窗口长度可以根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来设置。</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是因特网运输层面向连接的可靠地运输协议，为了提供可靠数据传输，依赖于上文讲述的可靠数据传输的原理，其中包括差错检测、重传、累积确认、定时器以及用于序号和确认号的首部字段。</p><p>TCP复杂且重要，为了避免文章过长，会另起一篇新文章具体讲述TCP。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>system call</title>
      <link href="2020/09/28/os/system-call/"/>
      <url>2020/09/28/os/system-call/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 3</p><a id="more"></a><p>硬件提供了进入内核态的方式，对于x86，使用中断指令int，将CPL置0，这也是用户程序发起的调用内核代码的唯一方式。</p><p>系统调用的核心：①用户程序中包含一段带有int指令的代码；②操作系统写中断处理，获取想要调用的程序的编号；③操作系统根据编号执行相应代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 4<span class="comment">// 系统调用号，函数表索引</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;=a&quot;(__res)    输出，&quot;=a&quot;表示eax，eax值会交给__res</span></span><br><span class="line"><span class="comment">// &quot;&quot;(__NR_##name) 输入，&quot;&quot;空表示同样是eax，__NR_write值会交给eax</span></span><br><span class="line"><span class="comment">// 后面就是把三个参数交给ebx,ecx,edx</span></span><br><span class="line"><span class="comment">// int 0x80表示软中断，也就是系统调用</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _syscall3(type name, atype a, btype b, ctype c) \</span></span><br><span class="line"><span class="function">type <span class="title">name</span><span class="params">(atype a, btype b, ctype c)</span> </span>&#123; \</span><br><span class="line"><span class="keyword">long</span> __res; \</span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span><span class="params">(<span class="string">&quot;int 0x80&quot;</span>:<span class="string">&quot;=a&quot;</span>(__res):<span class="string">&quot;&quot;</span>(__NR_##name),“b”((<span class="keyword">long</span>)(a)),<span class="string">&quot;c&quot;</span>((<span class="keyword">long</span>)(b)),<span class="string">&quot;d&quot;</span>((<span class="keyword">long</span>)(c)); \</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(__res &gt;= <span class="number">0</span>) <span class="keyword">return</span> (type)__res; \ </span></span></span><br><span class="line"><span class="function"><span class="params">    errno = -__res; \</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="number">-1</span>; \</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">_syscall3(<span class="keyword">int</span>, write, <span class="keyword">int</span>, fd, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">off_t</span>, count)</span></span></span><br></pre></td></tr></table></figure><p>上面代码的意思就是把代表write函数的系统调用号给到eax，然后执行int 0x80指令。</p><p>int 0x80中断是如何处理的？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">set_system_gate(<span class="number">0x80</span>, &amp;system_call);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> set_system_gate(n, addr) _set_gate(&amp;idt[n], 15, 3, addr);</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> set_gate(gate_addr, type, dpl, addr) __asm__(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这一行先置DPL为3，这样CPL=3可以进来，然后内部置CPL为0，进入内核态</span></span><br></pre></td></tr></table></figure><p>set_system_gate设置了0x80的中断处理门，使用system_call这个函数来处理0x80中断，操作系统在IDT中找到该函数入口并执行，执行结果记录在eax并交给__res，继续回到用户程序执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system_call.s</span></span><br><span class="line">...</span><br><span class="line">call _sys_call_table(,%eax,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys.h</span></span><br><span class="line">fn_ptr sys_call_table[] = &#123;</span><br><span class="line">sys_setup, sys_exit, sys_fork, sys_read, sys_write...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sched.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(fn_ptr*)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>system_call中根据系统调用号，决定具体调用哪个函数来处理，至于sys_write是如何实现的，会在学习IO驱动之后了解到。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="2020/09/26/net/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>2020/09/26/net/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>自顶向下方法第2章</p><a id="more"></a><h2 id="HTTP-TCP"><a href="#HTTP-TCP" class="headerlink" title="HTTP(TCP)"></a>HTTP(TCP)</h2><p>http是无状态协议，即服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。</p><p>http是面向连接的，分为非持续连接和持续连接，前者每一个对象的请求用一个单独的连接，后者所有对象的请求共用同一个连接。HTTP1.1版本后支持持续连接，默认连接方式也是持续连接。</p><p>对于持续连接，有一个可配置的超时间隔，若超过该时间未使用连接，则服务器关闭连接。</p><p>web缓存器：也称代理服务器，比如中国访问美国的站点网络时延可能较大，那么中国的ISP就可以设置一个代理服务器，减少网络时延。</p><p>条件get：用于避免代理服务器中的对象过期，代理服务器在缓存对象时同时缓存last-modified，当有客户再次请求该对象时，若时间与last-modified间隔超过了一个设定的值，代理服务器会发送带有if-modified-since: last-modified首部行的请求，若该对象未有更改，服务器返回代理服务器304 Not Modified。</p><p>内容分发网络（CDN）：CDN公司在因特网上设置了许多地理上分散的缓存器，使得大量流量实现了本地化。</p><h2 id="SMTP-TCP"><a href="#SMTP-TCP" class="headerlink" title="SMTP(TCP)"></a>SMTP(TCP)</h2><p>电子邮件系统组成部分：用户代理、邮件服务器、简单邮件传输协议（SMTP）。</p><p>每个用户代理对应一个邮件服务器，邮件服务器中有报文队列和若干个邮箱，邮件的发送从用户代理A到邮件服务器A的报文队列，到邮件服务器B的用户代理B的邮箱。</p><p>SMTP一般不使用中间服务器，哪怕邮件服务器A在中国，邮件服务器B在美国。如果邮件服务器B没有开机，那么邮件会保持在邮件服务器A中，并在以后再次尝试发送，通常间隔30分钟，如果几天后仍不成功，邮件服务器A会删除该报文，以电子邮件的方式通知用户代理A。</p><p>相比于HTTP是一个拉协议，SMTP是一个推协议。SMTP要求每个报文采用7比特ASCII码格式，如果某报文包含非7比特ASCII字符或二进制数据，则该报文必须按照7比特ASCII码进行编码，HTTP没有这种限制。HTTP把每个对象封装到自己的HTTP响应报文中，SMTP把所有报文对象放在一个报文之中。</p><p>不能够让用户代理A直接将邮件推到邮件服务器B，通过邮件服务器A中继，可以重复的尝试向不可达的邮件服务器B发送报文，直到邮件服务器B运行为止。</p><p>用户代理A到用户服务器A使用SMTP，用户服务器A到用户服务器B使用SMTP，但用户代理B从用户服务器B获取邮件无法使用SMTP，因为SMTP是推协议。目前有一些流行的邮件访问协议用来解决该问题，包括第三版的邮局协议（POP3）、因特网邮件访问协议（IMAP）、HTTP。</p><p>基于web的电子邮件：用户代理和邮件服务器之间使用HTTP，邮件服务器之间使用SMTP。</p><h2 id="DNS-UDP"><a href="#DNS-UDP" class="headerlink" title="DNS(UDP)"></a>DNS(UDP)</h2><p>域名系统（Domain Name System, DNS）:①一个由分层的DNS服务器实现的分布式数据库；②一个使得主机能够查询分布式数据库的应用层协议。</p><p>DNS服务器通常是运行BIND软件的UNIX机器，DNS协议运行在UDP上，使用53端口。</p><p>DNS服务器除了进行主机名到IP的转换，还提供其他的服务：①主机别名；②邮件服务器别名；③负载分配。</p><p>DNS工作流程：主机上的某个应用程序调用DNS客户端，并指明需要被转换的主机名，DNS客户端接收到后，向网络中发送一个DNS查询报文，经过若干毫秒时延后，DNS客户端接收到DNS回答报文，并将映射结果传递到调用DNS客户端的应用程序。</p><p>DNS采用分布式层次数据库，没有一台DNS服务器拥有因特网上所有主机的映射，相反这些映射分布在所有DNS服务器上。DNS服务器类型有三种：根DNS服务器、顶级域(TLD)DNS服务器、权威DNS服务器。</p><p>假设一个DNS客户要决定 <a href="http://www.amazon.com/">www.amazon.com</a> 的IP地址，首先与根服务器之一联系，返回顶级域名com的TLD服务器的地址，于是该客户与这些TLD服务器之一联系，返回amazon.com权威服务器的地址，最后该客户与amazon.com权威服务器之一联系，返回 <a href="http://www.amazon.com/">www.amazon.com</a> 的IP地址。</p><p>每个ISP都有一个本地DNS服务器，当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。本地DNS服务器除了转发，还可以用作DNS缓存。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>head</title>
      <link href="2020/09/26/os/head/"/>
      <url>2020/09/26/os/head/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 3</p><a id="more"></a><p>setup开启了实模式，移动system到内存0地址，并跳转到0地址，此时位于system的head模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 之前的setup为了jmpi临时设置了gdt，这里重新设置</span><br><span class="line">call setup_idtcall setup_gdt</span><br><span class="line"></span><br><span class="line">; 设置页表，页表设置成功后，跳转到main.c</span><br><span class="line">jmp after_page_tables</span><br><span class="line">after_page_table:</span><br><span class="line">; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>是main的三个参数，L6是main的返回地址</span><br><span class="line">push $<span class="number">0</span>push $<span class="number">0</span>push $<span class="number">0</span> push $L6push $_main</span><br><span class="line">    jmp setup_paging</span><br><span class="line">L6: jmp L6; main返回，系统就会死机，所以main不应该返回</span><br><span class="line">setup_paging:</span><br><span class="line">...; 设置页表</span><br><span class="line">    ret; 返回到main</span><br></pre></td></tr></table></figure><p>head准备了有关数据结构，并跳转到了main.c执行。main的工作就是做内存、中断、设备、时钟、CPU等内容的初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">mem_init();</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init();</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    sti();</span><br><span class="line">  move_to_user_mode();</span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;init();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处举例说明mem_init对内存的初始化操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/mm/memory.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">long</span> start_mem, <span class="keyword">long</span> end_mem)</span> </span>&#123;</span><br><span class="line"><span class="comment">// end_mem就是多大内存，从0x90002获取</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; PAGING_PAGES; ++i) &#123;</span><br><span class="line">    mem_map[i] = USED;</span><br><span class="line">    &#125;</span><br><span class="line">    i = MAP_NR(start_mem);</span><br><span class="line">    end_mem -= start_mem;</span><br><span class="line">    end_mem &gt;&gt;= <span class="number">12</span>;<span class="comment">// 每次把4k空间（页）置零</span></span><br><span class="line">    <span class="keyword">while</span>(end_mem-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    mem_map[i++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mem_init()自高地址向低地址标记可用，永远标记低地址是已用，因为低地址存放着操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setup</title>
      <link href="2020/09/26/os/setup/"/>
      <url>2020/09/26/os/setup/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 2</p><a id="more"></a><p><a href="https://juejin.im/post/6875607338229694477">bootsect</a>执行完后，setup和system被加载到了内存中，此时控制权转交给setup，即如下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; <span class="number">0x90000</span>:光标位置<span class="number">0x90002</span>:扩展内存数</span><br><span class="line">; <span class="number">0x9000C</span>:显卡参数<span class="number">0x901FC</span>:根设备号</span><br><span class="line">...; 获取硬件参数到<span class="number">0x90000</span></span><br><span class="line">mov ah, <span class="number">0x88</span><span class="keyword">int</span> <span class="number">0x15</span>mv [<span class="number">2</span>], ax; 获得物理内存到<span class="number">0x90002</span></span><br><span class="line"></span><br><span class="line">; 移动system到内存<span class="number">0</span>地址</span><br><span class="line">; 利用ax控制循环，利用es:di与ds:si控制目的地址与源地址</span><br><span class="line">mov cx, <span class="number">0x8000</span>rep movsw; 每次移动<span class="number">8000</span>H word</span><br><span class="line">jmp move</span><br><span class="line"></span><br><span class="line">; 设置GDT，IDT同理</span><br><span class="line">lgdt gdt_48</span><br><span class="line">gdt_48: .word <span class="number">0x800</span> .word <span class="number">512</span>+gdt, <span class="number">0x9</span></span><br><span class="line">gdt:.word <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">.word <span class="number">0x07FF</span>, <span class="number">0x0000</span>, <span class="number">0x9A00</span>, <span class="number">0x00C0</span></span><br><span class="line">.word <span class="number">0x07FF</span>, <span class="number">0x0000</span>, <span class="number">0x9200</span>, <span class="number">0x00C0</span></span><br><span class="line"></span><br><span class="line">mov ax, <span class="number">0x0001</span>mov cr0, ax; 使能保护模式</span><br><span class="line">jmpi <span class="number">0</span>, <span class="number">8</span>; 跳转到<span class="number">0</span>地址，此处非CS&lt;&lt;<span class="number">4</span>+IP</span><br></pre></td></tr></table></figure><p>setup最终跳转到了内存0地址，此处是system的head模块。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootloader</title>
      <link href="2020/09/23/os/bootloader/"/>
      <url>2020/09/23/os/bootloader/</url>
      
        <content type="html"><![CDATA[<p>HIT OS 1</p><a id="more"></a><p>x86开机处于实模式, CS=0xFFFF, IP=0x0000, 实模式CS&lt;&lt;4+IP, 寻址0xFFFF0(ROM BIOS), 检查RAM, 键盘, 显示器, 磁盘, 主板, 磁盘0磁道0扇区读入0x7c00, 512bytes, 这个是操作系统的第一段代码, 设置CS=0x07c0, IP=0x0000, 接着进入下面的代码，也就是bootloader。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">START(0x7c00):</span><br><span class="line">mov ax, 0x07c0        mov ds, ax; ds &#x3D; 0x07c0</span><br><span class="line">    mov ax, 0x9000        mov es, ax; es &#x3D; 0x9000</span><br><span class="line">    </span><br><span class="line">    ; src_address  &#x3D; ds:si &#x3D; 0x07c00</span><br><span class="line">    ; dest_address &#x3D; es:di &#x3D; 0x90000</span><br><span class="line">    sub si, si            sub di, di; si &#x3D; di &#x3D; 0</span><br><span class="line">    </span><br><span class="line">; 将主引导扇区从0x07c00拷贝到0x90000</span><br><span class="line">    ; 256 * word &#x3D; 512 byte</span><br><span class="line">    mov cx, 0x0100  rep movw; 0100H &#x3D; 256D</span><br><span class="line">    </span><br><span class="line">    ; CS:IP &#x3D; 0x9000:BOOTLOADER</span><br><span class="line">    jmpi BOOTLOADER, 0x9000</span><br><span class="line"></span><br><span class="line">BOOTLOADER:</span><br><span class="line">; cl &#x3D; 2 从第二个扇区开始读，第一个扇区是bootloader</span><br><span class="line">    ; al &#x3D; 4 读取扇区的个数，bootmain占四个扇区</span><br><span class="line">    ; bx &#x3D; 512D 将bootmain读到0x90200，bootloader占512字节</span><br><span class="line">    </span><br><span class="line">    ... ; 省略了一些操作，如设置寄存器等</span><br><span class="line">mov dx, 0x0000; dh磁头号 dl驱动器号</span><br><span class="line">    mov cx, 0x0002; ch柱面号 cl开始扇区</span><br><span class="line">    mov bx, 0x0200; es:bx待写入内存地址</span><br><span class="line">    mov ax, 0x0204; ah &#x3D; 02读驱动器扇区 al扇区数量</span><br><span class="line">    int 0x13; BIOS读磁盘中断</span><br><span class="line">    </span><br><span class="line">    ; 在屏幕上显示字符串</span><br><span class="line">    ...; 省略了显示字符中断对寄存器的设置</span><br><span class="line">mov bp, msg</span><br><span class="line">    int 0x10; BIOS显示字符中断</span><br><span class="line">    </span><br><span class="line">    ; 继续使用0x13中断读入system，启动盘的第6个扇区</span><br><span class="line">    ...</span><br><span class="line">    call read_system</span><br><span class="line">    jmpi 0x0200, 0x9000; bootmain</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">.byte 13, 10</span><br><span class="line">    .ascii &quot;loading system...&quot;</span><br><span class="line">.byte 13, 10    </span><br></pre></td></tr></table></figure><p>该段代码执行完毕后，控制权就交给bootmain了。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络概述</title>
      <link href="2020/09/22/net/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>2020/09/22/net/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>自顶向下方法第1章</p><a id="more"></a><h2 id="网络组成"><a href="#网络组成" class="headerlink" title="网络组成"></a>网络组成</h2><p>网络由主机（端系统）、分组交换机、传播介质构成。</p><p>网络可划分为核心与边缘（接入网）。</p><p>边缘网络通过边缘路由器接入核心网络。</p><p>链路层交换机一般位于边缘，实现链路层、物理层；路由器一般位于核心，实现网络层、链路层、物理层。</p><blockquote><p>端系统：PC、工作站、网络服务器、邮件服务器、PDA、游戏终端 …</p><p>分组交换机：路由器、链路层交换机 …</p><p>传播介质：同轴电缆、铜线、光纤、无线电频谱 …</p></blockquote><h2 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h2><ol><li>数字用户线（Digital Subscriber Line）<ul><li>ISP: 本地电话公司的本地中心局（CO）</li><li>线路：电话线（双绞铜线）<ul><li>高速下行信道：50kHz - 1MHz</li><li>中速上行信道：4kHz - 50kHz</li><li>普通的双向电话信道：0 - 4kHz</li></ul></li><li>端点：<ul><li>DSL调制解调器：数字数据 -&gt; 高频音</li><li>数字用户线接入复用器（DSLAM）：模拟信号 -&gt; 数字信号</li></ul></li><li>适用情形：本地中心局5-10英里范围内</li></ul></li><li>电缆<ul><li>ISP：有线电视公司</li><li>线路：混合光纤同轴（Hybrid Fiber Coax, HFC）<ul><li>光缆：电缆头端（CMTS） -&gt; 地区枢纽</li><li>同轴电缆：地区枢纽 -&gt; 各家各户</li></ul></li><li>端点：<ul><li>电缆调制解调器</li><li>电缆调制解调器端接系统（CMTS）：模拟信号 -&gt; 数字信号</li></ul></li><li>特征：共享广播媒体</li></ul></li><li>光纤到户（Fiber To The Home, FTTH）<ul><li>ISP: 本地电话公司的本地中心局（CO）</li><li>方案：<ul><li>主动光纤网络（AON）：CO直连HOME</li><li>被动光纤网络（PON）：增加中间节点</li></ul></li><li>端点：<ul><li>路由器 + 光纤网络端接器（ONT）</li><li>路由器 + 光纤线路端接器（OLT）：光信号 -&gt; 电信号</li></ul></li></ul></li><li>卫星、拨号<ul><li>适用情形：无法提供DSL、电缆、FTTH的地方</li><li>卫星：卫星调制解调器、卫星天线</li><li>拨号：传统电话线，与DSL模式相同</li></ul></li><li>以太网、WiFi<ul><li>通过局域网（LAN）与边缘路由器连接</li><li>LAN技术<ul><li>有线LAN：以太网</li><li>无线LAN：IEEE 802.11（WiFi）</li></ul></li><li>以太网：双绞铜线、以太网交换机</li></ul></li><li>广域无线接入：3G、LTE、4G<ul><li>ISP：蜂窝网络提供商</li></ul></li></ol><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>存储转发传输：先接收所有的分组到交换机队列，接着处理队列中的分组，每处理成功一个分组，转发到输出链路。</p><p>分组丢失（丢包）：输出队列已满，交换机会丢弃新到的分组。</p><p>转发表：将目的地址的一部分映射为输出链路，转发表由路由选择协议自动设置。</p><p>电路交换：相比于分组交换，预留了端系统间通信会话期间所需要的资源。电路交换的实现通过频分复用（FDM）或时分复用（TDM）。因特网属于分组交换网络。</p><h2 id="分组交换网"><a href="#分组交换网" class="headerlink" title="分组交换网"></a>分组交换网</h2><p>处理时延：检查分组首部、转发决议 …</p><p>排队时延：排队时延：输出链路正在传输其他分组。</p><p>传输时延：交换机转发的时间，不包括首分组和末分组到达之间的时间。</p><p>传播时延：交换机之前传播需要的时间。</p><p>吞吐量：瓶颈链路的传输速率，如今因特网吞吐量的限制主要在接入网。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>应用层（HTTP、SMTP、FTP）：应用程序间分组（报文）的格式。</p><p>运输层（TCP、UDP）：应用程序间传送分组（报文段）的标准。</p><p>网络层（IP）：主机间传送分组（数据报）的标准。</p><p>链路层（DOCSIS）：网络元素间传送分组（帧）的标准。</p><p>物理层：物理节点间传送比特的标准，不同物理介质有不同的标准。</p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt-android</title>
      <link href="2020/09/16/other/qt-android/"/>
      <url>2020/09/16/other/qt-android/</url>
      
        <content type="html"><![CDATA[<p>deepin qt5.14.1</p><a id="more"></a><p>下载<a href="http://download.qt.io/archive/qt/5.14/5.14.1/qt-opensource-linux-x64-5.14.1.run">QT5.14.1</a>。</p><p>执行<code>sudo apt-get install default-jdk</code>。</p><p>安装androidstudio。</p><p>androidstudio中安装ndk。</p><p>qt creator 工具-选项-设备-Android-选择sdk和ndk路径。</p><p>ndk在sdk文件夹下。</p><p>编译时切换desktop为android。</p>]]></content>
      
      
      
        <tags>
            
            <tag> environ </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>type_traits</title>
      <link href="2020/09/15/C++/type-traits/"/>
      <url>2020/09/15/C++/type-traits/</url>
      
        <content type="html"><![CDATA[<p>比迭代器萃取更广泛的型别萃取。</p><a id="more"></a><p>本文介绍__type_traits，阅读本文前，请确保你已经理解<a href="https://juejin.im/post/6871880576995950600">Traits编程技巧</a>。</p><p>iterator_traits用于萃取迭代器特性，__type_traits用于萃取型别特性。型别特性指其是否具有无关紧要的构造析构等，对于其中无关紧要的部分可以直接处理内存如malloc()、memcpy()等提高效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的value_type()可以方便的获取迭代器的value_type。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type_traits的使用，首先用value_type()获取迭代器所指型别T，接着使用<code>typedef typename __type_traits&lt;T&gt;::is_POD_type is_POD;</code>获取该迭代器所指对象是否为POD型别，接着使用is_POD()作为函数参数，对应__true_type和__false_type两个重载版本函数。</p><blockquote><p>POD意指Plain Old Data，也就是标量型别(scalar types)或传统的C struct型别。POD型别必然拥有trivial ctor/dctor/copy/assignment operator函数。</p></blockquote><p>type_traits.h内声明了所有C++标量型别的特化版本。而如果是我们自己定义的类，使用__type_traits萃取出的都是__false_type（很厉害的那种编译器除外，它可以自己判断是否有trivial函数），即使该类属于POD型别。解决办法是自行设计该类的__type_traits偏特化版本。</p><p>如何判断trivial函数？如果class内涵指针成员，就需要实现non-trivial函数。</p><p>本文内容参考 —— 《STL源码剖析》</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iterator_type</title>
      <link href="2020/09/14/C++/iterator-type/"/>
      <url>2020/09/14/C++/iterator-type/</url>
      
        <content type="html"><![CDATA[<p>迭代器的五种型别。</p><a id="more"></a><p>本文介绍迭代器的value type，difference type，reference type，pointer type，iterator_category五种型别，阅读本文前，请确保你已经理解<a href="https://juejin.im/post/6871880576995950600">Traits编程技巧</a>。</p><h2 id="value-type"><a href="#value-type" class="headerlink" title="value type"></a>value type</h2><p>指迭代器所指对象型别。</p><h2 id="difference-type"><a href="#difference-type" class="headerlink" title="difference type"></a>difference type</h2><p>指两个迭代器之间的距离，也可以用它表示容器最大容量，即头尾迭代器距离。如果一个泛型算法提供计数功能，例如STL中的count()其返回值必须使用difference type。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::<span class="function">difference_type <span class="title">count</span><span class="params">(I first, I last, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != last) &#123;</span><br><span class="line">    <span class="keyword">if</span>(*(first++) == value) &#123;</span><br><span class="line">        ++n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stddef.h定义了ptrdiff_t作为原生指针的difference type，针对<code>T*</code>与<code>const T*</code>设计偏特化萃取机，就可以使用<code>typename iterator_traits&lt;I&gt;::difference_type</code>萃取任何迭代器的difference type。</p><h2 id="reference-type-amp-pointer-type"><a href="#reference-type-amp-pointer-type" class="headerlink" title="reference type &amp; pointer type"></a>reference type &amp; pointer type</h2><p>reference type与pointer type分别对应引用与指针类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt; &#123;</span><br><span class="line"><span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T*&gt; &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="iterator-category"><a href="#iterator-category" class="headerlink" title="iterator_category"></a>iterator_category</h2><blockquote><p>迭代器可根据移动特性与施行操作分为五类：</p><p>Input Iterator：只读迭代器。</p><p>Output Iterator：只写迭代器。</p><p>Forward Iterator：单向读写迭代器。</p><p>Bidirectional Iterator：双向读写迭代器。</p><p>Random Access Iterator：类指针迭代器。</p></blockquote><p>以advanced()函数为例，该函数可以让某个迭代器前进n次，对于不同的迭代器类型，其前进方式是不一样的，例如Forward Iterator通过++运算符前进，但是Random Access Iterator可以通过+=运算符前进，当时当程序调用advanced()时，调用FI版本对RAI而言效率过低，而调用RAI版本则无法接受FI，下面的代码是一种解决办法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advanced</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(is_FI(i)) &#123;</span><br><span class="line">    advanced_FI(i, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(is_RAI(i)) &#123;</span><br><span class="line">    advanced_RAI(i, n);</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样在是形式才确定advanced()版本，效率低，我们希望在编译器确定它，函数重载机制可以帮助我们实现这个目标，我们需要一个占位参数用于重载决议。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ii_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oi_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fi_tag</span>:</span> <span class="keyword">public</span> ii_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bi_tag</span>:</span> <span class="keyword">public</span> fi_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rai_tag</span>:</span> <span class="keyword">public</span> bi_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这些类不需要成员，仅用于重载决议，继承机制使多态得以实现，例如ii与fi版本的advanced()实现相同，fi也可以使用ii版本的函数，不必再在fi版本函数中传递调用ii版本函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt; &#123;</span><br><span class="line"><span class="comment">// 原生指针是rai，我们总将迭代器类型认为是最强化的那一种</span></span><br><span class="line">    <span class="keyword">typedef</span> rai_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T*&gt; &#123;</span><br><span class="line"><span class="keyword">typedef</span> rai_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123;</span><br><span class="line">__advance(i, n, iterator_traits&lt;InputIterator&gt;::iterator_category());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(InputIterator&amp; i, Distance n, ii_tag) &#123;</span><br><span class="line"><span class="keyword">while</span>(n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(InputIterator&amp; i, Distance n, bi_tag) &#123;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(n--) ++i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(n--) --i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(InputIterator&amp; i, Distance n, rai_tag) &#123;</span><br><span class="line">n &gt; <span class="number">0</span> ? i += n : i -= n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>STL提供了iterator class，自设计的迭代器可以直接继承iterator，无需再自定义内嵌型别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span> =</span> <span class="keyword">ptrdiff_t</span>, <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> =</span> T*, <span class="class"><span class="keyword">class</span> <span class="title">Reference</span> =</span> T&amp;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iter</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::rai_tag, T&gt; &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>本文内容参考 —— 《STL源码剖析》</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特性萃取机</title>
      <link href="2020/09/13/C++/%E7%89%B9%E6%80%A7%E8%90%83%E5%8F%96%E6%9C%BA/"/>
      <url>2020/09/13/C++/%E7%89%B9%E6%80%A7%E8%90%83%E5%8F%96%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>STL Traits编程技巧</p><a id="more"></a><h2 id="参数推导"><a href="#参数推导" class="headerlink" title="参数推导"></a>参数推导</h2><p>考虑如何使用C++实现下面python的代码？即定义一个和变量a类型相同的变量b？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">int</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(b)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">type</span>(a)(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(c)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>RTTI性质中的typeid()只能够获取类型名称，无法像python中的type()一样用作变量定义。解决办法是使用function template的参数推导机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">type_impl</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    type_impl(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的缺点很明显，函数模板无法推导函数返回类型。</p><h2 id="内嵌型别"><a href="#内嵌型别" class="headerlink" title="内嵌型别"></a>内嵌型别</h2><p>迭代器所指型别称为value_type，如果value_type需要用于函数返回值，参数推导无法实现。解决办法是使用内嵌型别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iter</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    T* ptr;</span><br><span class="line">    Iter(T* p = <span class="number">0</span>):ptr(p) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span> </span>&#123;</span><br><span class="line"><span class="comment">// typename通知编译器I::value_type是一个型别</span></span><br><span class="line">    <span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Iter&lt;<span class="keyword">int</span>&gt; <span class="title">iter</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func(iter) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码也有缺点，比如对于原生指针，是没有value_type内嵌的。</p><h2 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h2><p>偏特化(partial specialization)：对于一个以上的模板参数，我们可以针对某个或某些模板参数进行特化工作，也就是将泛化版本中的某些template参数赋予明确的指定。</p><p>例如对于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>...&#125;;<span class="comment">// 该泛化版本可以允许任意型别</span></span><br></pre></td></tr></table></figure><p>可以有如下偏特化版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt; &#123;...&#125;;<span class="comment">// 该特化版本仅允许原生指针型别</span></span><br></pre></td></tr></table></figure><p>有了这个方法，就可以解决原生指针无法内嵌型别的问题。</p><h2 id="萃取机"><a href="#萃取机" class="headerlink" title="萃取机"></a>萃取机</h2><p>下面的class template专门用来萃取迭代器的特性，value_type正是迭代器的特性之一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码的意义是：如果I定义有自己value_type，就可以萃取出。</p><p>于是我们可以这样使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iter</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    T* ptr;</span><br><span class="line">    Iter(T* p = <span class="number">0</span>):ptr(p) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> iterator_triats::value_type <span class="title">func</span><span class="params">(I iter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Iter&lt;<span class="keyword">int</span>&gt; <span class="title">iter</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func(iter) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多了这一中间层带来的好处是traits可以拥有特化版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt; &#123;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>于是即便原生指针没有内嵌型别，也可以通过traits取其value_type。</p><p>需要注意的是对于<code>iterator_traits&lt;const int*&gt;::value_type</code>取出的是const int，如果想要取出int，我们需要另一个特化版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T*&gt; &#123;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到此为止，无论是迭代器，还是原生指针都可以通过traits取出正确的value_type。</p><p>STL约定了5种内嵌型别，我们只有遵守这个约定，才可以兼容STL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>本文内容参考 —— 《STL源码剖析》</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>placement_new</title>
      <link href="2020/09/12/C++/placement-new/"/>
      <url>2020/09/12/C++/placement-new/</url>
      
        <content type="html"><![CDATA[<p>operator new and placement new</p><a id="more"></a><h2 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h2><p>C语言中，我们使用malloc分配内存，使用free释放内存。下面代码我们申请了10个字节的空间，但实际上我们获得的空间会大于10个字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">s = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>下面的结构体用来存储申请的内存块信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> is_available;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free根据size来释放空间，标记is_available为可用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span>* <span class="title">mcbp</span>;</span></span><br><span class="line">    mcbp = p - <span class="keyword">sizeof</span>(mem_control_block);</span><br><span class="line">    mcbp -&gt; is_available = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free函数对这一点的实现没有统一的标准，在不同的编译程序中，甚至同一编译程序的不同版本中，其实现都有可能不同。它可能会使用一张记录所分配内存地址和长度的表，或将有关数据存放在内存块，或用一个指针存储相关管理信息等等。 —— 《UNIX环境高级编程》</p><h2 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h2><p>C++语言中，我们使用new/new[]分配内存，使用delete/delete[]释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] s;</span><br><span class="line">s = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* i = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">delete</span> i;</span><br><span class="line">i = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>对于内置对象而言，new操作符会调用默认构造函数，对于自定义对象而言，new操作符会调用我们编写的构造函数，相比于malloc，new操作符多了初始化的操作。相应的delete操作符除了释放空间外，也会调用析构函数。</p><p><strong>new操作符都干了什么事情？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>* sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));<span class="comment">// 内部调用malloc分配内存</span></span><br><span class="line"><span class="keyword">new</span>(p) <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">// 在p上调用构造函数</span></span><br><span class="line"><span class="built_in">string</span>* sp = <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>*&gt;(p);<span class="comment">// void* to string*</span></span><br></pre></td></tr></table></figure><p>operator new不是操作符而是函数，内部也是使用malloc来分配内存，如果类中没有重载operator new函数，new操作符会缺省调用::operator new函数，这个全局operator new函数也可以被重载，这样影响的就是所有对象的内存分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> sz)</span> </span>&#123; <span class="comment">// new</span></span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(sz);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> sz) &#123; <span class="comment">// new[]</span></span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(sz);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator new函数的第一个参数必须是size_t，可以自定义后续参数，size_t由new操作符计算并自动传入。例如<code>new int()</code>调用operator new中sz的值为<code>sizeof(int)</code>。</p><p>但是<code>new int[10]</code>调用operator new[]中sz的值并不是<code>sizeof(int)*10</code>，会多分配4个字节用于存储长度。new[]操作符会根据这4个字节构造所有对象。</p><p>new操作符是先调用operator new分配内存，再调用构造函数；delete操作符则是先调用析构函数，再调用operator delete释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* p) &#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete[]操作符会根据多出来个4个字节来去析构所有的对象。</p><h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p>我们每次使用new去创建对象时，会自动寻找一块空闲内存，那么我们能不能只调用构造函数，不申请内存呢？这就需要placement new，在已经存在的合法空间上去构造对象。</p><p>需要注意的是，placement new并不是指有一个名为placement new的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">new</span>(p) <span class="keyword">int</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面的代码就是placement new，先创建一块内存，然后在这块内存上去调用构造函数。之所以可以<code>new(p)</code>这样使用的原因是因为重载了operator new函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>, <span class="keyword">void</span>* p) &#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，已经不需要size_t参数了，所以只做占位用。我们也可以继续添加其他参数，来实现更多的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> p + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们可以像这样使用new操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* memo = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T)*<span class="number">10</span>);</span><br><span class="line"><span class="keyword">new</span>(memo, <span class="number">3</span>) T();</span><br></pre></td></tr></table></figure><p>上面的代码我们在长度为10的T数组中的第三个位置，构造了一个T对象。placement new使我们可以在一片空间上反复构造新的对象，省去了申请空间所需的时间，大大提高了程序的运行效率。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划系列 —— 背包DP之完全背包</title>
      <link href="2020/08/25/algo/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>2020/08/25/algo/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><blockquote><p>有n个物品，1个容量v的背包，第i个物品体积是volume[i]，价值是value[i]，问将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大，每个物品可以使用无限次。</p></blockquote><p>如果你阅读过我的<a href="https://juejin.im/post/6864812874875797518">上一篇文章01背包</a>，那么完全背包问题的代码只需要在其基础之上作很小的改动。在01背包的状态压缩中我们提到，j值需要向左增长，保证能够正确的引用到上一次状态的结果。</p><p>而若是j值向右增长，那么我们引用的“上一次状态”实际上是已经被更新的当前次的状态，这一步的含义指当前物品可以被重复选择，而这恰好就是完全背包问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [<span class="number">0</span>]*(v+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(volume[i-<span class="number">1</span>], v+<span class="number">1</span>): <span class="comment"># 相比于01背包，只有这一行做了改动</span></span><br><span class="line">            status[j] = <span class="built_in">max</span>(status[j], value[i-<span class="number">1</span>] + status[j-volume[i-<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> status[v]</span><br></pre></td></tr></table></figure><p>如果上面的解释还没有理解，继续向下看，但请确保你已经理解了<a href="https://juejin.im/post/6864812874875797518">01背包问题</a>。</p><hr><p>首先回忆01背包中<code>status[i][j] = max(status[i-1][j], value[i-1] + status[i-1][j-volume[i-1]])</code>的含义。</p><p>在状态转移的过程中，我们考虑前i-1件物品的状态，和是否选择第i件物品，保证了01背包问题中每个物品只能选择一次的特性。</p><p>而对于完全背包问题，每件物品可以无限使用，也就是对于第i件物品，我们可以重复选择，在这种情况下，<code>status[i][j]</code>可以由<code>status[i][j-volume[i-1]]</code>转移而来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [[<span class="number">0</span>]*(v+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, v+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j - volume[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                status[i][j] = <span class="built_in">max</span>(status[i-<span class="number">1</span>][j], value[i-<span class="number">1</span>] + status[i][j-volume[i-<span class="number">1</span>]]) <span class="comment"># 相比于01背包，只有这一行做了改动</span></span><br><span class="line">            <span class="keyword">else</span>: status[i][j] = status[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> status[n][v]</span><br></pre></td></tr></table></figure><p>同样的，我们对完全背包版本的代码作状态压缩。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [<span class="number">0</span>]*(v+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, v+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j - volume[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                status[j] = <span class="built_in">max</span>(status[j], value[i-<span class="number">1</span>] + status[j-volume[i-<span class="number">1</span>]]) <span class="comment"># 相比于01背包，只有这一行做了改动</span></span><br><span class="line">            <span class="keyword">else</span>: status[j] = status[j]</span><br><span class="line">    <span class="keyword">return</span> status[v]</span><br></pre></td></tr></table></figure><p>我们会发现状态压缩后，完全背包和01背包的状态转移方程一致，考虑01背包的j为何要向左增长？是因为01背包中需要尚未更新的<code>status[j-volume[i-1]]</code>，也就是<code>status[i-1][j-volume[i-1]]</code>。</p><p>而完全背包需要的是<code>status[i][j-volume[i-1]]</code>，即已经更新的<code>status[j-volume[i-1]]</code>，所以j需要向右增长，再对分支结构做简单的优化，可以得到最终版本完全背包问题的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [<span class="number">0</span>]*(v+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(volume[i-<span class="number">1</span>], v+<span class="number">1</span>):</span><br><span class="line">            status[j] = <span class="built_in">max</span>(status[j], value[i-<span class="number">1</span>] + status[j-volume[i-<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> status[v]</span><br></pre></td></tr></table></figure><p>这也就是本文最开始给出的代码。</p><p>之所以该问题被称作完全背包，其原因在于对于每一样物品可以使用无限次。在我们遇到的题目中，往往是完全背包问题的变体，我们需要学会如何将题目转换为经典的完全背包问题。</p><p>相关题目：<a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a>，<a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a>。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划系列 —— 背包DP之01背包</title>
      <link href="2020/08/25/algo/01%E8%83%8C%E5%8C%85/"/>
      <url>2020/08/25/algo/01%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a><a href="https://www.acwing.com/problem/content/2/">01背包问题</a></h2><blockquote><p>有n个物品，1个容量v的背包，第i个物品体积是volume[i]，价值是value[i]，问将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大，每个物品只能使用1次。</p></blockquote><p>考虑中间状态，有i个物品，有j个容量，该状态的最高价值为status[i][j]。该状态可以由其上一个状态转移获得，对于第i个物品，我们可以将其丢弃或放入背包，取两者最大值。</p><p>丢弃：status[i][j] = status[i-1][j]</p><p>放入：status[i][j] = value[i] + status[i-1][j-volume[i]]</p><p>这里的（i，j）状态，是第i个物品已经做出选择的结果，他需要上一个状态即选择第i-1个物品后的结果转移而来。j - volume[i]可以理解为，选择物品i后的容量是j，那么未选择之前为j - volume[i]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [[<span class="number">0</span>]*(v+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, v+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j - volume[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                status[i][j] = <span class="built_in">max</span>(status[i-<span class="number">1</span>][j], value[i-<span class="number">1</span>] + status[i-<span class="number">1</span>][j-volume[i-<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">else</span>: status[i][j] = status[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> status[n][v]</span><br></pre></td></tr></table></figure><p>对于矩阵status，其状态只在i-1和i两行之间转移，我们可以使用滚动数组也就是只用两行来不断地更新，维护上一步和当前步的状态，以达到降低空间复杂度的目的。</p><p>这里使用状态压缩，只用一行来记录状态，将二维DP降到一维DP。将上面的代码稍作改动，可以得到下面的错误代码，这里只是单纯的把i状态删掉了。虽然是错误的代码，但我们需要它来辅助理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [<span class="number">0</span>]*(v+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>， v+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j - volume[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                status[j] = <span class="built_in">max</span>(status[j], value[i-<span class="number">1</span>] + status[j-volume[i-<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">else</span>: status[j] = status[j]</span><br><span class="line">    <span class="keyword">return</span> status[v]</span><br></pre></td></tr></table></figure><p>该段代码的问题在于，对于status[j]的计算需要依赖于status[j-volume[i]]的结果，在二维中，status[j]和status[j-volume[i]]是分别处于不同行的，也就是i与i-1两行，但是在一维中，它们都在同一行。</p><p>并且j值是向右增长的，也就是说在计算status[j]时，status[j-volume[i]]的值早已被更新为第i行的状态了，而不是上一步的状态。所以我们需要让j值向左增长。得到如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [<span class="number">0</span>]*(v+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(v, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j - volume[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                status[j] = <span class="built_in">max</span>(status[j], value[i-<span class="number">1</span>] + status[j-volume[i-<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">else</span>: status[j] = status[j]</span><br><span class="line">    <span class="keyword">return</span> status[v]</span><br></pre></td></tr></table></figure><p>这段代码已经是正确的了，但是还不够完美，观察后不难发现status[j] = status[j]这一步是完全没有必要存在的，因此我们可以控制j的最小值，保证j - volume[i-1] &gt;= 0成立。得到最终代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, v, volume, value</span>):</span></span><br><span class="line">    status = [<span class="number">0</span>]*(v+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(v, volume[i-<span class="number">1</span>]-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            status[j] = <span class="built_in">max</span>(status[j], value[i-<span class="number">1</span>] + status[j-volume[i-<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> status[v]</span><br></pre></td></tr></table></figure><p>之所以该问题被称作01背包，其原因在于对于每一样物品只能使用一次。在我们遇到的题目中，往往是01背包问题的变体，我们需要学会如何将题目转换为经典的01背包问题。</p><p>相关题目：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a>、<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a>、<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a>。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划系列 —— 区间DP</title>
      <link href="2020/08/25/algo/%E5%8C%BA%E9%97%B4dp/"/>
      <url>2020/08/25/algo/%E5%8C%BA%E9%97%B4dp/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a><a href="https://www.acwing.com/problem/content/description/284/">石子合并</a></h2><blockquote><p>stones描述n堆石子质量，每次可以合并相邻2堆石子，付出代价为2堆石子质量之和，问n堆石子合并为1堆石子的最小代价？</p><p>例如对于stone = [1, 3, 5, 2]返回22。</p></blockquote><p>考虑对于区间[i, j]，有断点k，则合并[i, j]的代价cost(i, j)为sum(stone[i:j+1]) + cost(i, k) + cost(k+1, j)。对于sum(stone[i:j+1])我们可以使用前缀和做优化。</p><p><strong>DP方案1</strong>：记忆化搜索逆向DP。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">stones</span>):</span></span><br><span class="line">    n, prefix_sum = <span class="built_in">len</span>(stones), [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): prefix_sum[i] = stones[i] + prefix_sum[i-<span class="number">1</span>]</span><br><span class="line">    memory = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i == j: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> memory[i][j]: <span class="keyword">return</span> memory[i][j]</span><br><span class="line">        minimun = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">            minimun = <span class="built_in">min</span>(minimun, search(i, k) + search(k+<span class="number">1</span>, j) + prefix_sum[j] - prefix_sum[i-<span class="number">1</span>])</span><br><span class="line">            memory[i][j] = minimun</span><br><span class="line">        <span class="keyword">return</span> minimun</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> search(<span class="number">0</span>, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>DP方案2</strong>：枚举区间正向DP。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">stones</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(stones)</span><br><span class="line">    prefix_sum = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): prefix_sum[i] = stones[i] + prefix_sum[i-<span class="number">1</span>]</span><br><span class="line">    status = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-length+<span class="number">1</span>):</span><br><span class="line">            j = i + length - <span class="number">1</span></span><br><span class="line">            minimum = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                minimum = <span class="built_in">min</span>(minimum, status[i][k] + status[k+<span class="number">1</span>][j] + prefix_sum[j] - prefix_sum[i-<span class="number">1</span>])</span><br><span class="line">            status[i][j] = minimum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">最长有效括号</a></h2><blockquote><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p>例如对于’(()(()’返回2。</p></blockquote><p>考虑对于区间[i, j]，如果区间[i+1, j-1]是合法的且i，j处匹配，那么status[i, j] = status[i+1, j-1] + 2；接着需要枚举[i, j]内的区间，寻找两个相邻合法区间，取和最大值。例如对于”)()())”中，只有枚举[1, 4]中的区间，才能计算出status[1, 4] = 2 + 2 = 4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n, ans = <span class="built_in">len</span>(s), <span class="number">0</span></span><br><span class="line">    status = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-length+<span class="number">1</span>):</span><br><span class="line">            j = i + length - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">2</span> <span class="keyword">or</span> status[i+<span class="number">1</span>][j-<span class="number">1</span>]) <span class="keyword">and</span> (s[i], s[j]) == (<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>):</span><br><span class="line">                status[i][j] = status[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                <span class="keyword">if</span> status[i][k] <span class="keyword">and</span> status[k+<span class="number">1</span>][j]:</span><br><span class="line">                    status[i][j] = <span class="built_in">max</span>(status[i][j], status[i][k] + status[k+<span class="number">1</span>][j])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, status[i][j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：对该题目使用区间DP会超时，此处仅用此题举例，让读者可以验证自己代码的正确性。<del>（最长合法括号子序列问题没找到，该问题对’(()(()’是返回4的，是找合法子序列的长度，不是子串）</del></p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划系列 —— 线性DP之LIS与LCS</title>
      <link href="2020/08/25/algo/%E7%BA%BF%E6%80%A7dp/"/>
      <url>2020/08/25/algo/%E7%BA%BF%E6%80%A7dp/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长上升子序列</a></h2><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>例如对于[10,9,2,5,3,7,101,18]返回4。</p></blockquote><p>考虑第i位数字nums[i]是否可以继承之前的状态，需要知道之前状态子序列的长度n与最右值m。如果nums[i]大于m，状态i的长度为n+1，最右值为nums[i]。</p><p>上述的动态规划过程可以用一维数组记录中间状态，对于status[i]记录了以nums[i]为子序列最后一个元素的子序列长度。status[i]的计算需要遍历之前的所有状态，取最大长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    status = [<span class="number">1</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]: status[i] = <span class="built_in">max</span>(status[i], status[j]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(status)</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></h2><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。</p><p>例如对于text1 = “abcde”，text2 = “ace” 返回3。</p></blockquote><p>考虑对于中间状态(i, j)，text1[i]与text2[j]的加入是否对已有状态产生了影响。</p><ol><li>text1[i]与text2[j]的加入对已有状态无影响，状态(i, j) = 状态(i-1, j-1) 。</li><li>text1[i]与text2[j-1]匹配，状态(i, j) = 状态(i, j-1)。</li><li>text2[j]与text1[i-1]匹配，状态(i, j) = 状态(i-1, j)。</li><li>text1[i] == text2[j]，text[i]与text[j]匹配，状态(i, j) = 状态(i-1, j-1) + 1。</li></ol><p>上述的动态规划过程可以用二维数组记录中间状态，对于status[i][j]记录了text[:i]与text[:j]的最长公共子序列的长度。status[i][j]的计算依赖于status[i-1][j]，status[i][j-1]，status[i-1][j-1]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">text1, text2</span>):</span></span><br><span class="line">    n, m = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    status = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            status[i][j] = <span class="built_in">max</span>(status[i-<span class="number">1</span>][j], status[i][j-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                status[i][j] = <span class="built_in">max</span>(status[i][j], <span class="number">1</span> + status[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> status[n][m]</span><br></pre></td></tr></table></figure><p>对于情况1，已经包含在status[i-1][j]或status[i][j-1]中。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础算法系列 —— 贪心算法之力扣热度TOP5贪心策略记录</title>
      <link href="2020/08/25/algo/%E8%B4%AA%E5%BF%83/"/>
      <url>2020/08/25/algo/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="TOP1-跳跃游戏"><a href="#TOP1-跳跃游戏" class="headerlink" title="TOP1 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">TOP1 跳跃游戏</a></h2><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><p>例如对于[2,3,1,1,4]返回真，对于[3,2,1,0,4]返回假。</p></blockquote><p><strong>贪心策略1</strong>：如果位置i可以到达，那么i之前的所有位置一定可以到达。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">  reach = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; reach:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    reach = <span class="built_in">max</span>(reach, i + nums[i])</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>贪心策略2</strong>：向前遍历记录可以到达终点的最前的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">  start = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i + nums[i] &gt;= start:</span><br><span class="line">      start = i</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> == start</span><br></pre></td></tr></table></figure><h2 id="TOP2-跳跃游戏Ⅱ"><a href="#TOP2-跳跃游戏Ⅱ" class="headerlink" title="TOP2 跳跃游戏Ⅱ"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">TOP2 跳跃游戏Ⅱ</a></h2><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p><p>例如对于[2,3,1,1,4]返回2。</p></blockquote><p><strong>贪心策略1</strong>：每一次记录能到终点的最前的位置，并更新终点位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">  aim = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  cnt = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> aim:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">      <span class="keyword">if</span> i + nums[i] &gt;= aim:</span><br><span class="line">        aim = i</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>贪心策略2</strong>：记录位置i步长范围内哪个位置能到达的距离最远，此步就走哪个位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">  aim, edge, ans = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">    aim = <span class="built_in">max</span>(aim, i + nums[i])</span><br><span class="line">    <span class="keyword">if</span> i == edge:</span><br><span class="line">      ans += <span class="number">1</span></span><br><span class="line">      edge = aim</span><br><span class="line">  <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="TOP3-买卖股票的最佳时机II"><a href="#TOP3-买卖股票的最佳时机II" class="headerlink" title="TOP3 买卖股票的最佳时机II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">TOP3 买卖股票的最佳时机II</a></h2><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>例如对于[7,1,5,3,6,4]返回7，对于[1,2,3,4,5]返回4。</p></blockquote><p><strong>贪心策略</strong>：只记录上升段收益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">prices</span>):</span></span><br><span class="line">  profit = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">    <span class="keyword">if</span> prices[i] &gt; prices[i-<span class="number">1</span>]:</span><br><span class="line">      profit += prices[i] - prices[i-<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure><h2 id="TOP4-分割平衡字符串"><a href="#TOP4-分割平衡字符串" class="headerlink" title="TOP4 分割平衡字符串"></a><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">TOP4 分割平衡字符串</a></h2><blockquote><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。返回可以通过分割得到的平衡字符串的最大数量。</p><p>例如对于”RLRRLLRLRL”返回4，对于”RLLLLRRRLR”返回3。</p></blockquote><p><strong>贪心策略</strong>：遍历到平衡状态则结果加一。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">s</span>):</span></span><br><span class="line">  ans, balance = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    balance += <span class="number">1</span> <span class="keyword">if</span> i == <span class="string">&#x27;L&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> balance: ans += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="TOP5-分发饼干"><a href="#TOP5-分发饼干" class="headerlink" title="TOP5 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">TOP5 分发饼干</a></h2><blockquote><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p></blockquote><p><strong>贪心策略</strong>：优先满足胃口小的孩子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">g, s</span>):</span></span><br><span class="line">  g.sort()</span><br><span class="line">  s.sort()</span><br><span class="line">  i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(g) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">    <span class="keyword">if</span> g[i] &lt;= s[j]: i += <span class="number">1</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法系列 —— 双向搜索</title>
      <link href="2020/08/25/algo/%E5%8F%8C%E5%90%91/"/>
      <url>2020/08/25/algo/%E5%8F%8C%E5%90%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="字串变换问题"><a href="#字串变换问题" class="headerlink" title="字串变换问题"></a>字串变换问题</h2><blockquote><p>已知两个字串a、b，两个数组from、to，变换规则为：from[i]可以转换为to[i]。问a到b需要经过多少次变换？若10步内a无法变换到b，输出’NO ANSWER!’。</p><p>例如对于<code>a = &#39;abcd&#39;，b = &#39;xyz&#39;，from = [&#39;abc&#39;, &#39;ud&#39;, &#39;y&#39;]，to = [&#39;xu&#39;, &#39;y&#39;, &#39;yz&#39;]</code>：<code>&#39;abcd&#39; -&gt; &#39;xud&#39; -&gt; &#39;xy&#39; -&gt; &#39;xyz&#39;</code>需要经历3次变换。</p></blockquote><p>该题的解决方案使用到了<a href="https://juejin.im/post/6861529337809534989">广度优先搜索</a>，我们将经过一次变换能够得到的所有字符串作为一种状态，然后判断是否存在目标字符串，不存在则计算下一层状态，存在则当前层数为最小变换次数。</p><p>可以得到如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">a, b, f, t</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span>(<span class="params">h, q</span>):</span></span><br><span class="line">        s, n = h</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(f)):</span><br><span class="line">                <span class="keyword">if</span> f[j] != s[i:i+<span class="built_in">len</span>(f[j])]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                q.append([s[:i] + t[j] + s[i+<span class="built_in">len</span>(f[j]):], n+<span class="number">1</span>])</span><br><span class="line">    queue = [[a, <span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        head = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> head[<span class="number">0</span>] == b: <span class="keyword">return</span> head[<span class="number">1</span>]</span><br><span class="line">        extend(head, queue)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;NO ANSWER!&#x27;</span></span><br></pre></td></tr></table></figure><p>如果该题目没有时间限制，这样写当然没有问题。</p><p>考虑一个字符串的一次变换的所有可能，与字符串的长度和变换规则有关，这个中间状态可能数量非常庞大，那我们如何对该代码进行优化呢？</p><p>如果你阅读过<a href="https://juejin.im/post/6862152913654022151">我的上一篇文章</a>可能会想到通过拆分问题规模来分别求解，以达到降低问题数量级的目的。而在本题中，我们分别从a和b同时开始搜索，如果它们的搜索路径相遇了，即找到最小变换次数，通过双向搜索的方式，我们将规模为2N的问题，分解为了两个规模为N的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">a, b, f, t</span>):</span></span><br><span class="line">    ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    qa, qb, da, db = [a], [b], &#123;a:<span class="number">0</span>&#125;, &#123;b:<span class="number">0</span>&#125;</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span>(<span class="params">q, d, f, t</span>):</span></span><br><span class="line">        s = q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(f)):</span><br><span class="line">                <span class="keyword">if</span> f[j] != s[i:i+<span class="built_in">len</span>(f[j])]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tmp = s[:i] + t[j] + s[i+<span class="built_in">len</span>(f[j]):]</span><br><span class="line">                q.append(tmp)</span><br><span class="line">                d[tmp] = d[s]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> qa <span class="keyword">and</span> qb <span class="keyword">and</span> level &lt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">while</span> qa <span class="keyword">and</span> da[qa[<span class="number">0</span>]] == level:</span><br><span class="line">            extend(qa, da, f, t)</span><br><span class="line">        <span class="keyword">while</span> qb <span class="keyword">and</span> db[qb[<span class="number">0</span>]] == level:</span><br><span class="line">            extend(qb, db, t, f)</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> da.keys():</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, da[k] + db.get(k, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)))</span><br><span class="line">        <span class="keyword">if</span> ans &lt; <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>): <span class="keyword">return</span> ans</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;NO ANSWER!&#x27;</span></span><br></pre></td></tr></table></figure><p>该段代码中，开辟了两个队列和两个字典，分别存储双向搜索状态和字串所在层数。每一次队列扩展整一层的数据，用level来记录当前层数。扩展完成后判断两个字典是否有公共键值，如果有则说明发现了搜索路径的交点，对应层数相加即转换次数。</p><p>本文示例题目与<a href="https://www.acwing.com/problem/content/description/192/">acwing 190.字串变换</a>一致，读者可自行尝试提交，验证自己代码的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法系列 —— 折半搜索</title>
      <link href="2020/08/25/algo/%E6%8A%98%E5%8D%8A/"/>
      <url>2020/08/25/algo/%E6%8A%98%E5%8D%8A/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="黄金问题"><a href="#黄金问题" class="headerlink" title="黄金问题"></a>黄金问题</h2><blockquote><p>现在有n块黄金，每块黄金的质量为w[i]，小明可以一次性搬运质量不超过m的物体，问小明一次至多能运走多少质量的黄金？</p></blockquote><p>对于该问题，阅读过我之前讲过的<a href="https://juejin.im/post/6861160844521603080">深度优先搜索</a>应该不难写出如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur, total, status = <span class="built_in">set</span>(<span class="params"></span>)</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cur, n):</span><br><span class="line">        <span class="keyword">if</span> total + w[i] &gt; m:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        status.add(total + w[i])</span><br><span class="line">        dfs(i+<span class="number">1</span>, total + w[i])</span><br><span class="line">    <span class="keyword">return</span> status</span><br></pre></td></tr></table></figure><p>对于w = [1,8,6]，m = 10的数据，可以得到status = {1,8,6,9,7}，也就是w能够组合出的不超过m的所有值，取其最大值即为该问题的答案。</p><p>但是该解法的时间复杂度太高了，为n!（这里还与m值有关，要真有这么大都别玩了），<del>其实这里可以动态规划</del>，我们如何应对更大n值的情况？</p><p>对于规模为10的情况，其复杂度在400w，而对于规模为5的情况，其复杂度在100，也就是说如果我们能够把一个规模为10的问题分解成两个规模为5的问题，那么时间复杂度只需要100 + 100 = 200。速度较之前提升了2万倍。</p><p>那么我们如何通过两个规模为5的解得出规模为10的解呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, m, w</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur, end, total = <span class="number">0</span>, status = <span class="built_in">set</span>(<span class="params"></span>)</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cur, end):</span><br><span class="line">            <span class="keyword">if</span> total + w[i] &gt; m:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            status.add(total + w[i])</span><br><span class="line">            dfs(i+<span class="number">1</span>, end, total + w[i])</span><br><span class="line">        <span class="keyword">return</span> status</span><br><span class="line">    </span><br><span class="line">    ans1 = <span class="built_in">sorted</span>(<span class="built_in">list</span>(dfs(<span class="number">0</span>, n//<span class="number">2</span>)))</span><br><span class="line">    ans2 = <span class="built_in">sorted</span>(<span class="built_in">list</span>(dfs(n//<span class="number">2</span>, n)))</span><br><span class="line">    ans  = <span class="built_in">max</span>(ans1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans2:</span><br><span class="line">        t = binary_search_last_equal_or_lower(m-i, ans1)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, t+i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>上述代码中，我们遍历ans2列表，在ans1寻找最大的且与i相加不超过m的值（反过来也行），并在遍历的过程中动态更新ans的值，遍历结束，ans即我们想要的答案。</p><p>对于最终的ans，有如下三种可能。</p><ol><li>ans1[i] + ans2[j]</li><li>max(ans1)</li><li>max(ans2)</li></ol><p>其中情况1在遍历时完成，情况2在ans赋初值时完成，情况3在ans1没有值可以与m-i结对时完成（这时候二分查找返回0值）。</p><p>本文示例题目与<a href="https://www.acwing.com/problem/content/173/">acwing 171.送礼物</a>一致，读者可自行尝试提交，验证自己代码的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法系列 —— 广度优先搜索</title>
      <link href="2020/08/25/algo/%E5%B9%BF%E6%90%9C/"/>
      <url>2020/08/25/algo/%E5%B9%BF%E6%90%9C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>此篇文章使用广搜解决全排列问题，<a href="https://juejin.im/post/6861160844521603080">我的上一篇文章</a>详细介绍了使用深搜解决全排列问题的方法。</p><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><blockquote><p>给定一个<strong>没有重复数字</strong>的序列，返回其所有可能的全排列。例如对于数列[1, 2, 3]其全排列为[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]。</p></blockquote><p>事实上，在网络上查找全排列问题解决方案，得到的绝大部分答案是使用深度优先搜索解决的，因为相较于广度优先搜索而言，深度优先搜索更容易被理解，下图即深度优先搜索的示意图。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/696cd60580b84f89b1d70e5f69883250~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy"></p><p>为了探索广度优先搜索，我们需要借助另一张图片，考虑如何实现如图所示的按层遍历？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75980a23eca84d0088831b617785e69e~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy"></p><p>我们使用队列数据结构来实现广度优先搜索，初始将[1]，[2]，[3]入队。</p><p>考虑当前节点为[1]的情况：将[1]从队列的头部弹出，遍历nums数组，寻找排列中的第二个数字。易得在nums = [1,2,3]中，2与3可以作为排列中的第二个数字。于是[1,2]，[1,3]入队。</p><p>继续考虑当前节点为[2]，[3]的情况，直至[1,2]，[1,3]，[2,1]，[2,3]，[3,1]，[3,2]全部入队。</p><p>接着弹出队列头部[1,2]，遍历nums数组，寻找排列中的第三个数字，于是[1,2,3]，[1,3,2]入队…直到最后一个三位排列[3,2,1]入队，全部排列寻找完毕。</p><p>代码实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">    queue = [[i] <span class="keyword">for</span> i <span class="keyword">in</span> nums]</span><br><span class="line">    ans = [nums]<span class="comment"># 避免nums只有一个元素的情况，与下面tmp not in ans呼应</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        status = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> status:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tmp = status + [i]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="built_in">len</span>(nums) <span class="keyword">and</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">                ans.append(tmp)</span><br><span class="line">            <span class="keyword">else</span>: queue.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> solution([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span></span><br></pre></td></tr></table></figure><p>试着打印solution函数的中间状态，体会该迭代方法被称作<strong>广度优先搜索</strong>的原因。</p><p>本文示例题目与<a href="https://leetcode-cn.com/problems/permutations/">leecode 46.全排列</a>一致，读者可自行尝试提交，验证自己代码的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法系列 —— 深度优先搜索</title>
      <link href="2020/08/25/algo/%E6%B7%B1%E6%90%9C/"/>
      <url>2020/08/25/algo/%E6%B7%B1%E6%90%9C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>搜索本质上也是对解空间的枚举，本文介绍搜索算法中的深度优先搜索（<del>图论</del>）。</p><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><blockquote><p>给定一个<strong>没有重复数字</strong>的序列，返回其所有可能的全排列。例如对于数列[1, 2, 3]其全排列为[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]。</p></blockquote><p>我们可以使用n层循环，每一层循环内确定一位数字，在最内层循环内判断该排列是否符合要求，例如对于数列nums = [1, 2, 3]，可以写出如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i != j <span class="keyword">and</span> j != k <span class="keyword">and</span> i != k:</span><br><span class="line">                <span class="built_in">print</span> i, j, k</span><br></pre></td></tr></table></figure><p>这道题目分析到这里，其实和<a href="https://juejin.im/post/6860839051662983181">我的第一篇文章</a>的问题很有很大相似的地方，但不同的是在于百鸡百钱问题的自变量个数是固定的，即循环层数是固定的。</p><p>上述代码中我们试图通过每一层循环来确定一个数值，但这段代码只适用于len(nums) == 3的情况，但是如果nums长度为4，5，或更高呢？我们无法动态生成n层循环，<del>除非是用程序编写程序</del>，递归为我们巧妙地解决了这个问题。</p><p>在递归中，我们则通过每一层函数的嵌套来确定一个数值，并且我们只需给出顶层的实现就够了。</p><p>于是我们得出了下面的代码（涉及python中list与set的使用）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums, status</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">set</span>(nums) == <span class="built_in">set</span>(status):</span><br><span class="line">        <span class="built_in">print</span> status</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        solution(nums, status+[x])</span><br></pre></td></tr></table></figure><p>上述代码中，status表示当前函数层次的状态，即一个排列结果，该递归函数可以理解为一个数学表达式：<code>solution = for + solution</code>，那么该solution函数就会被展开为下面的样子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ... <span class="keyword">in</span> <span class="built_in">range</span>(...):</span><br><span class="line"><span class="keyword">for</span> ... <span class="keyword">in</span> <span class="built_in">range</span>(...):</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> ... : <span class="built_in">print</span> ... <span class="comment"># 只有在第n层，条件才会成立</span></span><br></pre></td></tr></table></figure><p>这就和我们最开始给出的代码看上去差不多了。但是现在代码虽然是有限的，可实际展开的时候依旧是无穷无尽的，这就需要我们为solution函数加上一个终止条件，也称<strong>递归出口</strong>。</p><p><strong>如果把递归的过程想象成包子馅的包子，那么如果没有递归出口，这个包子将会变成馒头。</strong></p><p>那么递归出口我们如何去定义呢？</p><p>通过题意不难推出当对于当前层，若当前排列结果status长度大于nums数列长度，即可终止递归。</p><p>于是可得出正确代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums, status</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(status) &gt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">set</span>(nums) == <span class="built_in">set</span>(status):</span><br><span class="line">        <span class="built_in">print</span> status</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        solution(nums, status+[x])</span><br><span class="line"></span><br><span class="line">solution([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [])</span><br><span class="line"><span class="comment"># [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span></span><br></pre></td></tr></table></figure><p>这段代码虽然可以正确运行，但我们可以让他更加美观。最终代码如下。</p><p>这一次，我们将递归出口定义在进入递归函数前，并且将中间状态记录在了ans数组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums, status, ans</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="built_in">len</span>(status):</span><br><span class="line">        ans.append(status)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> status:</span><br><span class="line">            solution(nums, status+[x], ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> solution([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [], [])</span><br><span class="line"><span class="comment"># [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span></span><br></pre></td></tr></table></figure><p>如果在solution的开始输出status的值，我们会得到如下的输出结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[1]</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 3]</span><br><span class="line">[1, 3, 2]</span><br><span class="line">[2]</span><br><span class="line">[2, 1]</span><br><span class="line">[2, 1, 3]</span><br><span class="line">[2, 3]</span><br><span class="line">[2, 3, 1]</span><br><span class="line">[3]</span><br><span class="line">[3, 1]</span><br><span class="line">[3, 1, 2]</span><br><span class="line">[3, 2]</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure><p>观察程序的输出与下面的图片，体会该迭代方法被称作<strong>深度优先搜索</strong>的原因。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de873254cbf444e3bdf4c3bbc59a01fd~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy"></p><p>本文示例题目与<a href="https://leetcode-cn.com/problems/permutations/">leecode 46.全排列</a>一致，读者可自行尝试提交，验证自己代码的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础算法系列 —— 枚举算法</title>
      <link href="2020/08/25/algo/%E6%9E%9A%E4%B8%BE/"/>
      <url>2020/08/25/algo/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="百鸡百钱问题"><a href="#百鸡百钱问题" class="headerlink" title="百鸡百钱问题"></a>百鸡百钱问题</h2><blockquote><p>鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？</p><p>———— 《算经》</p></blockquote><p>前提：100只鸡 + 100块钱，100块钱须全部用完。</p><p>设购买公鸡、母鸡、小鸡的数量分别为x、y、z，则题目可转化为三元二次方程组。</p><blockquote><p>x + y + z = 100</p><p>5*x + 3*y + z/3 = 100</p></blockquote><p>由题意可知x、y、z的范围分别为[0, 20]、[0, 33]、[0, 100]。</p><p>分析到这里，不难写出如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>():</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">                r1 = x + y + z == <span class="number">100</span></span><br><span class="line">                r2 = <span class="number">5</span>*x + <span class="number">3</span>*y + z/<span class="number">3</span> == <span class="number">100</span></span><br><span class="line">                <span class="keyword">if</span> r1 <span class="keyword">and</span> r2:</span><br><span class="line">                    ans.append([x, y, z])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># [[0, 25, 75], [3, 20, 77], [4, 18, 78], [7, 13, 80], [8, 11, 81], [11, 6, 83], [12, 4, 84]]</span></span><br></pre></td></tr></table></figure><p>但是通过分析代码，不难发现在程序中我们没有必要进行三层循环。</p><p>将三元二次方程组转换为二元一次方程，由于z的范围较大，我们选择枚举x、y的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>():</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">            z = <span class="number">100</span> - x - y</span><br><span class="line">            <span class="keyword">if</span> <span class="number">5</span>*x + <span class="number">3</span>*y + z/<span class="number">3</span> == <span class="number">100</span>:</span><br><span class="line">                ans.append([x, y, z])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># [[0, 25, 75], [3, 20, 77], [4, 18, 78], [7, 13, 80], [8, 11, 81], [11, 6, 83], [12, 4, 84]]</span></span><br></pre></td></tr></table></figure><p>百鸡百钱问题到此就成功解决了，由上述分析我们可以得出枚举算法的流程。</p><ol><li><p>建立数学模型，找出解空间。</p></li><li><p>思考是否需要枚举全局解空间？</p></li><li><p>选择合适的枚举顺序。</p></li></ol><p><strong>推荐阅读：</strong></p><p><a href="https://oi-wiki.org/basic/enumerate/">枚举 - OI Wiki</a></p><p><a href="https://www.bilibili.com/video/BV16T4y1G7E1?from=search&seid=15822378719663557467">算法分享-枚举一种简单而又粗暴的算法让你明白为啥要用复杂密码-码农视野</a></p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lab1.1 report</title>
      <link href="2020/08/14/os/lab1-1-report/"/>
      <url>2020/08/14/os/lab1-1-report/</url>
      
        <content type="html"><![CDATA[<p>分析makefile输出内容，了解ucore.img是如何生成的？</p><a id="more"></a><ol><li>下面这些源文件，编译为目标文件</li></ol><ul><li>kern/init/init.c</li><li>kern/libs/stdio.c</li><li>kern/libs/readline.c</li><li>kern/debug/panic.c</li><li>kern/debug/kdebug.c</li><li>kern/debug/kmonitor.c</li><li>kern/driver/clock.c</li><li>kern/driver/console.c</li><li>kern/driver/picirq.c</li><li>kern/driver/intr.c</li><li>kern/trap/trap.c</li><li>kern/trap/vectors.S</li><li>kern/trap/trapentry.S</li><li>kern/mm/pmm.c</li><li>libs/string.c</li><li>libs/printfmt.c</li></ul><ol start="2"><li>上面生成的目标文件链接为可执行程序kernel</li><li>下面这些源文件，编译为目标文件</li></ol><ul><li>boot/bootasm.S</li><li>boot/bootmain.c</li><li>tools/sign.c</li></ul><ol start="4"><li>上面生成的目标文件链接为可执行程序bootblock</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line"><span class="string">&#x27;obj/bootblock.out&#x27;</span> size: 488 bytes</span><br><span class="line">build 512 bytes boot sector: <span class="string">&#x27;bin/bootblock&#x27;</span> success!</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86中断处理</title>
      <link href="2020/08/04/os/x86%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
      <url>2020/08/04/os/x86%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>中断机制在8086时代就被引入了。</p><a id="more"></a><p>自8086开始，物理内存的0地址被中断向量表占据。每个中断向量占据4个字节，x86支持256个中断向量，整个中断向量表占据1KB内存空间。每个中断向量就是一个中断处理函数的入口地址。当一个中断发生时，CPU就在中断向量表中查找对应的中断处理函数，接着跳转到函数开始执行。这一套中断处理机制只在实模式发挥作用。</p><p>编号0-31的中断向量对应异常和不可屏蔽中断、编号32-47的中断向量是IO设备引起的中断属于可屏蔽中断、编号48-255的中断向量表示软中断。linux用120号（即0x80）实现系统调用。</p><p>当8086启动时，BIOS会在物理内存开始地址0x0000:0x0000处初始化中断向量表，各中断默认服务例程由BIOS给出，由于中断向量在中断向量表中按中断号顺序排列，因此给定一个中断号N，对应中断向量在物理内存中的位置就是0x0000:N*4。</p><h1 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h1><p>中断：外部中断（串口、硬盘、网卡、时钟…）、软件产生的中断（INT指令，通常用于系统调用）。可分为外部可屏蔽中断（INTR）、外部非屏蔽中断（NMI）。所有IO设备产生的中断请求（IRQ）均引起INTR，而紧急事件（如硬件故障）引起的故障产生NMI。</p><p>异常：程序错误、软件产生的异常、机器检查出的异常。可分为故障（Fault）、陷阱（Trap）、夭折（Abort）。异常的共同特点是既不使用中断控制器，又不能被屏蔽。</p><p>cpu对不同类型的中断源，获取对应中断号的方法是不同的。可屏蔽中断的中断号是在中断响应周期从中断控制器获取的。软中断INT nH的中断号是由中断指令直接给出的。不可屏蔽中断NMI及cpu内部一些特殊中断是由系统预先设置好的，如NMI的中断号为02H，非法除数的中断号为0H等等。</p><h1 id="8295A"><a href="#8295A" class="headerlink" title="8295A"></a>8295A</h1><p>8086采用8295A芯片作为中断控制器，随着计算机的发展中断控制器开始集成到cpu内（南桥），8295A单片芯片有8个中断输入引脚，通常两级片连使用，共15个中断输入信号（其中一个芯片的引脚和连接另一个芯片）。</p><p>8095A和8086接口有三个：一是系统总线，传输中断号；二是8086的INTR引脚，发送中断请求信号；三是8086的INTA引脚，用于消除中断。</p><p>中断流程：IO设备产生一个中断，发送一个电平变化给8295A，8295A编码中断号放到系统总线上，然后发出一个INT信号，8086收到INT信号后读取中断号，然后去中断向量表查询中断处理例程入口地址，跳转执行该处理程序。中断处理例程通常首先发送一个INTA信号，通知8295A该中断已被响应，可以消除。</p><p>8095A两片共16个引脚，对应16个中断请求号，级联时一般用IRQ2作为级联引脚，接第二片8295A的输出，也就是说IRQ2通常是没有中断产生的。通常硬件产生IRQ的顺序为：IRQ0(时钟)、IRQ1(键盘)、IRQ3(tty2)、IRQ4(tty1)、IRQ5(XT Winchester)、IRQ6(软驱)、IRQ7(打印机)、IRQ8(实时时钟)、IRQ9(重定向的IRQ2)、IRQ13(FPU异常)、IRQ14(AT Winchester)。</p><p>8295A初始化时，传入其ICW3控制字一个8位数字，其低三位没有意义。当8295A产生一个中断时，会得到一个引脚编号0-7，组成低3位，与ICW3的高5位组成一个字节，即中断号。通常第一片8295A的ICW3设置为0x20，第二片8095A的ICW3设置为0。所以键盘中断的中断号就是00100001H。</p><hr><p>引入保护模式后，一套更复杂的中断机制代替了中断向量表（Interrupt Vector Table IVT），即中断描述符表（Interrupt Descriptor Table IDT）。IDT不再固定存放在内存某个位置，而是可以放在IDTR寄存器指向的任意内存（不能太任意，比如字节对齐之类的小规则）。IDT的表项也不再是中断向量的4个字节，而是扩展为8个字节。表长也可以不足256，空描述符应置其存在位为0。IDTR寄存器占48位，高32位为基地址，低16位为界限值。</p><h1 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h1><p>在os中，有三种特殊的中断事件。</p><ol><li><p>由cpu外部设备引起的外部事件如IO中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与cpu的执行无关，该类称之为异步中断，也称外部中断，简称中断。</p></li><li><p>在cpu执行指令期间检测到不正常的或非法的条件（如除零、地址访问越界）所引起的内部内部事件称作同步中断，也称内部中断，简称异常。</p></li><li><p>在程序中使用请求系统服务调用而引发的事件，称作陷入中断（trap interrupt），也称软中断，系统调用简称trap。</p></li></ol><h1 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h1><p>当cpu收到中断（通过8295A完成）或异常的事件时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理例程中，在完成这个事件的处理后，再跳回刚才被打断的程序或任务中。每个中断或异常与一个中断服务例程（Interrupt Service Routine ISR）关联，其关联关系存储在中断描述符表中。而IDT的起始地址和大小保存在中断描述符表寄存器IDTR中。</p><p>IDT把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个表项占8字节的描述符数组，但IDT的第一项可以包含描述符。每个描述符相对于IDT基址的偏移为中断号*8。</p><p>cpu通过LIDT和SIDT指令操作IDTR，两条指令都有一个6字节的显示操作数表示内存地址。</p><p>LIDT（Load IDT Register）指令：使用一个包含线性地址基址和界限的内存操作数来加载IDT，os创建IDT时需要该指令设定IDT起始地址，该指令只能在ring0执行。</p><p>SIDT（Store IDT Register）指令：拷贝IDTR的基址和界限到一个内存地址，该指令可以在任意特权级执行。</p><p>保护模式下，中断描述符表最多存在256个门描述符，[0, 31]被Exception和NMI使用，[32, 255]保留给用户定义的中断，用户可以将他们用作外部IO设备中断，或系统调用等。</p><h1 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h1><p>IDT中的项即IDT gate descriptors（门描述符），包含三种类型的门描述符。</p><ol><li><p>Task-gate descriptor（任务门描述符）</p></li><li><p>Interrupt-gate descriptor（中断门描述符）</p></li><li><p>Trap-gate descriptor（陷入门描述符）</p></li></ol><p>中断（外部中断、异常、系统调用）应使用中断门和陷入门，它们的区别是，调用中断门时，中断会被cpu自动禁止，而调用陷入门时，cpu不会禁止或打开中断。  </p><h1 id="中断流程"><a href="#中断流程" class="headerlink" title="中断流程"></a>中断流程</h1><p>中断的处理除了中断服务例程里面的代码之外，还有两个过程是由硬件完成的。</p><p><strong>过程1</strong>：cpu收到中断事件，打断当前任务执行，再跳转到中断服务例程执行。</p><ol><li><p>cpu执行完当前程序每一天指令后，会去确认8295A是否有发送中断请求过来，如果有cpu就会在总线上读取中断向量。</p></li><li><p>以读到的中断向量为索引到IDT找到对应的门描述符，门描述符里有对应终端服务例程的段选择子。</p></li><li><p>根据段选择子在GDT中取得对应段描述符，段描述符里有保存中断服务例程（这里把例程看作一个段）的段基址和属性信息，接着跳转到该起始地址。</p></li><li><p>根据CPL和DPL判断特权级是否发生转换，如果发生了需要切换堆栈。</p></li><li><p>保存相关现场信息，将相关寄存器压栈。</p></li><li><p>将中断服务例程的第一条指令加载到CS:IP，开始执行中断服务例程。</p></li></ol><p><strong>过程2</strong>：中断服务例程执行完成使用IRET恢复被打断程序的执行。</p><ol><li><p>恢复现场，包括CS:IP，回到程序中继续执行。</p></li><li><p>如果存在特权级转换，还要切换堆栈。</p></li><li><p>如果处理的是带错误码的异常，需要被打断程序自行弹出堆栈中的错误码。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc内联汇编</title>
      <link href="2020/08/03/C++/gcc%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>2020/08/03/C++/gcc%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p>有些指令并没有对应的C语言语句，这时候就需要内联汇编。</p><a id="more"></a><h1 id="基本内联汇编"><a href="#基本内联汇编" class="headerlink" title="基本内联汇编"></a>基本内联汇编</h1><p>gcc在处理时，把asm(…)的内容打印到汇编文件中，所以多行需要”\n\t”做格式控制,让 gcc 把内联汇编代码翻译成一般的汇编代码时能够保证换行和留有一定的空格。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( </span><br><span class="line">  <span class="string">&quot;pushl %eax\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0,%eax\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popl %eax&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="扩展内联汇编"><a href="#扩展内联汇编" class="headerlink" title="扩展内联汇编"></a>扩展内联汇编</h1><p>gcc扩展内联汇编基本格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> [<span class="keyword">volatile</span>] (</span><br><span class="line">  Assembler Template</span><br><span class="line">  : Output Operands</span><br><span class="line">  [ : Input Operands</span><br><span class="line">  [ : Clobbers ] ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例子：开启保护模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> cr0;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl %%cr0, %0\n&quot;</span> :<span class="string">&quot;=r&quot;</span>(cr0))</span></span>; <span class="comment">// 将cr0寄存器读入cr0变量</span></span><br><span class="line">cr0 |= <span class="number">0x80000000</span>;                            <span class="comment">// 将cr0的0号bit置1</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl %0, %%cr0\n&quot;</span> ::<span class="string">&quot;r&quot;</span>(cr0))</span></span>; <span class="comment">// 将cr0变量写入cr0寄存器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C函数调用流程</title>
      <link href="2020/08/03/C++/C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
      <url>2020/08/03/C++/C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>函数参数、局部变量、调用、返回等机制剖析。</p><a id="more"></a><p>函数的调用时通过栈实现的，栈的生长方向是自顶向下，每个函数自己的栈空间被称作栈帧，所以主调函数的栈帧位于高地址，被调函数的栈帧位于低地址。EBP和ESP分别是当前栈帧的栈基指针和栈顶指针。</p><p>每个栈帧的生长方向也是自顶向下，底部存放将要跳转的地址，也就是返回地址。顶部存放上个栈帧的EBP，也就是上个栈帧的基址。在中间部分存放局部变量和函数参数。</p><p>函数的调用对应汇编语言的CALL指令，返回对应汇编语言的RET指令。CALL相当于将CS、IP压栈（这个就是上一条提到的栈帧底部的地址，也可能只压IP），然后跳转到函数入口。RET相当于弹出CS、IP，然后跳转到下一条指令。</p><p>函数参数的传递是通过寄存器来实现的。EXI、ESI、EDX、ECX分别对应从左至右第1、2、3、4个参数。参数准备好之后调用CALL指令。</p><p>跳转到函数执行后，首先将主调函数的EBP压入被调函数，接着将主要函数的ESP作为被调函数的EBP构造栈帧顶，接着ESP会向下移动，然后将IP压入栈中构造栈帧底。中间的局部变量和函数参数是通过对EBP进行偏移来构造的。函数完成计算将结果存入EAX中。然后调用LEAVE和RET指令，LEAVE相当于将被调函数的EBP给到ESP，弹出EBP，即切换当前栈帧到主调函数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>intern day thirty one</title>
      <link href="2020/07/31/record/intern-day-thirty-one/"/>
      <url>2020/07/31/record/intern-day-thirty-one/</url>
      
        <content type="html"><![CDATA[<p>自己把自己写的东西放到谷歌上翻译了一下，惨不忍睹… 我的六级可咋整呀，别再毕业了还没过。</p><a id="more"></a><p>This week the mentor has arranged the third task, which was basically completed yesterday. When there is no need to move bricks，just learning about os，the feeling of deep into computer system baselayer is fascinating.</p><p>I will move to the company tomorrow. I don’t know whether my new roommate is easy to get along with, but the good thing is that it only takes ten minutes to get from the bed to the office cubicle, and I can sleep a bit longer.</p><p>What’s more down is that I didn’t actually learn something in this month. I feel that anyone can also do these tasks… I have also seen posts on the intranet saying even simple tasks. You can also learn things, you have to add your own needs…but I really don’t want to spend time learning python, even if the cost of learning python on the basis of C++ is very low, I still have some resistance.</p><p>Maybe the only improvement is the ability to read the source code. This week, for projects with dozens of gigabytes, I can find out where to start in one day, applaud myself = =</p><p>When the foundation has consolidated in the future, try to read the source code of nginx or redis. I have never dared to try before.</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>特权级</title>
      <link href="2020/07/31/os/%E7%89%B9%E6%9D%83%E7%BA%A7/"/>
      <url>2020/07/31/os/%E7%89%B9%E6%9D%83%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>在x86-32保护模式下，通过特权级来实现保护机制。</p><a id="more"></a><p>在保护模式下，特权级有0、1、2、3四个，0最高，3最低。主要有三种资源受到保护：内存、IO端口、执行特殊机器指令的能力。在任意时刻，cpu都是在一个特定的特权级下运行的，从而决定了代码可以做什么，不可以做什么。这些特权级经常被称作保护环，最内环对应0特权级，最外环对应3特权级。在ucore中，cpu只用到了0、3两个特权级，分别对应内核态和用户态。</p><p>大约15条机器指令被cpu限制只能在内核态执行，所以它们被保留给操作系统内核使用。如果企图在ring0以外运行这些指令，就会导致一个一般保护异常，对内存和IO端口的访问也受类似的特权级限制。</p><p>数据段选择子的内容可以直接由程序加载到段寄存器(SS、DS等数据段)，这些内容里包含了2位的RPL(请求特权级)。但是代码段寄存器的内容不能由装载指令(MOV等)直接设置，而只能被会改变程序执行顺序的指令(JMP等)间接的设置，并且CS的低2位不再是RPL，而是一个由cpu维护的CPL(当前特权级)字段。代码段寄存器的CPL字段的值总是等于当前cpu所处的特权级。</p><p>当一个数据段选择子被加载时，会判断max(CPL, RPL) &lt;= DPL，为真则访问正常进行。在大多数情况下，RPL和CPL是一致的。但也有可能用户程序发生系统调用，此时请求者是用户程序，所以RPL为3。因为调用的是系统内核代码，所以CPL是0。此时只有DPL为3，数据段才可以被正常访问。（堆栈段是个例外，要求CPL、RPL、DPL三者相等才可以被正常访问。）</p><p><strong>CPL、RPL、DPL总结：</strong></p><ol><li><p>CPL：当前特权级（Current Privilege Level）保存在CS段寄存器的最低2位，CPL就是当前活动代码的特权级，也表示当前执行程序的特权级别。</p></li><li><p>DPL：描述符特权级（Descriptor Privilege Level）存储在段描述符中的权限位，用于描述对应段本身能被访问的特权等级。</p></li><li><p>RPL：请求特权级（Request Privilege Level）保存在段寄存器的最低2位，表示进程对段访问的请求权限，RPL一般被看作附加条件，只有它大于CPL才生效。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>段机制</title>
      <link href="2020/07/30/os/%E6%AE%B5%E6%9C%BA%E5%88%B6/"/>
      <url>2020/07/30/os/%E6%AE%B5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>段机制的引入最初是为了解决x86-16体系中16位寄存器对20位地址线的寻址问题，但我们通常说的分段内存管理指的是保护模式下的段机制。</p><a id="more"></a><h1 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h1><p>x86-16体系中，寄存器16位，段寄存器16位，地址线20位，当cpu执行指令访问内存时，由于寄存器和地址线位数不匹配，物理地址通过段首地址和偏移地址得出。</p><p>x86-32体系中，寄存器32位，段寄存器16位，地址线32位，寄存器与地址线位数相等，但是为了兼容x86-16，依旧需要支持段机制，所以引入了保护模式，之前的模式则称为实模式。</p><p>在实模式中，物理地址(20位) = 段首地址(16位) &lt;&lt; 4 + 偏移地址(16位)，cpu具有1MB的寻址能力。段界限就是64KB(2^16)，因为IP寄存器是16位的。</p><p>在保护模式中，cpu具有4GB的线性/物理地址空间寻址能力（线性地址空间由一维的线性地址构成，线性地址空间和物理地址空间对等，线性地址32位长，线性地址空间容量为4GB），段首地址(16位)只是一个索引，指向<strong>全局描述符表</strong>(Global Descriptor Table GDT)或<strong>局部描述符表</strong>(Local Descriptor Table LDT)的一个表项。</p><blockquote><p>保护模式下有两个段表，GDT和LDT，每一张段表可以包含8192(2^13)个段描述符，因此最多可以同时存在2*2^13=16384(2^14)个段，所以保护模式下可以访问64TB(16384*4GB)的逻辑地址空间。虽然保护模式下有很多段，逻辑地址空间看起来很大，但事实上并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的，目前所谓的64TB逻辑地址空间只是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有4GB那么大。</p></blockquote><h1 id="分段内存管理综述"><a href="#分段内存管理综述" class="headerlink" title="分段内存管理综述"></a>分段内存管理综述</h1><p>x86-32工作在保护模式时，可以使用全部32位地址线访问4GB物理地址空间，因为所有的通用寄存器都是32位的，所以用任何一个通用寄存器来间接寻址，不需要段机制就可以访问4G空间中的任意内存地址，但这并不意味着段寄存器没用了。</p><p>实模式中将整个物理内存看成分段的区域（这些区域就称之为段Segment，编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的），代码和数据位于不同区域，操作系统和用户程序并没有区别对待，而且每一个指针都指向实际的物理地址，这样，用户程序的指针如果指向了操作系统区域，或其他用户程序区域，并做出了修改操作，这对系统的安全性来讲是致命的。</p><p>而在保护模式下，提供了4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。我们用64位长的数据表示保护模式下的段属性和段参数，我们把这个64位的数据成为<strong>段描述符</strong>，它包含三个成员：<strong>段基址</strong>、<strong>段界限</strong>、<strong>段属性</strong>。但是段寄存器是16位的，无法存储长达64位的段描述符。</p><p>解决办法是将所有的段描述符顺序存储在内存的指定位置，组成一个段描述符表(Descriptor Table)，而段寄存器中的16位空间存储索引信息，此时段寄存器中的信息不再是段首地址，而是段选择子(Selector)，通过它可以在段描述符表中选择一个单位得到段的全部信息。</p><p>那么段描述符表存放在哪里？x86-32引入了两个新的寄存器管理段描述符，就是GDTR和LDTR，用于存放段描述符表首地址。</p><h1 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h1><p>在保护模式的分段内存管理机制下，每个段描述符占8字节，由如下三个参数定义：段基址(Base Address)、段界限(Limit)、段属性(Attributes)。</p><p>段基址：规定<strong>线性空间中段的起始地址</strong>，在x86-32保护模式下，段基址长32位，因为段基址长度和地址线长度相等，所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不像实模式下段基址必须是16的整数倍。</p><p>段界限：规定<strong>段的大小</strong>，在x86-32保护模式下，段界限长20位，而且段界限的单位可以是B或4KB。</p><p>段属性：规定<strong>段的各种属性</strong></p><ol><li><p>粒度位(Granularity)：用符号G表示。G=0表示段界限以B为单位，20位长的段界限可表示的范围是1B-1MB，增量为1B。G=1表示段界限以4KB为单位，20位长的段界限可表示的范围是4KB-4GB，增量为4KB。</p></li><li><p>类型(Type)：用于区别不同类型的段描述符，可表示该段是代码段还是数据段，是否可读、可写、可执行，段的扩展方向等。</p></li><li><p>描述符特权级(Descriptor Privilege Level DPL)：用来实现保护机制。</p></li><li><p>段存在位(Segment-Present bit)：若该位为0，则此段描述符是非法的，不能被用来实现地址转换。如果一个指向非法段描述符的段选择子被加载到段寄存器，cpu会立即产生异常。</p></li><li><p>已访问位(Accessed bit)：当处理器访问该段时（当一个指向该段描述符的段选择子被加载进一个段寄存器时），将自动设置访问位。操作系统可清楚该位。</p></li></ol><h1 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h1><p>段选择子长16位，就是实模式下的段寄存器，由GDTR访问段描述符是通过段选择子完成的，段选择子包括三部分：<strong>描述符索引</strong>(Index)、<strong>表指示位</strong>(Table Indicator TI)、<strong>请求特权级</strong>(Requested Privilege Level RPL)。段选择子的Index部分表示所需要的段描述符在GDT中的位置，由这个位置再根据GDTR存储的表基址就可以找到相应的段描述符，然后用段描述符中的段基址加上逻辑地址的偏移量就可以转换为线性地址。段选择子可以作为指针变量的一部分，从而对程序员是可见的，但一般是由连接加载器来设置的。</p><ol><li><p>索引(高13位)：在描述符表的8192个描述符中选择一个，处理器自动将该索引值乘以8（描述符的长度），再加上表基址来索引描述符表，从而选出需要的段描述符。</p></li><li><p>表指示位(中1位)：选择应该访问哪一个描述符表，0代表访问GDT，1代表访问LDT。</p></li><li><p>请求特权级(低2位)：保护机制，代表选择子的特权级，分0、1、2、3四个特权级。任务中的每一个段都有一个特定的级别，每当一个程序试图访问一个段时，就将该程序拥有的特权级与要访问的段的特权级进行比较，已决定是否能访问该段。系统约定，cpu只能访问统一特权级或较低特权级的段。</p></li></ol><p>全局描述符表的第一项是不能被cpu使用，所以当一个段选择子的索引和标志指示位都为0时，即段选择子指向GDT的第一项时，可以当作一个空的选择子，当一个指向空描述符的空选择子被加载到段寄存器时，处理器并不会产生一个异常，但是当用一个空选择子去访问内存时，则会产生异常。</p><blockquote><p>例子：给出逻辑地址 21H:12345678H 转换为线性地址。</p><p>21H即选择子，就是段寄存器里面的值，21H = 0000 0000 0010 0001b，取高13位：0000000000100b = 4，取中1位：0，取低2位：01，代表选择GDT的第4个描述符，特权级为1。</p><p>12345678H为逻辑地址偏移量，若GDT中第4个段描述符中的段基址为11111111H，则线性地址为11111111H + 12345678H = 23456789H。</p><p>若只采用了段机制，无页机制，那么此时该线性地址即物理地址。</p></blockquote><h1 id="全局-局部描述符表"><a href="#全局-局部描述符表" class="headerlink" title="全局/局部描述符表"></a>全局/局部描述符表</h1><p>全局描述符表在整个系统中只有一张，GDT可以被存储在内存中的任何位置，cpu通过寄存器GDTR存放GDT入口地址，程序员将GDT设定在内存中的某个位置后，可以通过LGDT、SGDT指令将GDT入口地址加载、保存到GDTR寄存器，GDTR寄存器占48位，其中高32位存放GDT在内存中的基址，低32位存放表长界限，该界限单位为字节。在机器刚加电或处理器复位后，GDTR中的基地址被设置为0，表界限被设置为0xFFFF，所以在保护模式初始化过程中必须给GDTR加载一个新值。GDT中的第一个段描述符被设定为空段描述符。</p><blockquote><p>关于GDT的第一项为什么被设定为空？如果一个任务没有LDT，LDT选择子就指向GDT中的第一项，即空段描述符。</p></blockquote><p>局部描述符表在整个系统中可以由若干张，每个任务可以有一张。GDT和LDT的关系可以理解为：GDT为一级描述符表，LDT为二级描述符表。即GDT的项不再是段描述符，而是LDT描述符（LDT也可以看作一个段，自然也有对应的描述符）。LDTR间接记录LDT的入口地址，与GDTR不同的是，LDTR的内容是一个段选择子，该选择子指向GDT中的LDT描述符。LDTR在程序中可以通过LLDT随时改变。</p><blockquote><p>例子：若需要的段描述符在LDT2的第三个项，逻辑地址偏移量为12345678H。</p><p>那么LDTR中的段选择子为：0000 0000 0001 0000b(Index = 2，TI = 0，RPL随意)。段寄存器中的段选择子为：0000 0000 0001 1100b(Index = 3，TI = 1，RPL随意)。</p><p>LDT的入口地址不像GDT一样，不是由LDTR直接得到，而是由LDTR中的段选择子指向的GDT中的LDT描述符中的LDT段基址得到。</p><p>由LDT的段选择子在GDT中选择出LDT描述符，由LDT描述符中的段基址(即LDT入口地址)可以找到LDT，由LDT和段寄存器中的段选择子得到的段描述符可以知道段基址，例如段基址为11111111H，则线性地址为11111111H + 12345678H = 23456789H。</p><p>若只采用了段机制，无页机制，那么此时该线性地址即物理地址。</p></blockquote><p>由于每个进程都有一套自己的程序段，数据段、堆栈段、有了LDT则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问（每个进程一个LDT，改变LDTR就可以在不同的LDT中切换，段寄存器保持不变，就可以访问不同进程的某一个段了）。</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>x86启动</title>
      <link href="2020/07/27/os/x86%E5%90%AF%E5%8A%A8/"/>
      <url>2020/07/27/os/x86%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>thu ucore lab 1.1</p><a id="more"></a><h2 id="第一条指令"><a href="#第一条指令" class="headerlink" title="第一条指令"></a>第一条指令</h2><p>当cpu加电后，为了向下兼容8086，处于16位的实模式，采用实模式的寻址方式，CS和EIP的初值决定了cpu在哪个地址取得相应的指令并执行。</p><p>通常第一条指令是长跳转指令（CS和EIP会被更新），会跳到BIOS代码执行，一个可以被访问的1M（实模式地址总线20位可用，2^20 = 1M）的内存空间中。</p><p>初始时CS = F000H，EIP = 0000FFF0H，实际地址是Base + EIP = FFFF0000H + 0000FFF0H = FFFFFFF0H，这是BIOS的EPROM所在地。</p><p>实模式的寻址一共20位，通过CS:IP获取（:就是CS左移4位再加上IP的意思，CS和IP都是16位），没有段页机制，因为还没进入到保护模式。</p><blockquote><p>在80x86CPU中设置的段寄存器只有16位，只能存放20位段起始地址的高16位，称它为段基值，而机器将段起始地址的低4位设置为0。故将段基值左移4位后，就得到一个20位的段起始地址，称它为段基地址或段基址。—— baidu</p><p>老式电脑的BIOS芯片，一般是EPROM（可擦除可编程只读存储器）。—— wiki</p><p>CPU复位（reset）或加电（power on）的时候以实模式启动，处理器以实模式工作。在实模式下，内存寻址方式和8086相同，由16位段寄存器的内容乘以16（10H）当做段基地址，加上16位偏移地址形成20位的物理地址，最大寻址空间1MB，最大分段64KB。可以使用32位指令。32位的x86 CPU用做高速的8086。在实模式下，所有的段都是可以读、写和可执行的。</p><p>286架构导入保护模式，允许硬件等级的存储器保护。然而要使用这些新的特色，需要额外先前不需要的软件指令。由于x86微处理机主要的设计规格，是能够完全地向前兼容于针对先前所有x86芯片所撰写的软件，因此286芯片的开机是处于’实模式’—也就是关闭新的存储器保护特性的模式，所以可以运行针对旧的微处理器所设计的软件。到现在为止，即使最新的x86 CPU一开始在电源打开处于实模式下，也能够运行针对先前任何芯片所撰写的软件。—— baidu</p></blockquote><h2 id="BIOS到BootLoader"><a href="#BIOS到BootLoader" class="headerlink" title="BIOS到BootLoader"></a>BIOS到BootLoader</h2><p>BIOS主要是做一些底层的硬件初始化工作，保证机器能够进行后续的正常工作。接着BIOS会加载存储设备（比如软盘、硬盘、光盘、USB盘）上的第一个扇区（主引导扇区，Master Boot Record, or MBR）的512字节到内存的0x7c00处（一个扇区就是512字节），然后跳转到0x7c00的第一条指令开始执行。</p><p>这个扇区里面的代码就是BootLoader的执行代码。BootLoader完成对操作系统的进一步加载。BIOS为什么不直接加载操作系统？这取决于BIOS的能力问题，在最初设计的时候，BIOS完成的功能就是只加载一个扇区，但一个操作系统代码容量是大于512字节的。</p><h2 id="BootLoader到OS"><a href="#BootLoader到OS" class="headerlink" title="BootLoader到OS"></a>BootLoader到OS</h2><p><strong>BootLoader完成的事情:</strong></p><ol><li><p>建立GDT，描述段表大致空间，给出位置和大小，设置DGTR值。</p></li><li><p>从实模式切换到保护模式（设置CR0寄存器0号bit为1），16位寻址空间切换到了32位寻址空间，1M寻址到4G寻址，为后续操作系统执行做准备，一旦切换到了保护模式，段机制就自动开启了。</p></li><li><p>从硬盘上读取kernel in ELF格式的kernel（跟在MBR后面的扇区）并放到内存中的固定位置。kernel的大小是占多个扇区的。</p></li><li><p>跳转到os的入口点执行，这时控制权转移到了os中。就是改一下CS和EIP的值。</p></li></ol><blockquote><p>ELF文件格式</p><p>在计算机科学中，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p><p>是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。</p><p>1999年，被86open项目选为x86架构上的类Unix操作系统的二进制文件标准格式，用来取代COFF。因其可扩展性与灵活性，也可应用在其它处理器、计算机系统架构的操作系统上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qemu安装</title>
      <link href="2020/07/27/other/qemu%E5%AE%89%E8%A3%85/"/>
      <url>2020/07/27/other/qemu%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>系统环境：CentOS 7.5 64位</p><a id="more"></a><p><code>yum update</code>、<code>yum upgrade</code>先给一套，然后<code>yum install qemu-system-x86</code>这里是需要模拟x86环境，所以只装了这个，不加x86就是所有的都装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(process:10709): GLib-WARNING **: 11:21:49.275: gmem.c:489: custom memory allocation vtable not supported</span><br><span class="line">qemu: could not load PC BIOS <span class="string">&#x27;bios-256k.bin&#x27;</span></span><br><span class="line">make: *** [qemu] Error 1</span><br></pre></td></tr></table></figure><p>如果有如上报错，执行<code>yum install seabios</code>，bios-256k.bin是一个软连接，但是没有对应的文件，需要安装相应的软件包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(process:23148): GLib-WARNING **: 12:26:31.595: gmem.c:489: custom memory allocation vtable not supported</span><br><span class="line"></span><br><span class="line">(qemu-system-i386:23148): Gtk-WARNING **: 12:26:31.647: cannot open display: </span><br><span class="line">make: *** [qemu] Error 1</span><br></pre></td></tr></table></figure><p>然后启动时又出现了这样的错误，因为我的系统环境是在服务器上，没有图形界面，启动qemu加上无图形界面参数就好了。应该是<code>-nographic</code>这个参数，不过我也没试过，ucore已经把makefile都写好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> environ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>intern day twenty three</title>
      <link href="2020/07/23/record/intern-day-twenty-three/"/>
      <url>2020/07/23/record/intern-day-twenty-three/</url>
      
        <content type="html"><![CDATA[<p>Times flies!</p><a id="more"></a><p>It may be because of the COVID. This year has passed quickly. I have only spent three semesters in school, but I feel that my life in college is about to end. At noon I lie down on the table and rest, thinking about what I will do for the next ten years. It’s really down to live like now. I would like to try whether it is possible to change careers. Like be a PM in the future and feel that I am more interested in the product. Then let programming as my specialty. It seems pretty good.</p><p>Compared with other interns, because I don’t need to care about the issue of getting regular, and I don’t need to prepare for autumn recruitment, my life is pretty leisurely. It’s a pity that I have no chance to complete a project with other interns during the internship, but recently I also talked to my roommate in Netease. I really owe a lot. I also feel the gap between myself and a famous school. There’s no way that I can only do my best to find resources on the Internet, work hard to acquire knowledge, and strive to bridge these gaps!</p><p>Not surprisingly, my life in college will only be one summer, depressed…</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis-aof</title>
      <link href="2020/07/21/db/redis-aof/"/>
      <url>2020/07/21/db/redis-aof/</url>
      
        <content type="html"><![CDATA[<p>redis数据持久化 —— aof(append only file)</p><a id="more"></a><hr><p>aof记录的是命令，也是通过子进程完成的，恢复就是再执行一遍这些命令，所以aof文件会比rdb文件更大，效率也更低，但是数据的完整性会更高。</p><p>aof默认是不开启的，需要在redis.conf中手动更改appendonly为yes，更改配置文件后需要重启redis服务。</p><p>如果aof文件有损坏，redis是无法正常工作的，可以使用<code>redis-check-aof --fix appendonly.aof</code>进行修复，修复是暴力的，有可能会丢失一些数据。</p><p>aof由于会不断地变大，redis提供了重写机制，会对aof文件的命令进行压缩，至于无法再压缩了怎么办，这个回头找本书补一下。</p><p>有关aof的配置项列在下面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span></span><br><span class="line"><span class="comment"># good enough in many applications, but an issue with the Redis process or</span></span><br><span class="line"><span class="comment"># a power outage may result into a few minutes of writes lost (depending on</span></span><br><span class="line"><span class="comment"># the configured save points).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File is an alternative persistence mode that provides</span></span><br><span class="line"><span class="comment"># much better durability. For instance using the default data fsync policy</span></span><br><span class="line"><span class="comment"># (see later in the config file) Redis can lose just one second of writes in a</span></span><br><span class="line"><span class="comment"># dramatic event like a server power outage, or a single write if something</span></span><br><span class="line"><span class="comment"># wrong with the Redis process itself happens, but the operating system is</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class="line"><span class="comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span></span><br><span class="line"><span class="comment"># data on disk, some other OS will just try to do it ASAP.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis supports three different modes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span></span><br><span class="line"><span class="comment"># always: fsync after every write to the append only log. Slow, Safest.</span></span><br><span class="line"><span class="comment"># everysec: fsync only one time every second. Compromise.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When the AOF fsync policy is set to always or everysec, and a background</span></span><br><span class="line"><span class="comment"># saving process (a background save or AOF log background rewriting) is</span></span><br><span class="line"><span class="comment"># performing a lot of I/O against the disk, in some Linux configurations</span></span><br><span class="line"><span class="comment"># Redis may block too long on the fsync() call. Note that there is no fix for</span></span><br><span class="line"><span class="comment"># this currently, as even performing fsync in a different thread will block</span></span><br><span class="line"><span class="comment"># our synchronous write(2) call.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to mitigate this problem it&#x27;s possible to use the following option</span></span><br><span class="line"><span class="comment"># that will prevent fsync() from being called in the main process while a</span></span><br><span class="line"><span class="comment"># BGSAVE or BGREWRITEAOF is in progress.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This means that while another child is saving, the durability of Redis is</span></span><br><span class="line"><span class="comment"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span></span><br><span class="line"><span class="comment"># possible to lose up to 30 seconds of log in the worst scenario (with the</span></span><br><span class="line"><span class="comment"># default Linux settings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span></span><br><span class="line"><span class="comment"># &quot;no&quot; that is the safest pick from the point of view of durability.</span></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="comment"># Redis is able to automatically rewrite the log file implicitly calling</span></span><br><span class="line"><span class="comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class="line"><span class="comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span></span><br><span class="line"><span class="comment"># the AOF at startup is used).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This base size is compared to the current size. If the current size is</span></span><br><span class="line"><span class="comment"># bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span></span><br><span class="line"><span class="comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span></span><br><span class="line"><span class="comment"># is reached but it is still pretty small.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify a percentage of zero in order to disable the automatic AOF</span></span><br><span class="line"><span class="comment"># rewrite feature.</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># An AOF file may be found to be truncated at the end during the Redis</span></span><br><span class="line"><span class="comment"># startup process, when the AOF data gets loaded back into memory.</span></span><br><span class="line"><span class="comment"># This may happen when the system where Redis is running</span></span><br><span class="line"><span class="comment"># crashes, especially when an ext4 filesystem is mounted without the</span></span><br><span class="line"><span class="comment"># data=ordered option (however this can&#x27;t happen when Redis itself</span></span><br><span class="line"><span class="comment"># crashes or aborts but the operating system still works correctly).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis can either exit with an error when this happens, or load as much</span></span><br><span class="line"><span class="comment"># data as possible (the default now) and start if the AOF file is found</span></span><br><span class="line"><span class="comment"># to be truncated at the end. The following option controls this behavior.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span></span><br><span class="line"><span class="comment"># the Redis server starts emitting a log to inform the user of the event.</span></span><br><span class="line"><span class="comment"># Otherwise if the option is set to no, the server aborts with an error</span></span><br><span class="line"><span class="comment"># and refuses to start. When the option is set to no, the user requires</span></span><br><span class="line"><span class="comment"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span></span><br><span class="line"><span class="comment"># the server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that if the AOF file will be found to be corrupted in the middle</span></span><br><span class="line"><span class="comment"># the server will still exit with an error. This option only applies when</span></span><br><span class="line"><span class="comment"># Redis will try to read more data from the AOF file but not enough bytes</span></span><br><span class="line"><span class="comment"># will be found.</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span></span><br><span class="line"><span class="comment"># AOF file for faster rewrites and recoveries. When this option is turned</span></span><br><span class="line"><span class="comment"># on the rewritten AOF file is composed of two different stanzas:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   [RDB file][AOF tail]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span></span><br><span class="line"><span class="comment"># string and loads the prefixed RDB file, and continues loading the AOF</span></span><br><span class="line"><span class="comment"># tail.</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-rdb</title>
      <link href="2020/07/21/db/redis-rdb/"/>
      <url>2020/07/21/db/redis-rdb/</url>
      
        <content type="html"><![CDATA[<p>redis数据持久化 —— rdb(redis database)</p><a id="more"></a><hr><p>rdb是redis默认的数据持久化方式，在redis.conf文件中关于rdb的相关配置下最下面。</p><p>rdb的原理是fork一个子进程去做持久化，完成后新的rdb文件会覆盖旧的rdb文件，这样的缺点就在于持久化过程中的数据操作不会被保存。优点是适合大规模的数据持久化，效率要比aof高。</p><p>dump.rdb默认会生成在启动时的目录，所以建议配置文件里把dir改成绝对路径。</p><p>rdb持久化是将内存中数据集的快照写入文件，恢复直接加载回内存，rdb文件中是紧凑压缩的二进制文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Save the DB on disk:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment">#   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   It is also possible to remove all the previously configured save</span></span><br><span class="line"><span class="comment">#   points by adding a save directive with a single empty string argument</span></span><br><span class="line"><span class="comment">#   like in the following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span></span><br><span class="line"><span class="comment"># (at least one save point) and the latest background save failed.</span></span><br><span class="line"><span class="comment"># This will make the user aware (in a hard way) that data is not persisting</span></span><br><span class="line"><span class="comment"># on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class="line"><span class="comment"># disaster will happen.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the background saving process will start working again Redis will</span></span><br><span class="line"><span class="comment"># automatically allow writes again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However if you have setup your proper monitoring of the Redis server</span></span><br><span class="line"><span class="comment"># and persistence, you may want to disable this feature so that Redis will</span></span><br><span class="line"><span class="comment"># continue to work as usual even if there are problems with disk,</span></span><br><span class="line"><span class="comment"># permissions, and so forth.</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compress string objects using LZF when dump .rdb databases?</span></span><br><span class="line"><span class="comment"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span></span><br><span class="line"><span class="comment"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span></span><br><span class="line"><span class="comment"># the dataset will likely be bigger if you have compressible values or keys.</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class="line"><span class="comment"># This makes the format more resistant to corruption but there is a performance</span></span><br><span class="line"><span class="comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span></span><br><span class="line"><span class="comment"># for maximum performances.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class="line"><span class="comment"># tell the loading code to skip the check.</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># The filename where to dump the DB</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># The working directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="line"><span class="comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis乐观锁</title>
      <link href="2020/07/21/db/redis%E4%B9%90%E8%A7%82%E9%94%81/"/>
      <url>2020/07/21/db/redis%E4%B9%90%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>通过redis的watch机制实现乐观锁。</p><a id="more"></a><p><strong>先说一下悲观锁和乐观锁</strong></p><p>悲观锁: 认为数据永远都会被修改的一种上锁方式。</p><p>乐观锁: 认为数据永远不会被修改的一种上锁方式，但更新数据时会检查数据是否被篡改。</p><hr><p>redis中可以使用watch开启监控，使用unwatch取消监控，实现乐观锁需要配合事务一起使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; watch k  <span class="comment"># 1</span></span><br><span class="line">&gt; multi</span><br><span class="line">&gt; <span class="built_in">set</span> k v1 <span class="comment"># 2</span></span><br><span class="line">&gt; <span class="built_in">exec</span>     <span class="comment"># 如果1处k和2处k(修改前)的值不同，事务执行失败</span></span><br><span class="line">&gt; (nil)</span><br></pre></td></tr></table></figure><p>对于set、get、incr、decr等操作，都需要保证k值未被其他线程(终端)修改，若是事务执行失败了，只能重新监控，重新开始。</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyqt记录</title>
      <link href="2020/07/21/art/pyqt%E8%AE%B0%E5%BD%95/"/>
      <url>2020/07/21/art/pyqt%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>一起搞py之qt小技巧。</p><a id="more"></a><p>个人是不喜欢搞美工的，但没办法，要恰饭的嘛。这里把搬砖学到的一些pyqt技巧记录一下。</p><hr><ol><li><p>designer设计的ui文件通过<code>self.ui = loadUi(&#39;client.ui&#39;)</code>进行导入，需要头文件<code>from PyQt5.uic import *</code></p></li><li><p>选择文件用这个<code>path, _ = QFileDialog.getOpenFileName(None, &quot;选择文件&quot;, &#39;/&#39;, &quot;(*.txt)&quot;)</code></p></li><li><p>选择文件夹用这个<code>path = QFileDialog.getExistingDirectory(None, &quot;选择路径&quot;)</code></p></li><li><p>新增的窗口要和主窗口初始化在一起，在需要的地方调用show方法。</p></li><li><p>menu的响应用<code>menu.triggered.connect(f)</code>，f形如<code>def f(e)</code>，通过<code>e.text()</code>判断选择了menu的哪个项。</p></li><li><p>右键菜单使用<code>self.setContextMenuPolicy(Qt.DefaultContextMenu)</code>开启，需要重写<code>def contextMenuEvent(self, e)</code>函数，函数内部通过<code>menu = QMenu()</code>创建右键菜单，使用<code>opt = menu.addAction(&quot;选项1&quot;)</code>添加菜单项，通过<code>menu.exec_(QCursor.pos())</code>的返回值判断选择了哪个菜单项。</p></li><li><p>窗口标题：<code>self.setWindowTitle(&#39;title&#39;)</code></p></li><li><p>窗口大小：<code>self.resize(200, 100)</code></p></li><li><p>关闭Dialog：<code>self.close()</code></p></li><li><p>布局：水平是<code>QHBoxLayout()</code>，垂直是<code>QVBoxLayout()</code>，向布局添加组件是<code>addWidget()</code>，向布局添加布局是<code>addLayout()</code>，最后调用<code>self.setLayout()</code>，传入整体布局才可以显示。布局贼好用，完成界面是响应式的。</p></li><li><p>seaborn heatmap需要的几个头文件：<code>import matplotlib; matplotlib.use(&#39;Qt5Agg&#39;)</code>，<code>import matplotlib.pyplot as plt</code>，<code>import seaborn as sns; sns.set()</code></p></li><li><p>heatmap的使用:</p><p>网上有demo，这个是我搬砖用到的模式</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.figure = plt.figure(figsize = (<span class="number">5</span>, <span class="number">5</span>)) <span class="comment"># 画布大小: 500 * 500</span></span><br><span class="line">    self.canvas = self.figure.canvas</span><br><span class="line">    self.figure.subplots_adjust(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment"># 左下角是0,0 右上角是1,1 这里是百分数，也就是画布铺满</span></span><br><span class="line">    self.canvas.mpl_connect(<span class="string">&#x27;motion_notify_event&#x27;</span>, self.move) <span class="comment"># 监视画布鼠标移动</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, e</span>):</span></span><br><span class="line">    print(e.x, e.y) <span class="comment"># 鼠标的坐标</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span> <span class="comment"># 自定义的画图函数</span></span><br><span class="line">    plt.cla() <span class="comment"># 清空坐标轴</span></span><br><span class="line">    data = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]] <span class="comment"># 随便写一组数据</span></span><br><span class="line">    <span class="comment"># cmap是热点颜色，cbar是否显示颜色标尺，aplha透明度</span></span><br><span class="line">    ax = sns.heatmap(data, cmap = <span class="string">&quot;Reds&quot;</span>, cbar = <span class="literal">False</span>, alpha = <span class="number">0.7</span>)</span><br><span class="line">    ax.invert_yaxis() <span class="comment"># 竖轴反转，让0，0在左下角</span></span><br><span class="line">    bgimg = img.imread(<span class="string">&#x27;bg.png&#x27;</span>) <span class="comment"># 添加背景图片，这里需要引入import matplotlib.image as img</span></span><br><span class="line">    ax.imshow(bgimg, aspect = ax.get_aspect(), extent = ax.get_xlim() + ax.get_ylim())</span><br><span class="line">    self.canvas.draw() <span class="comment"># 画图函数</span></span><br></pre></td></tr></table></figure><ol start="13"><li><p>qt程序的打包: <code>pyinstaller a.py b.py --noconsole --hidden-import PyQt5.QtXml --clean --win-private-assemblies -F</code>不知道为什么这么写，但是能用就行。</p></li><li><p>自定义matplotlib colormap，从透明开始</p><p>数值会被映射到[0, 1]上，三元组的第一个值是x对应的就是数值，第二三个值是y，所以第二个第三个数是一样的，对于’red’:[(0,0,0),(0.5,1,1),(1,1,1)]来说就是x在[0,0.5]即下半段数值上，rgb色中的r值从0到1渐变，而x在[0.5,1]即上半段数值上，r值始终为1。结合green和blue，在x处于不同位置，有不同的rbg值即有不同的颜色，alpha是可选的，下面的例子就是黄色(255,255,0)到红色(255,0,0)的渐变，透明度从0到1。</p><p>对于不连续的情况，x在i和i+1范围内，颜色变化为y1[i] ~ y0[i+1]</p><p>需要注意的是，如果在cdict中设置了alpha项，需要在绘图时将函数参数alpha项置为None（不设置参数，默认为1），这样才会使用自定义的透明度。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> colors</span><br><span class="line"></span><br><span class="line">cdict = &#123;</span><br><span class="line">    <span class="string">&#x27;red&#x27;</span>  : [</span><br><span class="line">        (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;green&#x27;</span>: [</span><br><span class="line">        (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;blue&#x27;</span> : [</span><br><span class="line">        (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;alpha&#x27;</span>: [</span><br><span class="line">        (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line">CMAP = colors.LinearSegmentedColormap(<span class="string">&#x27;CMAP&#x27;</span>, cdict)</span><br><span class="line">plt.register_cmap(cmap = CMAP)</span><br></pre></td></tr></table></figure><ol start="15"><li>qt + matplotlib 动态折线图</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_qt5agg <span class="keyword">import</span> FigureCanvasQTAgg <span class="keyword">as</span> FigureCanvas</span><br><span class="line"><span class="keyword">from</span> matplotlib.figure <span class="keyword">import</span> Figure</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QTimer</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> interpolate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        canvas = Canvas(self)</span><br><span class="line"></span><br><span class="line">        self.show()</span><br><span class="line">        canvas.plot()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Canvas</span>(<span class="params">FigureCanvas</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        figure = Figure()</span><br><span class="line">        self.axes = figure.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">        FigureCanvas.__init__(self, figure)</span><br><span class="line">        self.setParent(parent)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot</span>(<span class="params">self</span>):</span></span><br><span class="line">        timer = QTimer(self)</span><br><span class="line">        timer.timeout.connect(self.update_figure)</span><br><span class="line">        timer.start(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_figure</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.axes.cla()</span><br><span class="line">        self.axes.plot(np.random.randint(<span class="number">10</span>,size=<span class="number">10</span>), np.random.randint(<span class="number">10</span>,size=<span class="number">10</span>))</span><br><span class="line">        self.draw()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    ex = App()</span><br><span class="line">    app.exec_()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> art </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis事务</title>
      <link href="2020/07/20/db/redis%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/07/20/db/redis%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>redis单条命令是原子的，但是事务不保证原子性。</p><a id="more"></a><hr><p>事务即一组命令的集合，顺序执行。</p><p>redis事务具有一次性、顺序性、排他性，没有隔离级别的概念，即没有幻读、脏读、不可重复读等问题。</p><p>所有命令在事务中，并没有被直接执行，只有发起执行命令才会执行。</p><p>开启事务: multi</p><p>中途取消: discard</p><p>执行事务: exec</p><p>如果有一个命令语法错误，那么整个事务执行失败，如果一个命令逻辑错误，事务其余命令会正常执行。</p><p>PS: 自己开了两个终端试了一下，就是看谁先exec，结果就是谁设置的值。</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-bitmaps</title>
      <link href="2020/07/20/db/redis-bitmaps/"/>
      <url>2020/07/20/db/redis-bitmaps/</url>
      
        <content type="html"><![CDATA[<p>三大特殊数据类型 —— bitmaps</p><a id="more"></a><hr><p>bitmaps用作位存储，可以用于登录状态，活跃状态，打卡状态等只有0，1两种状态的统计</p><p>存储: setbit key offset value</p><p>取值: getbit key offset</p><p>统计: bitcount key [start end]</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-hyperloglog</title>
      <link href="2020/07/20/db/redis-hyperloglog/"/>
      <url>2020/07/20/db/redis-hyperloglog/</url>
      
        <content type="html"><![CDATA[<p>三大特殊数据类型 —— hyperloglog</p><a id="more"></a><hr><p>hyperloglog用于统计基数，列表L的基数 = set(L).size()</p><p>用集合统计page views浪费空间，因为不需要保存ip地址，hyperloglog数据量大时会有误差，但是内存空间固定，2^64数据量只需要12KB内存</p><p>添加: pfadd key element [element …]</p><p>统计: pfcount key [key …]</p><p>合并: pfmerge destkey sourcekey [sourcekey …]</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-geospatial</title>
      <link href="2020/07/20/db/redis-geospatial/"/>
      <url>2020/07/20/db/redis-geospatial/</url>
      
        <content type="html"><![CDATA[<p>三大特殊数据类型 —— geospatial</p><a id="more"></a><hr><p>geospatial存储地理位置，使用zset实现，可以使用zset命令，例如使用zrem删除元素</p><p>可以用作附近的人，定位，距离计算，推算地理位置信息等与地图有关的功能</p><p>添加位置（两极除外）: geoadd key longitude latitude member [longitude latitude member …]</p><p>查找位置: geopos key member [member …]</p><p>获取距离: geodist key member1 member2 [unit]</p><p>查找给定经纬度某一半径内元素: georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</p><p>查找给定元素某一半径内元素: georadiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</p><p>返回元素geohash表示: geohash key member [member …]</p><p>geohash不精确，某个矩形区域的点都可以用同一个geohash表示，geohash越相似，位置越相近</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-zset</title>
      <link href="2020/07/17/db/redis-zset/"/>
      <url>2020/07/17/db/redis-zset/</url>
      
        <content type="html"><![CDATA[<p>五大基本数据类型 —— zset</p><a id="more"></a><hr><p>zset是有序集合，可以用作带权排序，例如排行榜的实现等</p><p>添加: zadd key [NX|XX] [CH] [INCR] score member [score member …]</p><p>截取: zrange key start stop [WITHSCORES]</p><p>排序: zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</p><p>移除: zrem key member [member …]</p><p>长度: zcard key</p><p>逆序: zrevrange key start stop [WITHSCORES]</p><p>统计: zcount key min max</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-hash</title>
      <link href="2020/07/17/db/redis-hash/"/>
      <url>2020/07/17/db/redis-hash/</url>
      
        <content type="html"><![CDATA[<p>五大基本数据类型 —— hash</p><a id="more"></a><hr><p>hash类型形如key-(key-value)，用于存储经常变更的数据，类似用户信息等</p><p>hash更适合对象的存储，string更适合字符串存储</p><p>添加: hset key field value</p><p>获取: hget key field</p><p>批量添加: hmset key field value [field value …]</p><p>批量获取: hmget key field [field …]</p><p>获取全部: hgetall key</p><p>删除: hdel key field [field …]</p><p>长度: hlen key</p><p>存在: hexists key field</p><p>所有字段: hkeys key</p><p>所有值: hvals key</p><p>增加/减少: hincrby key field increment</p><p>新增: hsetnx key field value</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-set</title>
      <link href="2020/07/17/db/redis-set/"/>
      <url>2020/07/17/db/redis-set/</url>
      
        <content type="html"><![CDATA[<p>五大基本数据类型 —— set</p><a id="more"></a><hr><p>常用于共同关注，共同爱好，可能认识的人等场景</p><p>添加: sadd key member [member …]</p><p>查看: smembers key</p><p>存在: sismember key member</p><p>长度: scard key</p><p>移除: srem key member [member …]</p><p>随机获取: srandmember key [count]</p><p>随机删除: spop key [count]</p><p>移动: smove source destination member</p><p>差集: sdiff key [key …]</p><p>交集: sinter key [key …]</p><p>并集: sunion key [key …]</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-list</title>
      <link href="2020/07/17/db/redis-list/"/>
      <url>2020/07/17/db/redis-list/</url>
      
        <content type="html"><![CDATA[<p>五大基本数据类型 —— list</p><a id="more"></a><hr><p>常被用作消息队列、栈</p><p>左插: lpush key value [value …]</p><p>右插: rpush key value [value …]</p><p>截取: lrange key start stop</p><p>左删: lpop key</p><p>右删: rpop key</p><p>取值: lindex key index</p><p>长度: llen key</p><p>移除: lrem key count value</p><p>保留: ltrim key start stop</p><p>修改: lset key index value</p><p>插入: linsert key before|after pivot value</p><p>移动: rpoplpush source destination</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-string</title>
      <link href="2020/07/17/db/redis-string/"/>
      <url>2020/07/17/db/redis-string/</url>
      
        <content type="html"><![CDATA[<p>五大基本数据类型 —— string</p><a id="more"></a><hr><p>常用于计数器、对象缓存存储等</p><p>追加/新建: append key value</p><p>长度: strlen key</p><p>自增: incr key</p><p>自减: decr key</p><p>自定义步长: incrby key increment</p><p>截取: getrange key start end</p><p>替换: setrange key offset value</p><p>覆盖或新建且设置时效: setex key seconds value</p><p>只新建不覆盖: setnx key value</p><p>批量新建: mset key value [kay value …]</p><p>批量获取: mget key [key …]</p><p>批量不覆盖新建（原子操作）: msetnx key value [kay value …]</p><p>获取后覆盖/新建: getset key value</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="2020/07/17/db/redis%E5%9F%BA%E7%A1%80/"/>
      <url>2020/07/17/db/redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>redis在6.0版本之前使用单线程处理所有请求。</p><a id="more"></a><p><strong>0. redis的应用场景</strong></p><blockquote><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p></blockquote><p>上段引用自<a href="http://redis.cn/">redis官网</a>，redis不只是数据库，也可以作缓存和消息中间件。</p><p><strong>1. redis默认有16个数据库</strong></p><p>可以在redis.conf中查看databases项为16，默认使用0号数据库。</p><p><strong>2. 默认端口号6379的来历</strong></p><p>6379是一个女明星MERZ的九宫格数字。</p><p><strong>3. 使用单线程处理请求的原因</strong></p><p>多线程主要是为了避免cpu等待io操作，redis的数据都在内存中，出于对线程切换的考虑，我们允许内存io带来的cpu资源浪费，因此单线程的效率会更高。</p><p>官方解释是，redis基于内存操作，性能瓶颈不是cpu，而是内存和网络带宽，所以就用单线程了。</p><p><strong>4. <a href="http://redis.cn/commands.html">一些命令</a></strong></p><ul><li>select db切换数据库</li><li>dbsize查看当前数据库大小</li><li>flushdb清空当前数据库</li><li>flushall清空所有数据库</li><li>keys *查看所有key</li><li>exists key判断key是否存在</li><li>move key db移动key到其他数据库</li><li>expire key seconds设置key失效时间</li><li>ttl key查看key有效时间</li><li>del key删除key</li><li>type key查看key的类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis压测</title>
      <link href="2020/07/17/db/redis%E5%8E%8B%E6%B5%8B/"/>
      <url>2020/07/17/db/redis%E5%8E%8B%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>使用redis自带的benchmark进行压力测试。</p><a id="more"></a><h1 id="参数表"><a href="#参数表" class="headerlink" title="参数表"></a><a href="https://www.runoob.com/redis/redis-benchmarks.html">参数表</a></h1><table><thead><tr><th align="center">选项</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">-h</td><td align="center">指定服务器主机名</td><td align="center">127.0.0.1</td></tr><tr><td align="center">-p</td><td align="center">指定服务器端口</td><td align="center">6379</td></tr><tr><td align="center">-c</td><td align="center">指定并发连接数</td><td align="center">50</td></tr><tr><td align="center">-n</td><td align="center">指定请求数</td><td align="center">10000</td></tr></tbody></table><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>100k写入(set)请求测试，100并行客户端，每次写入3个字节，1台服务器处理请求，单机性能。25%的请求在1ms内处理完成，98%的请求在2ms内处理完成，100%的请求在4ms内处理完成，100k请求总计用时1.76秒，每秒处理56785次请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -c 100 -n 100000</span><br><span class="line"></span><br><span class="line">====== SET ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.76 seconds</span><br><span class="line">  100 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">25.00% &lt;= 1 milliseconds</span><br><span class="line">98.76% &lt;= 2 milliseconds</span><br><span class="line">99.61% &lt;= 3 milliseconds</span><br><span class="line">99.89% &lt;= 4 milliseconds</span><br><span class="line">100.00% &lt;= 4 milliseconds</span><br><span class="line">56785.91 requests per second</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis安装</title>
      <link href="2020/07/17/db/redis%E5%AE%89%E8%A3%85/"/>
      <url>2020/07/17/db/redis%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>linux中redis的源码安装。</p><a id="more"></a><p><a href="http://redis.cn/">redis.cn</a>下载，解压，使用make &amp; make install，会在/usr/local/bin中添加可执行文件，拷贝一份redis.conf，修改daemonize为yes，使其后台运行，使用redis-server redis.conf启动服务，使用redis-cli启动客户端。安装redis时需要注意gcc版本是否支持redis版本。</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> environ </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nosql简介</title>
      <link href="2020/07/17/db/nosql%E7%AE%80%E4%BB%8B/"/>
      <url>2020/07/17/db/nosql%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>为什么是nosql? nosql的分类？</p><a id="more"></a><h1 id="为什么用nosql？"><a href="#为什么用nosql？" class="headerlink" title="为什么用nosql？"></a>为什么用nosql？</h1><p>社交网络、地理位置、日志数据…等等数据类型逐渐复杂，关系型数据库（rdbms）已经无法满足对这些类型数据的存储。</p><p>nosql(not only sql)，泛指非关系型数据库。数据之间没有关系，耦合度低，方便扩展；高性能，细粒度，秒写8万次，秒读11万次；不需要像关系型数据库一样需要事先设计表结构（后续数据量大后，修改表结构是非常头疼的事情）。</p><h1 id="rdbms-vs-nosql"><a href="#rdbms-vs-nosql" class="headerlink" title="rdbms vs nosql"></a>rdbms vs nosql</h1><p>rdbms: 结构化、有专用查询语言、表存储、严格的一致性、基本的事务</p><p>nosql: 不仅仅是数据、四种分类、最终一致性、cap和base理论、3v和3高（海量(volume)、多样(variety)、实时(velocity)、高并发、高可拓、高性能）</p><h1 id="nosql四种分类"><a href="#nosql四种分类" class="headerlink" title="nosql四种分类"></a>nosql四种分类</h1><table><thead><tr><th align="center">分类</th><th align="center">代表</th><th align="center">典型应用场景</th><th align="center">数据模型</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">键值型</td><td align="center">redis</td><td align="center">内容缓存、日志系统</td><td align="center">通常是hash table实现</td><td align="center">查找速度快</td><td align="center">非结构化，通常只能当作字符串或二进制数据</td></tr><tr><td align="center">列存储型</td><td align="center">hbase</td><td align="center">分布式文件系统</td><td align="center">列簇式存储，将同一列数据存在一起</td><td align="center">查找速度快，可拓性强，更容易进行分布式拓展</td><td align="center">功能相对局限</td></tr><tr><td align="center">文档型</td><td align="center">mongodb</td><td align="center">web应用</td><td align="center">结构化数据</td><td align="center">数据结构要求不严格，表结构可变，不需要预定义表结构</td><td align="center">查询性能不高，缺乏统一的查询语法</td></tr><tr><td align="center">图型</td><td align="center">neo4j</td><td align="center">社交网络、推荐系统</td><td align="center">图结构</td><td align="center">可利用图论相关算法</td><td align="center">经常需要对整个图做计算才能得到需要的信息，且图结构不利于做分布式集群方案</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>intern day fifteen</title>
      <link href="2020/07/15/record/intern-day-fifteen/"/>
      <url>2020/07/15/record/intern-day-fifteen/</url>
      
        <content type="html"><![CDATA[<p>Mentor handed me a new task!</p><a id="more"></a><p>Because the last task originally scheduled for five weeks has been basically completed, the mentor has arranged a new task for me. This time, instead of optimizing the existing project, it is a brand new thing. I will start it from scratch. It seems more interesting than the last task. This task seems to involve massive data processing, which has certain performance requirements. I don’t know if I can do it well.</p><p>One of the more serious problems recently is that I am getting lazy and I want to lie down when I return to the hotel… I was originally doing five leetcode a day, and it’s so uncomfortable to use python, I cried…</p><p>The last thing to say is that the company’s xjj is really haokan.</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>intern day seven</title>
      <link href="2020/07/07/record/intern-day-seven/"/>
      <url>2020/07/07/record/intern-day-seven/</url>
      
        <content type="html"><![CDATA[<p>The South is not particularly hot!</p><a id="more"></a><p>Today is the seventh day of the internship. Although last weekend was not a working day, For a free meal, I still spend the weekend at the company. I was shocked that NetEase was not a 996 working system. I thought there would be lots of people although it is Saturday, but when I came to company, the office area was dark 2333, and there was no mandatory overtime after work. As long as the work was done, you can leave. Maybe formal employees will be busier.</p><p>Yesterday the mentor gave the task that added a module to a tool currently used in the studio. I started to do it today and found that it is not particularly difficult. The time given by the mentor is five weeks. I feel that I can finish it in three days. 2333.</p><p>There is also a phenomenon. There are not many people in the cafeteria when eating at noon every day, but at night I have to wait in front of the cafeteria a few minutes before the cafeteria opens. When the time comes, everyone runs at a speed that I have never seen in high school or college, 2333. I don’t know why it’s so different at noon and night.</p><p>Continue coding tomorrow, and strive to run the whole process before the mentor censor at night. = =</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>intern day three</title>
      <link href="2020/07/03/record/intern-day-three/"/>
      <url>2020/07/03/record/intern-day-three/</url>
      
        <content type="html"><![CDATA[<p>Internship is a bit boring!</p><a id="more"></a><p>In fact, when I was looking for an internship, I thought that if I received an offer, I would be very happy. I must find a friend to go out for a drink. However, when I received the offer on June 3, I was actually quite calm. After I came to NetEase, I actually felt that a bit lonely, today is another day to read the code, successfully completed the mentor’s request yesterday, I feel a little dull.</p><p>In addition to doing well the requirements given by the mentor one day, and then taking a look at some courses on NetEase’s internal platform, NetEase’s newcomer training should be quite good in many companies. The mentor said that he will hold a meeting with me on Monday and formally assigned me an internship task. It is estimated that next week will not be as leisurely as it is now.</p><p>The position of the classmate sitting next to me is game planning. It seems that most of his daily work is playing various games. 2333, I envy this kind of work!</p><p>What’s more, I know today that the most used language for game development is not C++. Most of the modules are actually written in scripting languages. I used to think that the game field is the world of C++. It really subverted my cognition!</p><p>Prepare to come to the company on Saturday and Sunday, after all, three meals a day can save a lot of money, not only air-conditioning but also fast internet.</p><p>Autumn recruitment have started one after another, and seeing the interns around me also prepare for autumn recruitment at the same time as the internship. The times are really different. This is no longer the time that can write bubble sort and you can join Huawei. Not to mention that IT is still a hot industry. Finding a job is also getting harder and harder every year. I hope that my senior year will be in the company I want to go to, so continue to work hard!</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>intern day two</title>
      <link href="2020/07/02/record/intern-day-two/"/>
      <url>2020/07/02/record/intern-day-two/</url>
      
        <content type="html"><![CDATA[<p>On the second day of the internship, the code has been known one after another!</p><a id="more"></a><p>Today, I sorted out the function calling process of the entire code, starting from the entrance of the program, step by step to find the backbone of the program, and gave it to the mentor. The mentor also said that I was basically correct in combing. The first time I read the source code, I just started I don’t know where to start, but I’ve got a little experience gradually.</p><p>I perfected my site during the lunch break. I like this topic very much. I decided to use English for every article in the future. Although I wrote it in Chinese and translated it with Google, I can also learn some English expression, mainly because there is no time to learn English during the holidays, just like this way to make up a little bit, after all, there is CET-6 next semester.</p><p>Before coming to the internship, I thought that I could write leetcode at noon and evening. However, I really found it a bit difficult when I arrived at the company. I came out of the company at 9 o’clock last night. There are some matters in the middle. In addition to the time on the road, I returned at 11 o’clock. Suddenly found that it is useless to bring the computer over! I still have to write the leetcode at noon, and I cannot give up the algorithm because of the internship.</p><p>Continue reading the code in the afternoon, trying to understand the logic of the code, feeling that I have already started, the only bad thing is that there are few comments on the code, and some are comments from previous versions, which can no longer be used as a reference, causing a lot of misleading, The root directory structure of the project also feels confusing. Should this project be originally written by an intern?</p><p>There are still things tonight, 233, just lazy to leave work at seven o’clock. Before coming to internship, I felt that 996 was actually nothing. As a result, I started to feel tired and sleepy the next day…but NetEase’s cafeteria is really good!</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>intern day one</title>
      <link href="2020/07/01/record/intern-day-one/"/>
      <url>2020/07/01/record/intern-day-one/</url>
      
        <content type="html"><![CDATA[<p>Today is the first day of internship!</p><a id="more"></a><p>I slept on the first day of work, and even the tired roommates were late on the first day of work… The company’s entry gift was given to the notebook, cup, and piggy pillow for sleeping. It’s super practical, otherwise don’t have a cup I don’t know what to drink during the day.</p><p>The task given by the mentor is a bit difficult. After reading the code for a whole afternoon, I can sort out some ideas. I hope I can understand the code tomorrow!</p><p>NetEase’s canteen is free, but the first time I happened to choose a window that requires payment, fortunately, it was only ten yuan, and I didn’t go to the more expensive side… Alas, I feel bad about my ten yuan.</p><p>In the evening, I went out for dinner with my mentor and two other groups of mentors and interns. The first time I ate crayfish, I wouldn’t eat it at all. 2333, Hangzhou’s consumption is quite high. Although the mentor treats guests, this meal It also cost nearly a thousand yuan.</p><p>In the evening, I came back to the company and asked the mentor that after 6:30, I wanted to be able to leave at any time after get off work, but there are still many people in the office area. Let me finish writing today’s summary before leaving!</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>感慨</title>
      <link href="2020/06/23/record/%E6%84%9F%E6%85%A8/"/>
      <url>2020/06/23/record/%E6%84%9F%E6%85%A8/</url>
      
        <content type="html"><![CDATA[<p>要么说人还是要好好学习呀！</p><a id="more"></a><p>加了入职群，一打眼昵称备注了学校的基本全是985，再不也是211CS强校，哭了/(ㄒoㄒ)/~~</p><p>默默的把自己的昵称改成了只有名字= =，如果不是想早点挣钱，说啥也得考个985的研究生读读…</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编笔记</title>
      <link href="2020/06/11/other/%E6%B1%87%E7%BC%96/"/>
      <url>2020/06/11/other/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-汇编语言基础"><a href="#1-汇编语言基础" class="headerlink" title="1 汇编语言基础"></a>1 汇编语言基础</h1><h2 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h2><h3 id="32位通用寄存器-8"><a href="#32位通用寄存器-8" class="headerlink" title="32位通用寄存器*8"></a>32位通用寄存器*8</h3><ul><li>EAX 累加器，用于算术、逻辑运算</li><li>EBX 基址寄存器，用于存放存储器地址，以方便指向变量或数组中的元素</li><li>ECX 计数器，用于循环操作等指令中的计数器</li><li>EDX 数据寄存器，用于存放数据</li><li>ESI 源变址寄存器，用于指向字符串或数组的源操作数</li><li>EDI 目的变址寄存器，用于指向字符串或数组中的目的操作数</li><li>EBP 基址指针寄存器，默认指向堆栈区域数据，主要用于在子程序中访问通过堆栈传递的参数和局部变量</li><li>ESP 堆栈指针寄存器，专用于指向堆栈区域顶部数据，在涉及堆栈操作的指令中会自动增加或减少<h3 id="16位段寄存器-6"><a href="#16位段寄存器-6" class="headerlink" title="16位段寄存器*6"></a>16位段寄存器*6</h3></li><li>CS 代码段寄存器</li><li>SS 堆栈段寄存器</li><li>DS 数据段寄存器</li><li>ES 附加段寄存器，也是用于存放数据的数据段</li><li>FS 数据段性质寄存器</li><li>GS 数据段性质寄存器<h3 id="32位标志寄存器-1（8086）"><a href="#32位标志寄存器-1（8086）" class="headerlink" title="32位标志寄存器*1（8086）"></a>32位标志寄存器*1（8086）</h3>除了标志位目的操作数的标志传送指令外，其他传送指令并不影响标志</li><li>状态标志<ul><li>CF 进位标志：当无符号整数加减运算结果的最高有效位有进位或借位时，将CF置1</li><li>PF 奇偶标志：反应运算结果最低字节中1的个数是奇是偶，偶数则置PF为1</li><li>AF 调整标志：反应加减运算时最低半字节有无进位或借位，有则置AF为1，该标志位由CPU使用，用户不必关心</li><li>ZF 零标志：反映运算结果是否为0，为0置ZF为1</li><li>SF 符号标志：反应运算结果正负，最高位为1即负数则置SF为1</li><li>OF 溢出标志：当有符号整数加减运算的结果超出范围，将OF置1，有符号数加减运算只有没有溢出时结果才是正确的。当两个相同符号数相加，而运算结果与原数据相反才会溢出，其他情况不会溢出</li></ul></li><li>控制标志<ul><li>DF 方向标志，仅用于串操作指令中，控制地址的变化方向</li></ul></li><li>系统标志<ul><li>TF 陷阱标志，用于控制处理器是否进入单步操作方式</li><li>IF 中断允许标志，用于控制外部可屏蔽中断是否可以被处理器响应<h3 id="32位指令指针寄存器-1"><a href="#32位指令指针寄存器-1" class="headerlink" title="32位指令指针寄存器*1"></a>32位指令指针寄存器*1</h3></li></ul></li><li>EIP 保存存储器地址，即将要执行的指令在主存中的位置，具有自动增量的能力，不能像通用寄存器一样直接修改</li></ul><h2 id="1-2-输入输出子程序库"><a href="#1-2-输入输出子程序库" class="headerlink" title="1.2 输入输出子程序库"></a>1.2 输入输出子程序库</h2><ul><li>DISPCRLF printf(“\n”)</li><li>DISPRD 显示8个通用寄存器内容</li><li>DISPRF 显示6个状态标志状态</li><li>DISPHD printf(“%x”, eax) 16进制显示</li><li>DISPUID printf(“%u”, eax) 无符号10进制</li><li>DISPSID printf(“%d”, eax) 有符号10进制</li><li>READMSG scanf(“%s”, eax) EAX存地址，调用后地址存放字串，EAX存长度不含0</li><li>READC scanf(“%c”, al) 调用后AL存字符ASCII码</li><li>READHD scanf(“%x”, eax) 输入8位十六进制数据，存在EAX中</li><li>READUID scanf(“%u”, eax) 输入无符号十进制整数，存在EAX中</li><li>READSID scanf(“%d”, eax) 输入有符号十进制整数，存在EAX中</li></ul><h1 id="2-通用数据处理指令"><a href="#2-通用数据处理指令" class="headerlink" title="2 通用数据处理指令"></a>2 通用数据处理指令</h1><h1 id="2-1-数据传送类指令"><a href="#2-1-数据传送类指令" class="headerlink" title="2.1 数据传送类指令"></a>2.1 数据传送类指令</h1><h3 id="2-1-1-传送指令-MOV"><a href="#2-1-1-传送指令-MOV" class="headerlink" title="2.1.1 传送指令 MOV"></a>2.1.1 传送指令 MOV</h3><ul><li>mov reg/mem, imm<ul><li>mov eax, 200</li><li>mov bvar, byte ptr 200</li><li>mov [ebx], word ptr 200</li></ul></li><li>mov reg/mem/seg, reg<ul><li>mov eax, ebx</li><li>mov bvar, al</li><li>mov [ebx], cx</li><li>mov ds, bx</li></ul></li><li>mov reg/seg, mem<ul><li>mov al, bvar</li><li>moc dx, [ebx]</li><li>mov edx, dvar[edi]</li><li>mov ds, wvar</li></ul></li><li>mov r16/m16, seg<ul><li>mov ax, ds</li><li>mov wvar, ds</li><li>mov [ebx], ss</li></ul></li></ul><h3 id="2-1-2-交换指令-XCHG"><a href="#2-1-2-交换指令-XCHG" class="headerlink" title="2.1.2 交换指令 XCHG"></a>2.1.2 交换指令 XCHG</h3><ul><li>XCHG reg, reg/mem</li><li>XCHG reg/mem, reg</li></ul><h3 id="2-1-3-堆栈操作指令"><a href="#2-1-3-堆栈操作指令" class="headerlink" title="2.1.3 堆栈操作指令"></a>2.1.3 堆栈操作指令</h3><p>栈底对应高地址，栈顶对应低地址</p><h4 id="进栈指令-PUSH"><a href="#进栈指令-PUSH" class="headerlink" title="进栈指令 PUSH"></a>进栈指令 PUSH</h4><ul><li>PUSH r16/m16/i16/seg</li><li>PUSH r32/m32/i32</li></ul><h4 id="出栈指令-POP"><a href="#出栈指令-POP" class="headerlink" title="出栈指令 POP"></a>出栈指令 POP</h4><ul><li>POP r16/m16/seg</li><li>POP r32/m32</li></ul><h3 id="2-1-4-EBP"><a href="#2-1-4-EBP" class="headerlink" title="2.1.4 EBP"></a>2.1.4 EBP</h3><p>既然堆栈是利用主存实现的，我们当然就能以随机存取方式读写其中的数据，通用寄存器之一的堆栈基址指针EBP就是出于这个目的而设计的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ebp, esp</span><br><span class="line">mov eax, [ebp+8];EAX&#x3D;SS:[EBP+8] EBP默认与堆栈段配合</span><br><span class="line">mov [ebp], eax;SS:[EBP]&#x3D;EAX</span><br></pre></td></tr></table></figure><h3 id="2-1-5-其他传送指令"><a href="#2-1-5-其他传送指令" class="headerlink" title="2.1.5 其他传送指令"></a>2.1.5 其他传送指令</h3><h4 id="地址传送指令-LEA"><a href="#地址传送指令-LEA" class="headerlink" title="地址传送指令 LEA"></a>地址传送指令 LEA</h4><p>存储器操作数具有地址属性，利用地址传送指令可以获取其地址，其中最常用的是获取有效地址指令LEA，该指令在执行时计算偏移地址</p><ul><li>LEA r16/r32, mem</li><li>LEA eax, [ebx+ecx] ;利用LEA实现加法操作</li></ul><h4 id="换码指令-XLAT"><a href="#换码指令-XLAT" class="headerlink" title="换码指令 XLAT"></a>换码指令 XLAT</h4><p>使用XLAT指令前，需要将EBX指向数据表首地址，并给AL赋值数据项的偏移量，执行的功能是将数据表该位置的数据取出赋值给AL，可以表达为AL=[EBX+AL]，默认使用DS数据段</p><h4 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h4><ul><li>CLC：复位进位标志，CF=0</li><li>STC：置位进位标志，CF=1</li><li>CMC：取反进位标志</li><li>CLD：复位方向标志，DF=0，串操作后地址增大</li><li>STD：置位方向标志，DF=1，串操作后地址减小</li><li>CLI：复位中断标志，IF=0，禁止可屏蔽中断</li><li>STI：置位中断标志，IF=1，允许可屏蔽中断</li><li>LAHF：标志寄存器低字节内容传送到AH寄存器</li><li>SAHF：AH寄存器内容传送到标志寄存器低字节</li><li>PUSHF：标志寄存器低16位压入堆栈</li><li>POPF：堆栈顶部一个字量数据弹出到标志寄存器低16位</li><li>PUSHFD：32位标志寄存器全部内容压入堆栈</li><li>POPFD：当前堆栈顶部一个双字数据弹出到标志寄存器</li></ul><h2 id="2-2-算数运算类指令"><a href="#2-2-算数运算类指令" class="headerlink" title="2.2 算数运算类指令"></a>2.2 算数运算类指令</h2><h3 id="2-2-1-加法指令"><a href="#2-2-1-加法指令" class="headerlink" title="2.2.1 加法指令"></a>2.2.1 加法指令</h3><h4 id="加法指令-ADD"><a href="#加法指令-ADD" class="headerlink" title="加法指令 ADD"></a>加法指令 ADD</h4><ul><li>ADD reg, imm/reg/mem</li><li>ADD mem, imm/reg</li></ul><h4 id="带进位加法指令-ADC"><a href="#带进位加法指令-ADC" class="headerlink" title="带进位加法指令 ADC"></a>带进位加法指令 ADC</h4><p>ADC除了完成ADD加法运算外，还要加上进位CF</p><ul><li>ADC reg, imm/reg/mem</li><li>ADC mem, imm/reg</li></ul><h4 id="增量指令-INC"><a href="#增量指令-INC" class="headerlink" title="增量指令 INC"></a>增量指令 INC</h4><p>不影响CF，但影响其他状态标志位</p><ul><li>INC reg/mem</li></ul><h3 id="2-2-2-减法指令"><a href="#2-2-2-减法指令" class="headerlink" title="2.2.2 减法指令"></a>2.2.2 减法指令</h3><h4 id="减法指令-SUB"><a href="#减法指令-SUB" class="headerlink" title="减法指令 SUB"></a>减法指令 SUB</h4><ul><li>SUB reg, imm/reg/mem</li><li>SUB mem, imm/reg</li></ul><h4 id="带借位减法指令-SBB"><a href="#带借位减法指令-SBB" class="headerlink" title="带借位减法指令 SBB"></a>带借位减法指令 SBB</h4><p>SBB除了完成SUB减法运算外，还要减去借位CF,64位减法先减低32位，再减高32位</p><ul><li>SBB reg, imm/reg/mem</li><li>SBB mem, imm/reg</li></ul><h4 id="减量指令-DEC"><a href="#减量指令-DEC" class="headerlink" title="减量指令 DEC"></a>减量指令 DEC</h4><p>不影响CF，但影响其他状态标志位</p><ul><li>DEC reg/mem</li></ul><h4 id="求补指令-NEG"><a href="#求补指令-NEG" class="headerlink" title="求补指令 NEG"></a>求补指令 NEG</h4><p>即用零减去操作数，结果返回操作数，与用0做减法的SUB指令一样，可用于对负数求补码或由负数补码求绝对值</p><ul><li>NEG reg/mem</li></ul><h4 id="比较指令-CMP"><a href="#比较指令-CMP" class="headerlink" title="比较指令 CMP"></a>比较指令 CMP</h4><p>使目的操作数减去源操作数，差值不回送到目的操作数，但按照减法结果影响状态标志</p><ul><li>CMP reg, imm/reg/mem</li><li>CMP mem, imm/reg</li></ul><h3 id="2-2-3-乘除法指令"><a href="#2-2-3-乘除法指令" class="headerlink" title="2.2.3 乘除法指令"></a>2.2.3 乘除法指令</h3><p>IA-32乘除法需要区别有无符号，并隐含使用EAX和EDX，有点复杂而且好像不咋用乘除法这里没写，页数76</p><h3 id="2-2-4-其他运算指令"><a href="#2-2-4-其他运算指令" class="headerlink" title="2.2.4 其他运算指令"></a>2.2.4 其他运算指令</h3><h4 id="零位扩展和符号扩展指令"><a href="#零位扩展和符号扩展指令" class="headerlink" title="零位扩展和符号扩展指令"></a>零位扩展和符号扩展指令</h4><p>位数增加，大小不变</p><ul><li>无符号数零位扩展 MOVZX 高位补0<ul><li>MOVZX r16, r8/m8</li><li>MOVZX r32, r8/m8/r16/m16</li></ul></li><li>有符号数符号扩展 MOVSX<ul><li>MOVSX r16, r8/m8</li><li>MOVSX r32, r8/m8/r16/m16</li></ul></li></ul><h4 id="10进制调整指令"><a href="#10进制调整指令" class="headerlink" title="10进制调整指令"></a>10进制调整指令</h4><p>貌似不重要，连个例子都没有，页数79</p><h2 id="2-3-位操作类指令"><a href="#2-3-位操作类指令" class="headerlink" title="2.3 位操作类指令"></a>2.3 位操作类指令</h2><h3 id="2-3-1-逻辑运算指令"><a href="#2-3-1-逻辑运算指令" class="headerlink" title="2.3.1 逻辑运算指令"></a>2.3.1 逻辑运算指令</h3><h4 id="逻辑与-AND"><a href="#逻辑与-AND" class="headerlink" title="逻辑与 AND"></a>逻辑与 AND</h4><p>结果返回到目的操作数，会设置CF=OF=0，影响SF，ZF，PF</p><ul><li>AND reg, imm/reg/mem</li><li>AND mem, imm/reg</li></ul><h4 id="逻辑或-OR"><a href="#逻辑或-OR" class="headerlink" title="逻辑或 OR"></a>逻辑或 OR</h4><p>结果返回到目的操作数，会设置CF=OF=0，影响SF，ZF，PF</p><ul><li>OR reg, imm/reg/mem</li><li>OR mem, imm/reg</li></ul><h4 id="逻辑非-NOT"><a href="#逻辑非-NOT" class="headerlink" title="逻辑非 NOT"></a>逻辑非 NOT</h4><p>不影响标志位</p><ul><li>NOT reg/mem</li></ul><h4 id="逻辑异或-XOR"><a href="#逻辑异或-XOR" class="headerlink" title="逻辑异或 XOR"></a>逻辑异或 XOR</h4><p>结果返回到目的操作数，会设置CF=OF=0，影响SF，ZF，PF，可用<code>XOR EAX,EAX</code>做清零运算</p><ul><li>XOR reg, imm/reg/mem</li><li>XOR mem, imm/reg</li></ul><h4 id="测试指令"><a href="#测试指令" class="headerlink" title="测试指令"></a>测试指令</h4><p>将两个数进行逻辑与运算，但不返回到目的操作数</p><ul><li>TEST reg, imm/reg/mem</li><li>TEST mem, imm/reg</li></ul><h3 id="2-3-2-移位指令"><a href="#2-3-2-移位指令" class="headerlink" title="2.3.2 移位指令"></a>2.3.2 移位指令</h3><h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><p>影响CF，SF，ZF，PF，如果移动一位，按照最高符号位是否改变设置OF，有改变则OF置1，移动次数大于1，OF不确定，逻辑移位可实现乘除2^N，余数由CF反应</p><ul><li>逻辑左移i8/CL位 SHL reg/mem, i8/CL 最低位补0，最高位进CF</li><li>逻辑右移i8/CL位 SHR reg/mem, i8/CL 最高位补0，最低位进CF</li><li>算数左移 SAL reg/mem, i8/CL 与SHL是同一条指令</li><li>算数右移i8/CL位 SAR reg/mem, i8/CL 最高位不变，最低为进CF</li></ul><h4 id="循环移位指令"><a href="#循环移位指令" class="headerlink" title="循环移位指令"></a>循环移位指令</h4><p>从一端移出返回到另一端形成循环，影响CF，OF，OF和移位指令一样</p><ul><li>不带进位循环左移 ROL reg/mem, i8/CL 最高位进入CF和最低位</li><li>不带进位循环右移 ROR reg/mem, i8/CL 最低位进入CF和最高位</li><li>带进位循环左移 RCL reg/mem, i8/CL CF进入最低位，最高位进入CF</li><li>带进位循环右移 RCR reg/mem, i8/CL CF进入最高位，最低位进入CF</li></ul><h1 id="3-程序结构"><a href="#3-程序结构" class="headerlink" title="3 程序结构"></a>3 程序结构</h1><h2 id="3-1-分支程序结构"><a href="#3-1-分支程序结构" class="headerlink" title="3.1 分支程序结构"></a>3.1 分支程序结构</h2><p>汇编语言需要首先利用比较CMP、测试TEST、加减运算、逻辑运算等影响状态标志的指令形成条件，然后利用条件转移指令判断由标志表达的条件，并根据标志状态控制程序转移到不同的程序段。</p><h3 id="3-1-1-无条件转移指令-JMP"><a href="#3-1-1-无条件转移指令-JMP" class="headerlink" title="3.1.1 无条件转移指令 JMP"></a>3.1.1 无条件转移指令 JMP</h3><ul><li>JMP label</li><li>JMP r32/r16</li><li>JMP m32/m16</li><li>JMP m48/m32</li></ul><h3 id="3-1-2-条件转移指令-JCC"><a href="#3-1-2-条件转移指令-JCC" class="headerlink" title="3.1.2 条件转移指令 JCC"></a>3.1.2 条件转移指令 JCC</h3><p>为区别有符号数的大小关系，无符号数的大小关系用高低表示，他需要利用CF确定高低，利用ZF确定相等。两个无符号数据的高低分成四种关系，对应9-12条。判断有符号数的大小需要组合OF和SF标志，并利用ZF标志确定相等于否，两个有符号数的大小也分四种关系，对应13-16条。对于判断是否相等，无论有无符号都是用JZ/JE。</p><ul><li>JZ/JE ZF=1 等于零/相等</li><li>JNZ/JNE ZF=0 不等于零/不相等</li><li>JS SF=1 符号为负</li><li>JNS SF=0 符号为负</li><li>JP/JPE PF=1 1的个数为偶</li><li>JNP/JPO PF=0 1的个数为奇</li><li>JO OF=1 溢出</li><li>JNO OF=0 无溢出</li><li>JC/JB/JNAE CF=1 进位/低于/不高于等于</li><li>JNC/JNB/JAE CF=0 无进位/不低于/高于等于</li><li>JBE/JNA CF=1或ZF=1 低于等于/不高于</li><li>JNBE/JA CF=0且ZF=1 不低于等于/高于</li><li>JL/JNGE SF!=OF 小于/不大于等于</li><li>JNL/JGE SF=OF 不小于/大于等于</li><li>JLE/JNG SF!=OF或ZF=1 小于等于/不大于</li><li>JNLE/JG SF=OF且ZF=0 不小于等于/大于</li></ul><h2 id="3-2-循环程序结构"><a href="#3-2-循环程序结构" class="headerlink" title="3.2 循环程序结构"></a>3.2 循环程序结构</h2><h3 id="3-2-1-循环指令-LOOP"><a href="#3-2-1-循环指令-LOOP" class="headerlink" title="3.2.1 循环指令 LOOP"></a>3.2.1 循环指令 LOOP</h3><ul><li>LOOP label 执行ECX次循环</li><li>JECXZ label ECX=0循环</li></ul><h1 id="附1-关键字"><a href="#附1-关键字" class="headerlink" title="附1 关键字"></a>附1 关键字</h1><table><thead><tr><th align="center">符号</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">EQU</td><td align="center">定义符号常量，不可重复</td></tr><tr><td align="center">MOD</td><td align="center">取余运算</td></tr><tr><td align="center">DUP</td><td align="center">复制操作符</td></tr><tr><td align="center">BYTE</td><td align="center">一个字节</td></tr><tr><td align="center">WORD</td><td align="center">两个字节</td></tr><tr><td align="center">DWORD</td><td align="center">四个字节</td></tr><tr><td align="center">FWORD</td><td align="center">六个字节</td></tr><tr><td align="center">QWORD</td><td align="center">八个字节</td></tr><tr><td align="center">TBYTE</td><td align="center">十个字节</td></tr><tr><td align="center">ORG</td><td align="center">将参数表达的偏移地址作为当前偏移地址</td></tr><tr><td align="center">ALIGN</td><td align="center">地址对齐</td></tr><tr><td align="center">OFFSET</td><td align="center">返回变量名所在段偏移地址</td></tr><tr><td align="center">SEG</td><td align="center">返回段基地址</td></tr><tr><td align="center">TYPE</td><td align="center">返回变量类型字节数</td></tr><tr><td align="center">LENGTHOF</td><td align="center">返回元素数</td></tr><tr><td align="center">SIZEOF</td><td align="center">返回变量所占字节数</td></tr><tr><td align="center">NOP</td><td align="center">空操作</td></tr><tr><td align="center">CALL</td><td align="center">子程序调用</td></tr><tr><td align="center">RET</td><td align="center">子程序返回</td></tr><tr><td align="center">INT</td><td align="center">中断调用</td></tr><tr><td align="center">IRET</td><td align="center">中断返回</td></tr><tr><td align="center">PUSHAD</td><td align="center">全部32位寄存器进栈</td></tr><tr><td align="center">POPAD</td><td align="center">全部32位寄存器出栈</td></tr><tr><td align="center">PUSHA</td><td align="center">全部16位寄存器进栈</td></tr><tr><td align="center">POPA</td><td align="center">全部16位寄存器出栈</td></tr><tr><td align="center">CBW</td><td align="center">AL符号扩展为AX</td></tr><tr><td align="center">CWD</td><td align="center">AX符号扩展为DX和AX</td></tr></tbody></table><h1 id="附2-程序示例"><a href="#附2-程序示例" class="headerlink" title="附2 程序示例"></a>附2 程序示例</h1><ul><li>双字变量大小端互换：65</li><li>换码显示程序：69</li><li>64位数据相加程序：73</li><li>大小写字母转换程序：75</li><li>温度转换程序：78</li><li>移位指令实现乘法：83</li><li>循环移位程序：84</li><li>自然数求和程序：91</li><li>处理器识别程序：92</li><li>不同进制显示程序：92</li><li>个数折半程序：97 JNC</li><li>位测试程序：98 JZ</li><li>奇校验程序：99 JNP</li><li>数据比较程序：100</li><li>求绝对值程序：101</li><li>字母判断程序：102</li><li>显示数据最高位程序：103</li><li>有符号数运算溢出程序：104</li><li>地址表程序：104 多分支</li><li>数组求和程序：107 数组元素访问</li><li>求最大值程序：109</li><li>简单加密解密程序：110</li><li>字符个数统计程序：111</li><li>斐波那契数列程序：111</li><li>冒泡排序：112</li><li>字符剔除程序：113</li><li>16进制显示程序：123</li><li>有符号10进制显示程序：124</li><li>二进制输入程序：126</li><li>有符号10进制输入程序：127</li><li>计算有符号数平均值程序：129</li><li>状态标志显示程序：137</li><li>通用寄存器显示程序：139</li><li>ASCII表显示程序：142</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开心</title>
      <link href="2020/06/03/record/%E5%BC%80%E5%BF%83/"/>
      <url>2020/06/03/record/%E5%BC%80%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>拿到了网易的春招实习offer！开心！</p><a id="more"></a><p>从四月开始一直到现在，真的心累，但好在最后有一个好结果，这段时间来可以说是自己大学两年成长最快的一段时间了。现在的任务就是把课业好好学一学，虽然平时分估计都非常低了，这学期基本就没咋上过课，签到能有一半都不错了..还剩两周好好复习，争取不要挂科！</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>共享内存</title>
      <link href="2020/05/05/C++/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
      <url>2020/05/05/C++/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><blockquote><p>共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。</p></blockquote><ol><li><p>共享内存头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>共享内存操作函数</p><ul><li><p>创建或打开一块共享内存区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">- key: <span class="keyword">key_t</span> 这是一个整形, 通过这个可以可以找到或者创建一块共享内存</span><br><span class="line">一般这个整形数, 使用<span class="number">16</span>机制形式来表示, 非<span class="number">0</span> 值</span><br><span class="line">- size: 共享内存的大小</span><br><span class="line">- shmflg: 属性</span><br><span class="line">- 访问权限</span><br><span class="line">- 附件属性: 创建/判断共享内存是不是存在</span><br><span class="line">- 创建: IPC_CREAT</span><br><span class="line">- 判断共享内存是不是已经存在: IPC_EXCL, 需要和 IPC_CREAT 一起使用</span><br><span class="line">IPC_CREAT|IPC_EXCL|<span class="number">0664</span></span><br><span class="line">     返回值:</span><br><span class="line">失败: <span class="number">-1</span></span><br><span class="line">        成功: &gt; <span class="number">0</span>, 返回共享内存的引用的ID, 通过这个返回值就可以找到这块共享内存</span><br><span class="line"><span class="comment">// 创建一块共享内存</span></span><br><span class="line">shmget(<span class="number">0x10</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line"><span class="comment">// 判断共享内存是不是存在 -&gt; size是用不到的, 写多少都行, 一般写 0</span></span><br><span class="line">shmget(<span class="number">0x10</span>, <span class="number">0</span>, IPC_CREAT|IPC_EXCL);</span><br><span class="line"> - 存在: 返回是&gt; <span class="number">0</span>, 不存在: <span class="number">-1</span></span><br><span class="line"><span class="comment">// 打开共享内存</span></span><br><span class="line">shmget(<span class="number">0x10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>将当前进程和共享内存关联到一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">- shmid: shmget的返回值, 共享内存的ID</span><br><span class="line">- shmaddr: 申请的共享内存的起始地址, 指定为<span class="literal">NULL</span> -&gt; 内核指定</span><br><span class="line">- shmflg: 对共享内存的操作</span><br><span class="line">- 读: SHM_RDONLY, 必须要有读权限</span><br><span class="line">- 读写:  <span class="number">0</span></span><br><span class="line">     返回值:</span><br><span class="line">成功: 共享内存的首(起始)地址</span><br><span class="line">失败: (<span class="keyword">void</span> *) <span class="number">-1</span></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="keyword">void</span>* ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">char</span>* p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ptr, p, <span class="built_in">strlen</span>(p));</span><br></pre></td></tr></table></figure></li><li><p>将共享内存和当前进程分离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分离成功之后, 进程就不能操作这块共享内存了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line">参数: shmaddr: shmat的返回值</span><br><span class="line">返回值: 成功: <span class="number">0</span>, 失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure></li><li><p>共享内存操作 -（ 删除共享内存 ）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享内存必须删除才能消失</span></span><br><span class="line"><span class="comment">// 创建共享内存的进程被销毁了, 对共享内存没有任何影响</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">- shmid: shmget的返回值, 共享内存的ID</span><br><span class="line">- cmd: 要做到的操作</span><br><span class="line">- IPC_STAT: 获取共享内存当前状态</span><br><span class="line">- IPC_SET: 设置共享内存的状态</span><br><span class="line">- IPC_RMID: 标记共享内存要被销毁</span><br><span class="line">- buf:</span><br><span class="line">IPC_STAT: buf存储数据</span><br><span class="line">IPC_SET: buf中初始化数据 -&gt; 设置到内核</span><br><span class="line">IPC_RMID: 没有用, <span class="literal">NULL</span></span><br><span class="line"><span class="comment">// 想删除某块共享内存</span></span><br><span class="line">shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>思考问题</p><ul><li><p>问题1: 操作系统如何知道一块共享内存被多少进程关联?</p><ul><li>通过shmat进行一次管理, 在内存中会有一条记录<ul><li>可以称之为: 引用计数</li><li>产生一个关联: +1</li><li>取消关联: -1</li></ul></li></ul></li><li><p>问题2: 是不是可以对共享内存进行多次删除</p><ul><li><p>可以, 删除一次和删除多次是等价的</p><ul><li>调用shmctl 之后, 对共享内存进行标记 -&gt; 标记为要删除</li></ul></li></ul></li></ul></li></ol><pre><code>   - 共享内存的key 从非0 -&gt; 0之后 对共享内存访问     - 已经关联成功的进程可以继续访问   - 之前没有进行关联, 的进程就不能访问这块内存了       - 调用 shmat -&gt; 失败</code></pre><ol start="4"><li><p>shm和mmap的区别</p><blockquote><ol><li>shm可以直接创建, 内存映射区创建的时候需要依赖磁盘文件<ul><li>内存映射区匿名映射不能进行无血缘关系的进程通信</li></ul></li><li>shm效率更高<ul><li>shm直接对内存操作</li><li>mmap需要同步磁盘文件</li></ul></li><li>内存共享<ul><li>所有的进程操作的是同一块内存 -&gt; shm</li><li>内存映射区操作:<ul><li>每个进程都会在自己的虚拟地址空间中有一块独立的内存</li></ul></li></ul></li><li>数据安全性<ul><li>进程突然退出<ul><li>共享内存还在</li><li>内存映射区消失了</li></ul></li><li>运行进程的电脑突然挂了 -&gt; 死机<ul><li>数据存储在共享内存中 -&gt; 没有</li><li>内存映射区中的数据 -&gt; 还有<ul><li>内存映射区需要关联磁盘文件, 二者是同步的</li></ul></li></ul></li></ul></li><li>生命周期<ul><li>内存映射区: 进程退出, 内存映射区销毁</li><li>共享内存: 进程退出, 共享内存还在, 手动删除, 或者关机</li></ul></li></ol></blockquote></li></ol><ol start="5"><li><p>ftok 函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br><span class="line">- 参数pathname: 对应某个存在的路径或路径中的对应的文件名 - 绝对路径</span><br><span class="line">- 参数proj_id: 目前只使用了该变量占用的内存的一部分(<span class="number">1</span>个字节)</span><br><span class="line">        取值范围: <span class="number">0</span> - <span class="number">255</span></span><br><span class="line"><span class="keyword">key_t</span> t = ftok(<span class="string">&quot;/home/&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">shmget(t, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rand() % <span class="number">1000</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="3-共享内存操作命令"><a href="#3-共享内存操作命令" class="headerlink" title="3. 共享内存操作命令"></a>3. 共享内存操作命令</h1><ol><li><p>ipcs 用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipcs -a // 打印当前系统中所有的进程间通信方式的信息</span><br><span class="line">ipcs -m// 打印出使用共享内存进行进程间通信的信息   ==  常用</span><br><span class="line">================ 以下为了解内容 ================</span><br><span class="line">ipcs -q // 打印出使用消息队列进行进程间通信的信息</span><br><span class="line">ipcs -s // 打印出使用信号进行进程间通信的信息</span><br></pre></td></tr></table></figure></li><li><p>ipcrm 用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -M shmkey  // 移除用shmkey创建的共享内存段</span><br><span class="line">ipcrm -m shmid// 移除用shmid标识的共享内存段</span><br><span class="line">================ 以下为了解内容 ================</span><br><span class="line">ipcrm -Q msgkey// 移除用msqkey创建的消息队列</span><br><span class="line">ipcrm -q msqid// 移除用msqid标识的消息队列</span><br><span class="line">ipcrm -S semkey// 移除用semkey创建的信号</span><br><span class="line">ipcrm -s semid// 移除用semid标识的信号</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-共享内存API封装"><a href="#4-共享内存API封装" class="headerlink" title="4. 共享内存API封装"></a>4. 共享内存API封装</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string -&gt; char*</span></span><br><span class="line"><span class="comment">// .c_str()  /    data()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseShm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseShm(<span class="keyword">int</span> key)</span><br><span class="line">    &#123;</span><br><span class="line">        getShmID(key, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BaseShm(<span class="keyword">int</span> key, <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        getShmID(key, size, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BaseShm(<span class="built_in">string</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">key_t</span> key = ftok(name.data(), <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        getShmID(key, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BaseShm(<span class="built_in">string</span> name, <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">key_t</span> key = ftok(name.data(), <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        getShmID(key, size, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">mapShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ptr = shmat(m_shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unmapShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = shmdt(m_ptr);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = shmctl(m_shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getShmID</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> size, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_shmid = shmget(key, size, flag);</span><br><span class="line">        <span class="keyword">return</span> shmid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_shmid;</span><br><span class="line">    <span class="keyword">void</span>* m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>套接字超时</title>
      <link href="2020/05/05/C++/%E5%A5%97%E6%8E%A5%E5%AD%97%E8%B6%85%E6%97%B6/"/>
      <url>2020/05/05/C++/%E5%A5%97%E6%8E%A5%E5%AD%97%E8%B6%85%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-1-accept超时"><a href="#1-1-accept超时" class="headerlink" title="1.1 accept超时"></a>1.1 accept超时</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accept 等待并接受连接请求的过程, 是阻塞的</span></span><br><span class="line"><span class="comment">// 可以设置等待一定的时长, 如果长时间没有连接, 使该函数返回, 让当前进程/线程处理别的任务</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> s, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多路IO转接 select/poll/epoll</span></span><br><span class="line"><span class="comment">// 比如使用select实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大的文件描述符是: lfd</span></span><br><span class="line">fd_set rdset;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(lfd, &amp;rdset);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tm</span> =</span> &#123;<span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = select(lfd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tm);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 超时, 不等了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    accept(lfd, addr, len);<span class="comment">// 必然不阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2-connect-超时"><a href="#1-2-connect-超时" class="headerlink" title="1.2 connect 超时"></a>1.2 connect 超时</h2><blockquote><ol><li><p>Posix 定义了与 select/epoll 和 非阻塞 connect 相关的规定：</p><ul><li>连接成功建立时，socket 描述字变为可写。（连接建立时，写缓冲区空闲，所以可写）</li><li>连接建立失败时，socket 描述字既可读又可写。 （由于有未决的错误，从而可读又可写）</li></ul></li><li><p>连接失败, 错误判定方式:</p><ul><li>当用select检测连接时，socket既可读又可写，只能在可读的集合通过getsockopt获取错误码。</li></ul></li></ol><ul><li>当用epoll检测连接时，socket既可读又可写，只能在EPOLLERR中通过getsockopt获取错误码。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端主动给服务器发送连接请求</span></span><br><span class="line"><span class="comment">// connect内部有一个超时检测, 75s</span></span><br><span class="line"><span class="comment">// connect 是一个阻塞函数: 当前整个连接过程操作完成, 函数返回, 通过返回的状态可以判断连接的成功与否</span></span><br><span class="line"><span class="comment">// 如果想自己完成connect的超时检测, 需要将connect变成非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置connect的非阻塞, 修改fd的属性</span></span><br><span class="line"><span class="keyword">int</span> fl = fcntl(fd, F_GETFL);</span><br><span class="line">fl |= O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, fl);</span><br><span class="line"><span class="comment">// 2. 连接服务器</span></span><br><span class="line"><span class="keyword">int</span> ret = conect(connfd, serveraddr, len);</span><br><span class="line"><span class="comment">// 返回-1: 连接失败, errno==EINPROGRESS,说明在连接过程中</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINPROGRESS)</span><br><span class="line">&#123;</span><br><span class="line">    fd_set wrset;</span><br><span class="line">FD_ZERO(&amp;wrset);</span><br><span class="line">FD_SET(connfd, &amp;wrset);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tm</span> =</span> &#123;<span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = select(connfd+<span class="number">1</span>, <span class="literal">NULL</span>, &amp;wrset, <span class="literal">NULL</span>, &amp;tm);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 超时, 连接还没有完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)<span class="comment">// ==1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断连接是成功还是失败</span></span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(op);</span><br><span class="line">        getsockopt(connfd, SOL_SOCKET, SO_ERROR, &amp;op, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span> 设置回阻塞模式</span><br><span class="line">fnctl();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="comment">// 判断错误</span></span><br><span class="line">sockfd: 文件描述符</span><br><span class="line">level: SOL_SOCKET</span><br><span class="line">optname: SO_ERROR</span><br><span class="line">optval: <span class="keyword">int</span> 类型, 存储错误状态</span><br><span class="line">optlen: optval大小对一个的以地址</span><br></pre></td></tr></table></figure><h2 id="1-3-read超时"><a href="#1-3-read超时" class="headerlink" title="1.3 read超时"></a>1.3 read超时</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read默认也是阻塞 的</span></span><br><span class="line"><span class="comment">// 如果对方一直不给我方发数据, 线程会一直阻塞在read的位置, 可以设置超时时长, 时间到达之后线程去处理其他逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 多路IO转接 select/poll/epoll</span></span><br><span class="line"><span class="comment">// 比如使用select实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大的文件描述符是: 通信的 connfd</span></span><br><span class="line">fd_set rdset;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(connfd, &amp;rdset);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tm</span> =</span> &#123;<span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = select(connfd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tm);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 超时, 不等了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    read(connfd, buf, size);<span class="comment">// 必然不阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-write超时"><a href="#1-4-write超时" class="headerlink" title="1.4 write超时"></a>1.4 write超时</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地的写缓冲区已经被写满了, 再写会导致阻塞</span></span><br><span class="line"><span class="comment">// 如何对方不接收数据, 本地写缓冲区一直阻塞 -&gt; tcp通过滑动窗口实现的</span></span><br><span class="line"><span class="comment">// 不想一直阻塞, 可以设置阻塞超时</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多路IO转接 select/poll/epoll</span></span><br><span class="line"><span class="comment">// 比如使用select实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大的文件描述符是: 通信的 connfd</span></span><br><span class="line">fd_set wrset;</span><br><span class="line">FD_ZERO(&amp;wrset);</span><br><span class="line">FD_SET(connfd, &amp;wrset);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tm</span> =</span> &#123;<span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = select(connfd+<span class="number">1</span>, <span class="literal">NULL</span>, &amp;wrset, <span class="literal">NULL</span>, &amp;tm);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 超时, 不等了, 写缓冲区还是满的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 写缓冲区可用</span></span><br><span class="line">    write(connfd, buf, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雷火25笔试</title>
      <link href="2020/04/25/record/%E9%9B%B7%E7%81%AB4.25%E7%AC%94%E8%AF%95/"/>
      <url>2020/04/25/record/%E9%9B%B7%E7%81%AB4.25%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>四个小时，四道题，前两个小时过了俩，第三题有思路了，但是case0，感觉写的挺对…</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>在一个三维坐标系里搭积木，积木可以悬空。给出所有积木的坐标，问整体的表面积。我是先写了个判断两个积木是否相邻的函数，然后遍历积木，看当前积木和他后面的n个积木相邻，每确定一个ans += 6 - 2*n。题不算难，但也想了十多分钟。</p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>leetcode84题，相邻大楼贴最大广告牌，答案看别人使用单调栈做，然而自己根本不知道单调栈是啥，这题我上leetcode看做法很多，我是用的优化的暴力法做的，复杂度O(N^2)。还好当时想出来了…</p><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>N位十进制数允许前导零，按位相加等于S，任意三个连续组成的数字是X的整数倍，给出NSX，问有多少种可能？我先是把0-999中X的倍数存到K里，然后遍历K，然后取每个串前两位和串组成一对kv存到字典里，然后递归寻找，但是case0了…</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx分析</title>
      <link href="2020/04/18/other/nginx%E5%88%86%E6%9E%90/"/>
      <url>2020/04/18/other/nginx%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="nginx多进程同步非阻塞并发模型分析"><a href="#nginx多进程同步非阻塞并发模型分析" class="headerlink" title="nginx多进程同步非阻塞并发模型分析"></a>nginx多进程同步非阻塞并发模型分析</h1><blockquote><p>基于epoll-et事件驱动模型非阻塞处理并发请求，让nginx成为当下最流行的轻量级web服务器，其在性能方面远胜于同类型其他产品，通过IO多路复用机制实现并发，这使得nginx的网络IO操作在单个具体处理流程中是同步的，并不是真正意义上的UNIX IO模型中的AIO。本文通过分析nginx的内部实现机制，尝试寻找基于现有nginx网络架构基础上，进行异步IO的方式。</p></blockquote><h2 id="一．多进程与多核CPU"><a href="#一．多进程与多核CPU" class="headerlink" title="一．多进程与多核CPU"></a>一．多进程与多核CPU</h2><h3 id="（一）并行与并发"><a href="#（一）并行与并发" class="headerlink" title="（一）并行与并发"></a>（一）并行与并发</h3><ul><li>假设办公室内只有一台咖啡机，午休时大家排成一列队伍，每个人在自己的杯子里接满咖啡后，回到座位上慢慢享用。这个过程叫做串行。<br>同样的，办公室依旧只有一台咖啡机，大家依旧排成一列队伍，每个人只在自己的杯子里接一部分的咖啡，然后回到座位上将杯子中的咖啡喝光，继续排在队伍的后面，这个过程叫做并发。</li><li>而如果办公室内有两台咖啡机，大家就可以排成两列一样长的队伍，这两列队伍依旧按照并发处理，这个过程叫做并行。并行是需要硬件作为支撑的。<br>也就是说，如果计算机的cpu是单核的，那么在一个时间点内，cpu不可能同时处理多个进程，每个进程只能占用cpu资源一段时间。但如果cpu是多核的，当计算机中有多个进程需要处理，那么不同的两个进程之间就有可能是并行的。</li><li>nginx的架构设计默认采用多进程的方式，分为单个master进程和多个worker进程，其中worker进程的数量一般与cpu核数保持一致，基于这样的设置，使得nginx可以充分利用cpu资源，在硬件的层面上提升了服务器性能。<h3 id="（二）master与worker"><a href="#（二）master与worker" class="headerlink" title="（二）master与worker"></a>（二）master与worker</h3></li><li>unix系统中，nginx启动后以守护进程的形式在后台运行，整个nginx服务包含一个master进程和多个worker进程，nginx同样支持多线程模式，考虑到多线程模式的线程安全问题，我们一般就采用nginx默认的多进程模式。</li><li>master进程的主要负责接受外部的信号，向worker进程发送信号，监控worker进程的运行状态以及在worker进程异常死亡时重启worker进程。而worker进程则主要负责网络事件的处理。多个worker进程之间通过锁机制竞争客户端发送给master进程的请求处理权。<h3 id="（三）处理流程"><a href="#（三）处理流程" class="headerlink" title="（三）处理流程"></a>（三）处理流程</h3></li><li>当我们通过nginx在80端口提供http服务时，master进程通过socket() -&gt; bind() -&gt; listen()创建监听套接字并绑定在80端口上监听客户端的连接请求，并通过fork()创建多个worker进程，这些worker()进程复制了master进程的虚拟地址空间，共享内核区进程控制块的文件描述符表，当有客户端向nginx服务发起连接请求时，多个worker进程共享的监听套接字会在这时变为可读状态，通过为了保证只有一个进程处理该请求，所有worker进程需要争抢accpet_mutex锁，抢到互斥锁的的进程负责处理监听套接字的读事件。</li><li>在worker进程获取了与客户端通信的权力后，便开始进行recv()，send()等一系列操作，最后断开与客户端通信的套接字，这就是一个请求从发起到结束的全部流程。nginx通过多进程的方式，将一个时间点内的多个请求分摊给多个worker处理，这多个worker进程绑定cpu不同核心，相比于单进程处理，多进程的处理方式对服务器性能做了极大的提升。</li></ul><h2 id="二．事件驱动架构"><a href="#二．事件驱动架构" class="headerlink" title="二．事件驱动架构"></a>二．事件驱动架构</h2><blockquote><p>nginx的事件驱动架构的核心是epoll，也是nginx得以获得高并发，高性能的关键因素，IO多路复用技术可以用来实现事件驱动模型，nginx使用的epoll就是IO多路复用技术之一，此外还有select与poll，与多进程多线程相比，IO多路复用技术的最大优势是系统开销小，不必创建维护进程/线程。下面通过分析三种不同的IO多路复用技术，探讨epoll的优势所在。</p></blockquote><h3 id="（一）select"><a href="#（一）select" class="headerlink" title="（一）select"></a>（一）select</h3><ul><li>select会构造一张文件描述符列表，需要我们手动添加要监听的文件描述符到表中，select内部会以遍历的形式检测被标识的文件描述符是否具有可读/可写/异常状态，当某个文件描述符具备这种状态的时候，select函数返回，我们通过读取传入文件描述符列表，就能够判断可处理文件描述符，进而进行相关IO操作。</li><li>select的缺点之一在于select函数的fdset大小为128字节，最大监听文件描述符数量为1024，修改系统内核也会造成效率的降低，其次select对文件描述符表采用轮询处理，即遍历处理，这样的效率是很低的。再有select需要在内核区和用户去频繁复制文件描述符集，使得系统开销变大。<h3 id="（二）poll"><a href="#（二）poll" class="headerlink" title="（二）poll"></a>（二）poll</h3></li><li>poll是对select的简单改进版，其对文件描述符集的遍历依旧是线性遍历，但是poll使用链表数据结构维护文件描述符集，这使得可检测的文件描述符数量突破了select函数1024的限制，可操作的文件描述符数量即为系统可以打开的最大文件描述符数量。还有一点优化在于用户无需每次调用poll时传入一个新的文件描述符集，因为poll对于传入文件描述符集的修改在结构体的revents上，其要检测事件events是不会被修改的。<h3 id="（三）epoll"><a href="#（三）epoll" class="headerlink" title="（三）epoll"></a>（三）epoll</h3></li><li>epoll相比于select和poll最大的改进在于epoll使用了红黑树+就绪链表的数据结构，可监听文件描述符数量与poll一样是系统可打开的最大文件描述符数。用户使用epoll_create函数会在内核创建一颗红黑树（用来维护用户关心的文件描述符），以及就绪链表（用来存放已经就绪的文件描述符）。接着用户执行epoll_ctl函数传入epoll_event结构体，该结构体会被拷贝进内核，内核会在红黑树上添加对应的节点。需要注意的是，内核对红黑树上可用文件描述符的检测依旧采用轮询处理，当发现某个文件描述符处于可用状态时，会调用该节点在epoll_ctl时注册的回调函数，将其添加进就绪链表当初，epoll_wait返回的文件描述符集只存在可用文件描述符，这使得用户在遍历该文件描述符集时省去了大量不可用文件描述符的事件。并且这里返回的文件描述符集通过mmap创建内核区和用户区的共享内存空间，减少了在内核区与用户区之间不必要的拷贝操作。其次epoll支持边沿触发工作模式，当事件发生时，用户必需立即处理完成，有效减少了事件触发次数。</li></ul><h3 id="（四）epoll与select、poll对比"><a href="#（四）epoll与select、poll对比" class="headerlink" title="（四）epoll与select、poll对比"></a>（四）epoll与select、poll对比</h3><ol><li>epoll减少了用户区和内核区之间的数据拷贝。<ul><li>使用select时需要创建fdset拷贝到内核中，在内核检测到就就绪事件后，修改传入fdset的标志位告知用户有就绪事件的发生，然后将fdset从内核区拷贝到用户区。内核区删除和文件描述符相关的数据结构，由于select修改了fdset的值，在下一次调用select时必需重置fdset，内核再重新拷贝一份新的文件描述符集。</li><li>调用poll时将pollfd结构体数组拷贝到内核区监听，内核分配链表来存储监听的文件描述符，检测到事件发生后修改fd对应的revents值用于告知用户，而events成员不变，因此下一次调用poll无需重置操作。然后内核把传入的pollfd传出到用户区，删除与文件描述符相关的数据结构，下次调用poll需要将pollfd重新传给内核，内核重新拷贝，重新分配数据结构。</li><li>调用epoll_create会在内核区创建红黑树和就绪链表，接着调用epoll_ctl将epoll_event结构体拷贝到内核区，内核在红黑树上添加对应节点，然后将就绪链表上的文件描述符传入epoll_event结构体数组返回用户区，系统在返回时使用内存映射函数mmap创建共享存储区，避免了从内核区到用户区的拷贝操作，且内核不会删除与文件描述符相关的数据结构，下一次epoll调用也就不需要再做用户区到内核区的拷贝操作，直接沿用之前的数据结构。</li></ul></li><li>epoll减少了对就绪文件描述符的遍历。<ul><li>需要注意的是，在内核的层面上，内核检测文件描述符集时，三者采用的都是轮询的操作，时间复杂度都为O(n)，唯一的区别在于epoll的红黑树上只维护了用户关心的文件描述符，而select则是维护了全部1024个文件描述符，poll则是维护用户传入的pollfd结构体数组。</li><li>而在用户层面上，epoll返回的是内核就绪链表中的文件描述符，这里面的文件描述符全部都是用户需要处理的，所以在用户层面上调用epoll的时间复杂度为O(1)，而selcet和poll返回的就是传入的文件描述符集，我们需要通过遍历去判断哪个文件描述符处于就绪状态，因此在调用select和poll的时候时间复杂度为O(n)。虽然select和poll都可以通过maxfd来做一定程度上的遍历优化，但依旧存在时间浪费问题。</li></ul></li><li>epoll支持et工作模式<ul><li>select和poll都是LT（水平触发）工作模式，而epoll默认采用LT工作模式，同样也支持ET（边沿触发）工作模式。并且同时支持block与no-block文件描述符。</li><li>LT工作模式即当内核检测到文件描述符集上有文件描述符处于就绪状态，就会通知用户，用户可以选择不处理或只处理一部分，下一次调用时内核依旧会通知用户该文件描述符处于就绪状态。</li><li>ET工作模式即当内核检测到文件描述符集上有文件描述符处于就绪状态，会通知用户但该文件描述符只被通知一次直到下一次新的就绪状态来临，因此用户必需立即处理完成该事件，所以对应的文件描述符必须设置非阻塞，避免在循环对文件描述符做读写操作时，因为操作完成而阻塞在读写操作上。ET工作模式很大程度上减少了文件描述符被重复触发的次数，因此效率比LT工作模式要高。</li><li>但是在epoll配合多线程使用时，一个文件描述符依旧有可能被触发多次，当一个线程在处理该文件描述符时，该文件描述符触发了新的就绪状态，这时另一个线程被通知处理该文件描述符，这就造成了两个线程同时操作一个文件描述符的问题。epoll对此问题提供了相应的EPOLLONESHOT事件，对于注册了EPOLLONESHOT的文件描述符，内核只触发该文件描述符的一个事件且只触发一次，只有在一个线程对该文件描述符的处理完成后，该线程会会重置该文件描述符上EPOLLONESHOT事件状态，使得该文件描述符再次处于可被触发状态。使用EPOLLONESHOT事件机制进一步减少了事件被触发的次数。</li></ul></li><li>epoll适用情形<ul><li>由于epoll在内核中维护了红黑树和就绪链表，且该数据结构不被删除可以重复利用，内核开销很大，如果只是监听少量的文件描述符，内核开销得不偿失，因此epoll适用于并发量大的情景。而且需要注意的是，当并发量较大时，就绪文件描述符拷贝到就绪列表的操作太大，对服务器来讲是不小的压力，这也是epoll相比于select和poll的不足之处。</li></ul></li></ol><h2 id="三．同步与异步"><a href="#三．同步与异步" class="headerlink" title="三．同步与异步"></a>三．同步与异步</h2><ul><li><p>同步异步与阻塞非阻塞常常被同时提起，由于nginx使用epoll-et作为事件驱动模型，使得通信套接字为非阻塞状态，那么为什么说nginx是同步IO模型呢？</p></li><li><p>上文提到epoll在内核层面上通过轮询的方式，寻找处于就绪状态的文件描述符，当寻找到时将该文件描述符添加到就绪链表当中，这个添加过程用到了红黑树在节点添加时注册的回调函数，通过该回调函数为就绪链表添加就绪状态文件描述符。而在用户层面，遍历epoll_event结构体数组处理所有处于就绪状态的文件描述符。</p></li><li><p>有POSIX对异步IO和同步IO的定义：</p><blockquote><p>An asynchronous I/O operation does not cause the requesting process to be blocked; （异步IO操作不会导致请求进程被阻塞）<br>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;（同步IO操作导致请求过程被阻塞，直到该IO操作完成）</p></blockquote></li><li><p>而对于处于就绪状态文件描述符的IO操作在用户区进行，在遍历就绪文件描述符数组时，对相应的文件描述符做IO操作，这个过程时阻塞的，只有所有的IO操作进行完，进程才可以做后续操作。需要注意的是，这里的阻塞不是指文件描述符的阻塞/非阻塞状态，文件描述符在epoll-et模式下，被设置为非阻塞。但是进程必须等待就绪文件描述符的IO操作结束，这个过程是阻塞的，该阻塞状态持续到IO操作完成。符合POSIX对于同步IO的定义。</p></li><li><p>那为什么在有些资料中说nginx是多进程+异步非阻塞呢？这个异步操作到底体现在哪里呢？对于内核层面，调用epoll_ctl函数添加红黑树节点时，会为该文件描述符注册回调函数，当轮询红黑树节点发现某个节点处于就绪状态时，调用对应的回调函数将该文件描述符添加到就绪链表。但这个过程并不是异步回调，轮询操作必须等待回调函数完成才能够继续进行。至于“异步”大体指的是编程模型上的异步概念，指文件描述符就绪状态的轮询判定与就绪状态的处理是异步关系，并非真正的异步IO。</p></li></ul><h2 id="四．总结"><a href="#四．总结" class="headerlink" title="四．总结"></a>四．总结</h2><ul><li>异步IO的效率毫无疑问是高于同步IO的，那我们有没有可能对nginx现有的架构做进一步的优化，使其真正支持异步IO通信呢？epoll在内核层面采用了回调机制，在C语言中，回调是处理异步IO操作的一种简捷的方式，但需要配合多线程的使用，但是使用多线程需要创建并维护线程，线程之间上下文的切换也需要额外的开销，这对于在高并发情形下本就不轻松的内核来说，无异于是更大的负担。而对于用户区来说，亦没有必要采用多线程的方式对就绪状态文件描述符做IO操作，由于所有的文件描述符都是就绪的，在整个遍历处理的过程中，没有阻塞状态，也就没有对cpu资源的浪费行为，前面也已经提到过nginx的整体工作流程是采用多进程的方式，对cpu资源已经达到了最大程度的利用，我们再去使用多线程处理只会增加内核的负担。也就是说，nginx现有的架构已经是再多种并发模型权衡下的最优选择，但在最新的C++20标准中为C++引入了协程，C++中的协程具备夸张的性能优势，或许在未来会出现基于现有nginx架构，使用C++协程实现真正的多进程+异步非阻塞模型也极有可能。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx是同步的!</title>
      <link href="2020/04/16/other/nginx%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84!/"/>
      <url>2020/04/16/other/nginx%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84!/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>nginx通过多进程 + epoll实现，nginx的事件驱动指的就是epoll，而不是通过MQ实现异步的那种</p><p>不知道怎么回事一搜nginx都是异步非阻塞，因为这点事研究了好久，压根就不是异步的</p><p>master进程里做socket、bind、listen</p><p>worker进程里抢accept的处理权，抢到之后就是epoll的一套流程</p><p>首先要说的是IO多路复用就是同步非阻塞的，poll就是轮询还异步个p，除非开多线程/多进程，不过要是开了还IO复用干p</p><p>nginx的多进程不是在epoll上，epoll的整个处理流程都在worker上，主要为了充分利用多核cpu的优势</p><p>真TM气死我了，网上哪来那么多nginx异步非阻塞啊</p><p>就算扯了一堆理由往异步上靠，也绝对不是unix的AIO！！！！</p><blockquote><p>POSIX 定义：An asynchronous I/O operation does not cause the requesting process to be blocked;<br>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地套接字</title>
      <link href="2020/04/11/C++/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
      <url>2020/04/11/C++/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h1><blockquote><p>用于本地进程间通信，有无亲缘关系均可</p><p>一般使用tcp通信流程</p><p>客户端和服务端各自对应一个本地套接字文件，指向一块内核缓冲区，A端写会写到自己的wirte区然后发到B端的read区，A端读从自己的read区读</p></blockquote><h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><ul><li>服务器端</li></ul><ol><li>创建监听的套接字<ul><li>int lfd = socket(af_local, sock_stream, 0);</li><li>第一个参数: AF_UNIX或AF_LOCAL</li></ul></li><li>监听的套接字绑定本地的 套接字文件-&gt; server端<ul><li>struct sockaddr_un addr;</li><li>绑定成功之后, 指定的sun_path中的套接字文件会自动生成</li><li>bind(lfd, addr, len);</li></ul></li><li>监听<ul><li>listen(lfd, 100);</li></ul></li><li>等待并接受连接请求<ul><li>struct sockaddr_un cliaddr;</li><li>int connfd  = accept(lfd, cliaddr, len);</li></ul></li><li>通信<ul><li>接收数据: read/recv</li><li>发送数据: write/send</li></ul></li><li>关闭连接<ul><li>close();</li></ul></li></ol><ul><li>客户端</li></ul><ol><li>创建通信的套接字<ul><li>int fd = socket(af_local, sock_stream, 0);</li></ul></li><li>监听的套接字绑定本地的IP 端口<ul><li>struct sockaddr_un addr;</li><li>绑定成功之后, 指定的sun_path中的套接字文件会自动生成</li><li>bind(fd, addr, len);</li></ul></li><li>连接服务器<ul><li>struct sockaddr_un serveraddr;</li><li>connect(fd, serveraddr, sizeof(serveraddr));</li></ul></li><li>通信<ul><li>接收数据: read/recv</li><li>发送数据: write/send</li></ul></li><li>关闭连接<ul><li>close();</li></ul></li></ol><ul><li>sockaddr_un<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件:  sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">  <span class="keyword">char</span> sun_path[UNIX_PATH_MAX];<span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待并接受连接请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket fileName: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> nums = recv(connfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client disconnect...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, buf);</span><br><span class="line">            send(connfd, buf, nums, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(connfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="comment">// 绑定成功, client.sock会自动生成j</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(cfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (struct sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 5. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, everyone... %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> nums = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server disconnect...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>udp</title>
      <link href="2020/04/10/C++/udp/"/>
      <url>2020/04/10/C++/udp/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="/photo/udp%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png" alt="udp通信流程" loading="lazy"></p><blockquote><p>先说下tcp的send和recv</p><ul><li>ssize_t send(int sockfd, const void * buf, size_t len, int flags);    和write一样，flags一般写0</li><li>ssize_t recv(int sockfd, void * buf, size_t len, int flags);        和read一样，flags一般写0</li></ul></blockquote><h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><ul><li><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code></li><li>sockfd: 通信的fd</li><li>buf: 要发送的数据</li><li>len: 要发送的数据的长度</li><li>flags: 一般写0</li><li>dest_addr: 通信的另外一端的地址信息</li><li>addrlen: dest_addr的内存大小</li></ul><h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><ul><li><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code></li><li>sockfd: 通信的fd</li><li>buf: 接收数据的一块内存</li><li>len: 接收数据的内存(第二个参数)大小</li><li>flags: 0</li><li>src_addr: 接收谁的数据, 就写入了那个终端的地址信息, 如果不要这部分数据 -&gt; NULL</li><li>addrlen: src_addr参数对应内存大小(传入传出参数)</li></ul><h3 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h3><ul><li>因为udp无连接，所以这里没写并发，服务器也支持客户端并发请求<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的fd绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0 -&gt; 0.0.0.0</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">char</span> ipbuf[<span class="number">64</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP: %s, Port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的fd绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, everyone %d ...\n&quot;</span>, num++);</span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><blockquote><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。</p><ul><li>只能在局域网中使用</li><li>客户端只要绑定了服务器广播使用的端口, 就可以接收到广播数据</li></ul></blockquote><ul><li>一个网段的ip地址可以是0-255，但0和255不能标识主机<ul><li>192.168.x.0表示一个网段</li><li>192.168.x.255表示广播地址<br><img src="/photo/%E5%B9%BF%E6%92%AD.png" alt="广播" loading="lazy"></li></ul></li></ul><h3 id="通信流程-1"><a href="#通信流程-1" class="headerlink" title="通信流程"></a>通信流程</h3><ul><li>服务器端 -&gt; 广播的一端:<ul><li>创建通信的套接字<ul><li>int fd = socket( af_inet, SOCK_DGRAM, 0);</li><li>设置udp广播属性<ul><li><code>int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);</code></li><li>sockfd: 文件描述符<ul><li>level: SOL_SOCKET</li><li>optname: SO_BROADCAST</li><li>optval: int数值为1, 允许广播</li><li>optlen: optval内存大小</li></ul></li></ul></li></ul></li><li>通信 -&gt; 发送广播数据<ul><li>struct sockaddr_in cliaddr;</li><li>cliaddr.sin_port(8888);    // 广播数据发送到客户端的8888端口, 客户端需要绑定该端口</li><li>cliaddr.sin_addr.s_addr -&gt; 初始化一个广播地址</li><li>发送数据: sendto(fd, buf, len, 0, &amp;cliaddr, len);</li></ul></li><li>关闭通信的fd<ul><li>close(fd);</li></ul></li></ul></li><li>客户端<pre><code>- 创建一个通信的套接字      - int fd = socket(af_inet, SOCK_DGRAM, 0);- 如果想接收广播数据, 需要绑定以固定端口(服务器广播数据使用的端口)      - struct sockaddr_in cliaddr;      - cliaddr.sin_port(8888);      - bind(fd, cliaddr, len);- 通信      - 接收数据: recvfrom- 关闭通信的文件描述符      - close(fd);</code></pre></li></ul><h3 id="server-c-1"><a href="#server-c-1" class="headerlink" title="server.c"></a>server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置广播属性</span></span><br><span class="line">    <span class="keyword">int</span> op = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line">    <span class="comment">// 将数据发送给客户端, 使用广播地址和固定端口</span></span><br><span class="line">    <span class="comment">// 初始化客户端的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">8989</span>); <span class="comment">// 客户端也需要绑定这端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.247.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n &quot;</span>, num++);</span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;广播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-c-1"><a href="#client-c-1" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的fd绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"><span class="comment">//inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组播-多播"><a href="#组播-多播" class="headerlink" title="组播(多播)"></a>组播(多播)</h2><blockquote><p>Server给局域网的交换机发送数据，无论连接到局域网的客户端想不想接收该数据，Server都会给客户端发送该数据。—&gt;进而造成客户端上数据的拥塞—&gt;因此引出了多播(组播)：Server可以将数据包只发送给指定组内的客户端，而不发送给指定组外的客户端。</p><ul><li>可以在internet中进行组播</li><li>加入到多播组中才可以收到数据</li></ul></blockquote><p><img src="/photo/%E7%BB%84%E6%92%AD.png" alt="组播" loading="lazy"></p><ul><li>组播地址<table><thead><tr><th align="center">IP地址</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">224.0.0.0~224.0.0.255</td><td align="center">局部链接多播地址：是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包</td></tr><tr><td align="center">224.0.1.0~224.0.1.255</td><td align="center">预留多播地址：公用组播地址，可用于Internet；使用前需要申请</td></tr><tr><td align="center">224.0.2.0~238.255.255.255</td><td align="center">预留多播地址：用户可用组播地址(临时组地址)，全网范围内有效</td></tr><tr><td align="center">239.0.0.0~239.255.255.255</td><td align="center">本地管理组播地址，可供组织内部使用，类似于私有 IP 地址，不能用于 Internet，可限制多播范围</td></tr></tbody></table></li></ul><h3 id="通信流程-2"><a href="#通信流程-2" class="headerlink" title="通信流程"></a>通信流程</h3><ul><li>服务器端 -&gt; 组播的一端:<ul><li>创建通信的套接字<ul><li>int fd = socket(af_inet, SOCK_DGRAM, 0);</li><li>设置udp组播属性<ul><li><code>int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);</code></li><li>sockfd: 通信的文件描述符<ul><li>level: IPPROTO_IP</li><li>optname: IP_MULTICAST_IF</li><li>optval: struct in_addr</li><li>optlen: optval的内存大小</li></ul></li></ul></li></ul></li><li>通信 -&gt; 发送组播数据<ul><li>struct sockaddr_in cliaddr;</li><li>cliaddr.sin_port(8888);    // 广播数据发送到客户端的8888端口, 客户端需要绑定该端口</li><li>cliaddr.sin_addr.s_addr -&gt; 初始化一个组播地址</li><li>发送数据: sendto(fd, buf, len, 0, &amp;cliaddr, len);</li></ul></li><li>关闭通信的fd<ul><li>close(fd);</li></ul></li></ul></li><li>客户端<ul><li>创建一个通信的套接字<ul><li>int fd = socket( af_inet, SOCK_DGRAM, 0);</li></ul></li><li>如果想接收组播数据, 需要绑定以固定端口(服务器组播数据使用的端口)<ul><li>struct sockaddr_in cliaddr;</li><li>cliaddr.sin_port(8888);</li><li>bind(fd, cliaddr, len);</li></ul></li><li>客户端加入到组播网络中<ul><li><code>int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);</code></li><li>sockfd: 通信的文件描述符<ul><li>level: IPPROTO_IP</li><li>optname: IP_ADD_MEMBERSHIP</li><li>optval: struct ip_mreqn</li><li>optlen: optval 的内存大小</li></ul></li></ul></li><li>通信<ul><li>接收数据: recvfrom</li></ul></li><li>关闭通信的文件描述符<br>  close(fd);<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 组播组的IP地址.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">  <span class="comment">// 本地某一网络设备接口的IP地址。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_address</span>;</span></span><br><span class="line">  <span class="comment">// 网卡编号</span></span><br><span class="line">  <span class="keyword">int</span> imr_ifindex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="server-c-2"><a href="#server-c-2" class="headerlink" title="server.c"></a>server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置组播属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">    <span class="comment">// 初始化组播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据发送给客户端, 使用广播地址和固定端口</span></span><br><span class="line">    <span class="comment">// 初始化客户端的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">8989</span>); <span class="comment">// 客户端也需要绑定这端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, client...%d\n &quot;</span>, num++);</span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;组播的数据: %s\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-c-2"><a href="#client-c-2" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通信的fd绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">op</span>;</span></span><br><span class="line">    op.imr_address.s_addr = INADDR_ANY; <span class="comment">// 本地地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);</span><br><span class="line"></span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路转接</title>
      <link href="2020/04/09/C++/IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/"/>
      <url>2020/04/09/C++/IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="IO多路转接"><a href="#IO多路转接" class="headerlink" title="IO多路转接"></a>IO多路转接</h1><blockquote><p>多进程/多线程中，accept、read、write某些情况下是会阻塞的</p><p>改进思路：使用系统函数，让内核判断阻塞状态，不再由应用程序自己监视客户端连接和数据通信，取而代之由内核替应用程序监视文件</p><p>使用IO多路转接，系统不必再维护进程/线程，大大减小系统开销</p></blockquote><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ul><li>头文件：<ul><li>include &lt;sys/time.h&gt;</li><li>include &lt;sys/types.h&gt;</li><li>include &lt;unistd.h&gt;<blockquote><p>主旨思想:</p><ul><li><p>先构造一张有关文件描述符的列表, 将要监听的文件描述符添加到该表中</p></li><li><p>调用一个函数,监听该表中的文件描述符,直到这些描述符表中的一个进行I/O操作时，该函数才返回</p></li><li><ul><li>该函数为阻塞函数</li><li>函数对文件描述符的检测操作是由内核完成的</li></ul></li><li><p>在返回时，它告诉进程有多少(哪些)描述符要进行I/O操作</p></li></ul></blockquote></li></ul></li></ul><h3 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h3><ul><li>int select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout);</li><li>sizeof(fd_set) = 128字节，对应1024位</li><li>参数:<ul><li>nfds: 委托内核检测的最大文件描述符的值 + 1</li><li>readfds: 读集合, 委托内核检测哪些文件描述符的读属性<ul><li>一般检测读操作</li><li>对的是对方发送过来的数据, 因为读是被动的接收数据<ul><li>因此需要时时检测对应读缓冲区</li></ul></li><li>这是一个传入传出的参数</li></ul></li><li>fd_set: 写集合, 委托内核检测哪些文件描述符的写属性<ul><li>这是一个传入传出的参数</li><li>委托内核检测写缓冲区是不是还可以写数据(不满就可以写)</li></ul></li><li>exceptfds: 异常集合, 委托内核检测哪些文件描述符出现了异常</li><li>timeout:<ul><li>NULL: 永久阻塞, 直到检测到了文件描述符有变化</li><li>tv_sec = 0, tv_usec = 0, 不阻塞</li><li>tv_sec &gt; 0 || tv_usec &gt; 0, 阻塞对应的时间长度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">   <span class="keyword">long</span>    tv_sec;         <span class="comment">// seconds</span></span><br><span class="line">   <span class="keyword">long</span>    tv_usec;        <span class="comment">// microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>返回值:<ul><li>-1: 失败</li><li>&gt;0(n): 检测的集合中有n个文件描述符发生了变化</li></ul></li></ul><h3 id="FD-CLR"><a href="#FD-CLR" class="headerlink" title="FD_CLR"></a>FD_CLR</h3><ul><li>void FD_CLR(int fd, fd_set * set);</li><li>将参数文件描述符fd对应的标志位, 设置为0<h3 id="FD-ISSET"><a href="#FD-ISSET" class="headerlink" title="FD_ISSET"></a>FD_ISSET</h3></li><li>int FD_ISSET(int fd, fd_set * set);</li><li>判断fd对应的标志位到底是0还是1, 返回值: fd对应的标志位的值<h3 id="FD-SET"><a href="#FD-SET" class="headerlink" title="FD_SET"></a>FD_SET</h3></li><li>void FD_SET(int fd, fd_set * set);</li><li>将参数文件描述符fd对应的标志位, 设置为1<h3 id="FD-ZERO"><a href="#FD-ZERO" class="headerlink" title="FD_ZERO"></a>FD_ZERO</h3></li><li>void FD_ZERO(fd_set * set);</li><li>fd_set共有1024bit, 全部初始化为0</li></ul><p><img src="/photo/select1.png" alt="select1" loading="lazy"></p><p><img src="/photo/select2.png" alt="select2" loading="lazy"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待连接 -&gt; 循环</span></span><br><span class="line">    <span class="comment">// 检测 -&gt; 读缓冲区, 委托内核去处理</span></span><br><span class="line">    <span class="comment">// 数据初始化, 创建自定义的文件描述符集</span></span><br><span class="line">    fd_set rdset, tmp;</span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="keyword">int</span> maxfd = lfd;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 委托内核检测</span></span><br><span class="line">        tmp = rdset;</span><br><span class="line">        ret = select(maxfd+<span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测的度缓冲区有变化</span></span><br><span class="line">        <span class="comment">// 有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收连接请求</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockcli</span>;</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(sockcli);</span><br><span class="line">            <span class="comment">// 这个accept是不会阻塞的</span></span><br><span class="line">            <span class="keyword">int</span> connfd = accept(lfd, (struct sockaddr*)&amp;sockcli, &amp;len);</span><br><span class="line">            <span class="comment">// 委托内核检测connfd的读缓冲区</span></span><br><span class="line">            FD_SET(connfd, &amp;rdset);</span><br><span class="line">            maxfd = connfd &gt; maxfd ? connfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通信, 有客户端发送数据过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lfd+<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在集合中, 说明读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="keyword">int</span> ret = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;对方已经关闭了连接...\n&quot;</span>);</span><br><span class="line">                    FD_CLR(i, &amp;rdset);</span><br><span class="line">                    close(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(i, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><ul><li>是select的简单改进版<ul><li>内核对select集合是进行线性遍历<ul><li>最大支持检测1024个文件描述符，因为fdset128字节，但可以修改内核源码重新编译</li><li>内核中是用数组来维护的，所以不能更多</li></ul></li><li>内核对poll集合也是线性遍历<ul><li>可以检测大于1024文件描述符</li><li>内核使用链表维护<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>   fd;         <span class="comment">// 委托内核检测的文件描述符</span></span><br><span class="line">  <span class="keyword">short</span> events;     <span class="comment">// 委托内核检测文件描述符的什么事件</span></span><br><span class="line">  <span class="keyword">short</span> revents;    <span class="comment">// 文件描述符实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>[100];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>参数:<ul><li>fds: 这是一个struct pollfd数组, 这是一个要检测的文件描述符的集合</li><li>nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1</li><li>timeout: 阻塞时长<ul><li>0: 不阻塞</li><li>-1: 阻塞，检测的fd有变化解除阻塞</li><li>&gt;0: 阻塞时长，单位毫秒</li></ul></li></ul></li><li>返回值:<ul><li>-1: 失败</li><li>&gt;0(n): 检测的集合中有n个文件描述符发送的变化</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待连接 -&gt; 循环</span></span><br><span class="line">    <span class="comment">// 检测 -&gt; 读缓冲区, 委托内核去处理</span></span><br><span class="line">    <span class="comment">// 数据初始化, 创建自定义的文件描述符集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 委托内核检测</span></span><br><span class="line">        ret = poll(fds, maxfd+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测的度缓冲区有变化</span></span><br><span class="line">        <span class="comment">// 有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收连接请求</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockcli</span>;</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(sockcli);</span><br><span class="line">            <span class="comment">// 这个accept是不会阻塞的</span></span><br><span class="line">            <span class="keyword">int</span> connfd = accept(lfd, (struct sockaddr*)&amp;sockcli, &amp;len);</span><br><span class="line">            <span class="comment">// 委托内核检测connfd的读缓冲区</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fds[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxfd = i &gt; maxfd ? i : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通信, 有客户端发送数据过来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在集合中, 说明读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="keyword">int</span> ret = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;对方已经关闭了连接...\n&quot;</span>);</span><br><span class="line">                    close(fds[i].fd);</span><br><span class="line">                    fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><blockquote><p>内核检测epoll传递的fd集合，是以红黑树的形式遍历的</p><p>内核会创建一块共享内存：和用户区共享，不同于select和poll需要在内核区和用户区之间做频繁的拷贝</p><p>epoll的效率很高，1G的内存就可以支撑10万级的并发</p></blockquote><p><img src="/photo/epoll.png" alt="epoll" loading="lazy"></p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><ul><li><code>int epoll_create(int size);</code></li><li>创建一颗红黑树</li><li>size：以前使用hash表，底层是数组所以需要size，现在这个参数已经没有意义了，随便写一个就行，但不要写0，可能会有问题</li><li>返回值大于0，是个文件描述符，红黑树的根节点，用来操作红黑树</li></ul><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><ul><li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></li><li>对epoll树进行管理: 添加节点, 删除节点, 修改已有的节点属性</li><li>epfd: epoll_create的返回值, 通过这个值就可以找到红黑树</li><li>op: 要进行什么样的操作<ul><li>EPOLL_CTL_ADD: 注册新节点, 添加到红黑树上</li><li>EPOLL_CTL_MOD: 修改检测的文件描述符的属性</li><li>EPOLL_CTL_DEL: 从红黑树上删除节点</li></ul></li><li>fd: 要检测的文件描述符的值</li><li>event: 检测文件描述符的什么事件<ul><li>EPOLLIN 可读</li><li>EPOLOUT 可写</li><li>EPOLLERR 有错误<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>        * ptr; <span class="comment">// 复杂</span></span><br><span class="line">  <span class="keyword">int</span>          fd; <span class="comment">// 简单，让该值和epoll_ctl的fd参数一致就好</span></span><br><span class="line">  <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">  <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>     events;      <span class="comment">// Epoll events</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;        <span class="comment">// User data variable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><ul><li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></li><li>检测函数</li><li>参数:<ul><li>epfd: epoll_create的返回值, 通过这个值就可以找到红黑树</li><li>events: 传出参数, 保存了发生变化的文件描述符的信息</li><li>maxevents: 第二个参数结构体数组的大小</li><li>timeout: 阻塞时间<ul><li>0: 不阻塞</li><li>-1: 一直阻塞, 知道检测的fd有状态变化, 解除阻塞</li><li>&gt;0: 阻塞的时长(毫秒)</li></ul></li></ul></li><li>返回值:<ul><li>成功: 有多少个文件描述符状态发生了变化 &gt; 0</li><li>失败: -1</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll树</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听lfd添加到树上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="comment">// 检测事件的初始化</span></span><br><span class="line">    ev.events = EPOLLIN ;</span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">    <span class="comment">// 开始检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nums = epoll_wait(epfd, events, <span class="keyword">sizeof</span>(events)/<span class="keyword">sizeof</span>(events[<span class="number">0</span>]), <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;numbers = %d\n&quot;</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历状态变化的文件描述符集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">// 有新连接</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clisock</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(clisock);</span><br><span class="line">                <span class="keyword">int</span> connfd = accept(lfd, (struct sockaddr*)&amp;clisock, &amp;len);</span><br><span class="line">                <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将通信的fd挂到树上</span></span><br><span class="line">                <span class="comment">//ev.events = EPOLLIN | EPOLLOUT;</span></span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd  = connfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通信</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 读事件触发, 写事件触发</span></span><br><span class="line">                <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="keyword">int</span> count = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client disconnect ...\n&quot;</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                    <span class="comment">// 从树上删除该节点</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 正常情况</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LT工作模式"><a href="#LT工作模式" class="headerlink" title="LT工作模式"></a>LT工作模式</h3><blockquote><p>LT(level triggered)是默认的工作方式，并且同时支持block和no-block socket，在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p></blockquote><ul><li>委托内核检测可读，读缓冲区有数据，epoll会通知用户<ul><li>用户不读，继续通知</li><li>读一部分，继续通知</li><li>读完，不再通知</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll树</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听lfd添加到树上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="comment">// 检测事件的初始化</span></span><br><span class="line">    ev.events = EPOLLIN ;</span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">    <span class="comment">// 开始检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nums = epoll_wait(epfd, events, <span class="keyword">sizeof</span>(events)/<span class="keyword">sizeof</span>(events[<span class="number">0</span>]), <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;numbers = %d\n&quot;</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历状态变化的文件描述符集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">// 有新连接</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clisock</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(clisock);</span><br><span class="line">                <span class="keyword">int</span> connfd = accept(lfd, (struct sockaddr*)&amp;clisock, &amp;len);</span><br><span class="line">                <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将通信的fd挂到树上</span></span><br><span class="line">                <span class="comment">//ev.events = EPOLLIN | EPOLLOUT;</span></span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd  = connfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通信</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 读事件触发, 写事件触发</span></span><br><span class="line">                <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">int</span> count = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client disconnect ...\n&quot;</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                    <span class="comment">// 从树上删除该节点</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 正常情况</span></span><br><span class="line">                    <span class="comment">//printf(&quot;client say: %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, count);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ET工作模式"><a href="#ET工作模式" class="headerlink" title="ET工作模式"></a>ET工作模式</h3><blockquote><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></blockquote><ul><li>委托内核检测可读，读缓冲区有数据，epoll会通知用户<ul><li>如果读缓冲区没有再新来数据，不会再通知</li><li>如果有新来数据，通知用户，但如果上一次的没读完，会从上一次剩下的开始读</li></ul></li></ul><h4 id="设置边沿模式"><a href="#设置边沿模式" class="headerlink" title="设置边沿模式"></a>设置边沿模式</h4><ul><li>需要修改事件属性：EPOLLET</li></ul><h4 id="设置文件描述符非阻塞"><a href="#设置文件描述符非阻塞" class="headerlink" title="设置文件描述符非阻塞"></a>设置文件描述符非阻塞</h4><ul><li>int flag = fcntl(fd, F_GETFL);</li><li>flag = flag | O_NONBLOCK;</li><li>fcntl(fd, F_SETFL, flag);</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 绑定 ip, port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll树</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听lfd添加到树上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="comment">// 检测事件的初始化</span></span><br><span class="line">    ev.events = EPOLLIN ;</span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">    <span class="comment">// 开始检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nums = epoll_wait(epfd, events, <span class="keyword">sizeof</span>(events)/<span class="keyword">sizeof</span>(events[<span class="number">0</span>]), <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;numbers = %d\n&quot;</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历状态变化的文件描述符集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">// 有新连接</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clisock</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(clisock);</span><br><span class="line">                <span class="keyword">int</span> connfd = accept(lfd, (struct sockaddr*)&amp;clisock, &amp;len);</span><br><span class="line">                <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将通信的fd挂到树上</span></span><br><span class="line">                <span class="comment">//ev.events = EPOLLIN | EPOLLOUT;</span></span><br><span class="line">                <span class="comment">// 设置为边沿触发</span></span><br><span class="line">                <span class="comment">// 设置fd属性为非阻塞</span></span><br><span class="line">                <span class="keyword">int</span> flag = fcntl(connfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(connfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd  = connfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通信</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 读事件触发, 写事件触发</span></span><br><span class="line">                <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (count = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>)<span class="comment">// 因为要循环读完数据，所以才要设置非阻塞，要不就因为读完数据阻塞在这了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 处理read数据</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, count);</span><br><span class="line">                    <span class="comment">// 直接发送回客户端</span></span><br><span class="line">                    write(curfd, buf, count);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client disconnect...\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN)<span class="comment">// fd非阻塞，缓冲区没有数据也会再去读，会产生EAGAIN错误，这时候代表数据读完了</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;date over....\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口复用</title>
      <link href="2020/04/09/C++/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"/>
      <url>2020/04/09/C++/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>有可能server程序终止了，但端口还处于TIME_WAIT状态，再次启动server会提示端口占用</p><p>端口复用最常用的用途是:</p><ul><li>防止服务器重启时之前绑定的端口还未释放</li><li>程序突然退出而系统没有释放端口</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>函数是设置socket属性用的，这里用来设置端口复用</li><li>端口复用设置的时机: 服务器绑定端口之前，设置端口复用</li><li>参数:<ul><li>sockfd: 要操作的文件描述符</li><li>level: 级别 -&gt; SOL_SOCKET (端口复用的级别)</li><li>optname: 端口复用的级别(二选一)<ul><li>SO_REUSEADDR</li><li>SO_REUSEPORT</li></ul></li><li>optval: 端口复用-&gt; 对应的是整形数<ul><li>1: 可以复用</li><li>0: 不能复用</li></ul></li><li>optlen: optval参数对应的内存大小</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP状态转换</title>
      <link href="2020/04/09/C++/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/"/>
      <url>2020/04/09/C++/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><ul><li><p>三次握手之前:</p><ul><li>服务器端:<ul><li>先启动, 并设置监听 -&gt; listen()<ul><li>状态: LISTEN</li></ul></li></ul></li></ul></li><li><p>三次握手开始:</p><ul><li>第一次握手:<ul><li>客户端调用 connect() 函数, 状态: SYN_SENT</li></ul></li><li>第二次握手:<ul><li>服务器端接受连接请求, 状态: SYN_RCVD</li><li>客户端: 连接请求被接受, 状态: ESTABLISHED</li></ul></li><li>第三次握手:<ul><li>服务器的的连接请求被客户端接受: 状态: ESTABLISHED</li><li>通信的双方必须都变成: ESTABLISHED 状态之后才可以正常通信.</li></ul></li></ul></li><li><p>四次挥手:</p><ul><li>第一次挥手:<ul><li>主动断开连接的一方:<ul><li>调用了 close() 函数: 状态: FIN_WAIT_1</li></ul></li><li>被动断开连接的一方:<ul><li>状态: CLOSE_WAIT</li></ul></li></ul></li><li>第二次挥手:<ul><li>主动断开连接的一方:<ul><li>状态: FIN_WAIT_2</li></ul></li></ul></li><li>第三次挥手:<ul><li>被动断开连接的一方:<ul><li>调用函数 close(), 状态: LAST_ACK<br>主- 动断开连接的一方:</li><li>状态: TIME_WAIT</li></ul></li></ul></li><li>第四次挥手:<ul><li>当被动接受连接的一方, 收到, 主动断开连接一方的ACK之后, 就死了</li></ul></li></ul></li></ul><p><img src="/photo/tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="tcp状态转换" loading="lazy"></p><p><img src="/photo/tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A22.png" alt="tcp状态转换2" loading="lazy"></p><h2 id="2msl-Maximum-Segment-Lifetime"><a href="#2msl-Maximum-Segment-Lifetime" class="headerlink" title="2msl(Maximum Segment Lifetime)"></a>2msl(Maximum Segment Lifetime)</h2><ul><li>TIME_WAIT状态会持续2msl，以保证对方能够收到自己的ACK信息</li><li>msl官方建议2分钟，实际30秒</li></ul><h2 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h2><ul><li>A发送FIN，B回应ACK但没有发送FIN，则A处于半连接，可以接收但不能发送</li><li>即A调用close()，但B没有，此时A可读，B可读可写</li></ul><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><ul><li>半关闭函数</li><li>include &lt;sys/socket.h&gt;</li><li><code>int shutdown(int sockfd, int how);</code><ul><li>sockfd: 要操作的文件描述符</li><li>how: 操作方式<ul><li>SHUT_RD: 关闭读</li><li>SHUT_WR: 关闭写</li><li>SHUT_RDWR: 关闭读写</li></ul></li></ul></li></ul><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><ul><li>shell命令，一般参数使用anp，可以查看网络状态</li><li>a (all)显示所有选项，默认不显示LISTEN相关</li><li>p 显示建立相关链接的程序名</li><li>n 拒绝显示别名，能显示数字的全部转化成数字。</li><li>l 仅列出有在 Listen (监听) 的服务状态</li><li>t (tcp)仅显示tcp相关选项</li><li>u (udp)仅显示udp相关选项</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP并发通信</title>
      <link href="2020/04/08/C++/TCP%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1/"/>
      <url>2020/04/08/C++/TCP%E5%B9%B6%E5%8F%91%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ul><li>父进程：等待并接受连接请求</li><li>子进程：通信，接收一个请求创建一个子进程<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号捕捉的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleChild</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, wnohang);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child process 都死了&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child process 都还活着...&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="keyword">int</span> lfd = socket();</span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line">bind(lfd, ip, port);</span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">listen(lfd, block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置信号捕捉</span></span><br><span class="line">sigaction();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 等待并接受连接请求</span></span><br><span class="line"><span class="keyword">int</span> cfd = accept(lfd, addr, len);</span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 子进程</span></span><br><span class="line"><span class="comment">// 通信 -&gt; 循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">int</span> ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 客户端断开连接</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 没有任何异常, 回复客户端</span></span><br><span class="line">write();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 杀死这个子进程</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号捕捉函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleChild</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 资源回收</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有的子进程回收完毕!!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;剩下的子进程都还活着!!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);   <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册新号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = recycleChild;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrCli</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(addrCli);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;正在焦急等待客户端的连接...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> connfd = accept(fd, (struct sockaddr*)&amp;addrCli, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)<span class="comment">//如果在accept阻塞时，SIGCHLD信号发来，父进程去回收子进程回来后就不会继续阻塞而是返回-1，并设置errno</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功和客户端建立了连接</span></span><br><span class="line">        <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 读数据</span></span><br><span class="line">                <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">                <span class="keyword">int</span> ret = read(connfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 打印客户端地址信息</span></span><br><span class="line">                    <span class="keyword">char</span> ip[<span class="number">32</span>];</span><br><span class="line">                    inet_ntop(AF_INET, &amp;addrCli.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client IP: %s, Port: %d\n&quot;</span>, ip, ntohs(addrCli.sin_port));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端说: %s\n&quot;</span>, recvBuf);</span><br><span class="line">                    <span class="comment">// 写数据</span></span><br><span class="line">                    <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;你好, 客户端 - %d\n&quot;</span>, num++);</span><br><span class="line">                    write(connfd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            close(connfd);  <span class="comment">// 通信</span></span><br><span class="line">            <span class="comment">// 退出当前子进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>和多进程是类似的</li><li>回收子线程不能用join，该函数是阻塞的，应该使用线程分离</li></ul><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子线程处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">working</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 和建立连接的客户端通信</span></span><br><span class="line"><span class="keyword">int</span> ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">write(fd, data, <span class="built_in">strlen</span>(data)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line"><span class="keyword">int</span> lfd = socket();</span><br><span class="line"><span class="comment">// 2. 绑定</span></span><br><span class="line">bind(lfd, addr, len);</span><br><span class="line"><span class="comment">// 3. 监听</span></span><br><span class="line">listen(lfd, block);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 4. 等待并接受连接请求</span></span><br><span class="line"><span class="keyword">int</span> cfd = accept(lfd, addr, len);</span><br><span class="line"><span class="comment">// 5. 创建子线程</span></span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, working, arg);</span><br><span class="line">pthread_detach(&amp;tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;  <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>    <span class="comment">// 地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span> <span class="title">infos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">working</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">info</span> =</span> (struct SockInfo*)arg;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> ret = read(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经关闭连接...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收数据失败...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            write(info-&gt;fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);   <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="keyword">sizeof</span>(infos) / <span class="keyword">sizeof</span>(infos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;infos[i], <span class="keyword">sizeof</span>(infos[i]));</span><br><span class="line">        infos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        infos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111111111\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程监听, 子进程通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, infos[i].fd);</span><br><span class="line">            <span class="keyword">if</span>(infos[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pinfo = &amp;infos[i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> connfd = accept(fd, (struct sockaddr*)&amp;pinfo-&gt;addr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent thread, connfd: %d\n&quot;</span>, connfd);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = connfd;</span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="2020/04/08/C++/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>2020/04/08/C++/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><blockquote><p>滑动窗口是TCP中用于实现诸如ACK确认，流量控制，拥塞控制的承载结构。</p><p>窗口可以理解为缓存，滑动是指缓存中的数据量是变化的。</p><p>通信双方都有两个滑动窗口：发送窗口，接收窗口。</p></blockquote><ul><li>单向数据发送图示<ul><li>白色格子：空闲的空间</li><li>灰色格子：数据已经被发送出去，但还没被接收</li><li>发送端紫色：还没有发送出去的数据</li><li>接收端紫色：已经接收的数据</li></ul></li></ul><p><img src="/photo/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="滑动窗口" loading="lazy"></p><ul><li>TCP通信过程<ul><li>mss：最大的数据段大小，一条数据的最大数据量</li><li>win：滑动窗口空闲空间</li></ul></li></ul><p><img src="/photo/tcp%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="tcp通信过程" loading="lazy"></p><ol><li>客户端向服务器发起连接, 客户端的滑动窗口大小为4096, 一次发送的最大数据量1460</li><li>服务器接收连接请求(第二次握手), 告诉客户端服务器的滑动窗口大小为6144, 一次发送的最大数据量1024</li><li>第三次握手</li><li>4-9 客户端连续给服务器发送了 6k数据, 每次发送1k</li><li>第10次, 服务器告诉客户端: 发送的6k数据已经收到存储到滑动窗口缓存中, 缓存数据已经处理了2k</li><li>第11次, 服务器告诉客户端: 发送的6k数据已经收到存储到滑动窗口缓存中, 缓存数据已经处理了4k</li><li>第12次, 客户端给服务器发送1k数据</li><li>第13次, 主动请求和服务器断开连接, 并且给服务器发送了1k数据</li><li>第14次, 服务器回复ACK8194, a: 同意断开连接的请求 b: 告诉客户端我已经收到刚才2k数据 c: 滑动窗口2k</li><li>第15, 16次, 通知客户端滑动窗口中的数据处理完了</li><li>第17次, 服务器给客户端发送FIN, 断开和客户端的连接</li><li>第18次, 客户端同意了服务器的断开请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三握四挥</title>
      <link href="2020/04/08/C++/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/"/>
      <url>2020/04/08/C++/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="/photo/tcp.png" alt="tcp" loading="lazy"></p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ul><li>第一次握手:<ol><li>客户端将SYN标志位赋值为1</li><li>生成一个随机的32位序号</li><li>这个序号后边是可以携带数据的 (数据大小)</li></ol></li><li>第二次握手:<ol><li>服务器接收客户端的连接: ACK=1</li><li>服务器会回发一个确认序号: ack=随机序号+数据长度+SYN标志位(按一个字节算)</li><li>服务器会向客户端发起连接请求: SYN=1</li><li>服务器会生成一个随机序号: seq=k</li></ol></li><li>第三次握手:<ol><li>客户端答应服务器的连接请求: ACK=1</li><li>客户端回复收到了服务器的数据: ack=服务器的随机序号+数据长度+SYN(按一个字节算)</li></ol></li></ul><p><img src="/photo/%E6%8F%A1%E6%89%8B.png" alt="握手" loading="lazy"></p><ul><li>SYN: 建立连接的请求</li><li>ACK: 同意</li><li>seq/Seq: 随机生成的32位的序号</li><li>ack/Ack: 32位确认序号，确认上一次的数据已经接收了多少</li></ul><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><ul><li>由先close的一方发起</li><li>FIN: 断开连接的请求</li></ul><p><img src="/photo/%E6%8C%A5%E6%89%8B.png" alt="挥手" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="2020/04/07/C++/socket/"/>
      <url>2020/04/07/C++/socket/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><blockquote><p>Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。其目的是将TCP/IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。与套接字相关的函数被包含在头文件sys/socket.h中。<br>Socket是一套通信接口，linux和windows都可以使用，但是又细微差别。</p></blockquote><p><img src="/photo/socket.png" alt="socket" loading="lazy"></p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><blockquote><p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编/译码从而导致通信失败。<br>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)<br>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian 和 Little-Endian，下面先从字节序说起。、</p></blockquote><ul><li><p>用两个4字节十六进制数举例</p><ul><li>0x12345678</li><li>0x11223344</li></ul></li><li><p>大端（网络字节序）<br><img src="/photo/big.png" alt="big" loading="lazy"></p></li><li><p>小端（主机字节序）<br><img src="/photo/little.png" alt="little" loading="lazy"></p></li><li><p>端口转换函数</p><ul><li><code>uint16_t htons(uint16_t hostshort);</code></li><li><code>uint16_t ntohs(uint16_t netshort);</code></li></ul></li><li><p>IP转换函数</p><ul><li><code>uint32_t htonl(uint32_t hostlong);</code></li><li><code>uint32_t ntohl(uint32_t netlong);</code></li></ul></li></ul><h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><ul><li>include &lt;arpa/inet.h&gt;</li><li><code>int inet_pton(int af, const char *src, void *dst);</code><ul><li>点分字符串转整型数</li><li>参数<ul><li>af：地址族协议（AF_INET, AF_INET6）</li><li>src：点分十进制字符串</li><li>dst：传出参数，内存地址</li></ul></li><li>返回值：<ul><li>1：成功</li><li>-1：失败</li><li>0：不包含表示指定地址族中有效网络地址的字符串</li></ul></li></ul></li><li><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code><ul><li>整型数转点分十进制字符串</li><li>参数<ul><li>af：地址族协议（AF_INET, AF_INET6）</li><li>src：整型数IP地址</li><li>dst：传出参数，内存地址</li><li>size：修饰dst大小</li></ul></li><li>返回值<ul><li>NULL：失败</li><li>非空指针：指向dst，成功</li></ul></li></ul></li></ul><h2 id="sockaddr"><a href="#sockaddr" class="headerlink" title="sockaddr"></a>sockaddr</h2><ul><li>前两个是一样的，只不过第二个不需要自己偏移指针了</li><li>第三个是本地套接字用的</li><li>第四个是IPV6用的</li></ul><p><img src="/photo/sockaddr.png" alt="sockaddr" loading="lazy"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;<span class="comment">// 地址族协议, ipv4, ipv6</span></span><br><span class="line"><span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>    <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">// __SOCKADDR_COMMON(sin_)</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;         <span class="comment">// Port number.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">// Internet address.</span></span><br><span class="line">    <span class="comment">// Pad to size of &#x27;struct sockaddr&#x27;.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[`<span class="keyword">sizeof</span>(struct sockaddr)-__SOCKADDR_COMMON_SIZE-<span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>)-<span class="keyword">sizeof</span> (struct in_addr)`];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h2 id="套接字函数"><a href="#套接字函数" class="headerlink" title="套接字函数"></a>套接字函数</h2><ul><li>include &lt;sys/types.h&gt;</li><li>include &lt;sys/socket.h&gt;</li><li>include &lt;arpa/inet.h&gt;     包含这个头文件, 上边的两个就可以不写了</li></ul><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><ul><li><code>int socket(int domain, int type, int protocol);</code></li><li>创建一个套接字</li><li>参数<ul><li>domain: 地址族协议<br>  AF_INET: ipv4<br>  AF_INET6: ipv6<br>  AF_UNIX, AF_LOCAL: 进行本地套接字通信(进程间通信)</li><li>type: 通信过程中使用的协议<br>  SOCK_STREAM: 流式协议<br>  SOCK_DGRAM: 报式协议</li><li>protocol: 一般写0<ul><li>SOCK_STREAM: 流式协议默认使用使用: tcp</li><li>SOCK_DGRAM: 报式协议默认使用使用: udp</li></ul></li></ul></li><li>返回值：这个文件描述符操作的是内核缓冲区<ul><li>成功: 文件描述符</li><li>失败: -1</li></ul></li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul><li><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></li><li>为文件描述符绑定IP和端口</li><li>sockfd: 通过socket函数得到的</li><li>addr: 需要将IP和Port初始化到这个结构体中</li><li>addrlen: 第二个参数结构体占的内存大小</li></ul><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><ul><li><code>int listen(int sockfd, int backlog);</code></li><li>设置监听</li><li>sockfd: 通过socket函数得到的</li><li>backlog: 定义sockfd的挂起连接队列可以达到的最大长度，指定的数值不能大于/proc/sys/net/core/somaxconn中存储的数据，默认为128</li></ul><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><ul><li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></li><li>得到一个用于通信的文件描述符，函数默认阻塞</li><li>参数:<ul><li>sockfd: 用于监听的文件描述符(套接字)</li><li>addr: 传出参数, 记录了连接成功的客户端的IP和端口信息</li><li>addrlen: 第二个参数结构体对应的内存大小</li></ul></li><li>返回值:<ul><li>成功: 通信的文件描述符</li><li>失败: -1</li></ul></li></ul><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><ul><li><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></li><li>客户端使用该函数连接服务器</li><li>参数:<ul><li>sockfd: 用于通信的文件描述符</li><li>addr: 客户端要连接的服务器的地址信息</li><li>addrlen: 第二个参数结构体占的内存大小</li></ul></li><li>返回值:<br>  连接成功: 0<br>  连接失败: -1</li></ul><p><img src="/photo/socket%E9%80%9A%E4%BF%A1.png" alt="socket通信" loading="lazy"></p><h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><p><img src="/photo/tcp%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png" alt="tcp通信流程" loading="lazy"></p><ul><li>服务端<ol><li>创建一个用于监听的套接字<ul><li>监听: 监听有客户的连接</li><li>套接字: 这个套接字是一个文件描述符</li></ul></li><li>将这个监听文件描述符和本地的IP和端口绑定  (IP和端口 == 服务器地址信息)<ul><li>客户端连接服务器的时候使用的就是这个IP和端口</li></ul></li><li>设置监听, 监听的fd开始工作</li><li>阻塞等待, 当有客户端发起连接, 解除阻塞, 接受客户端的连接, 会得到一个用户通信的套接字(fd)</li><li>通信<ul><li>接收数据</li><li>发送数据</li></ul></li><li>通信结束, 断开连接</li></ol></li><li>客户端<ol><li>创建一个用于通信的套接字 (fd)</li><li>连接服务器, 需要指定连接的服务器的 IP 和 Port</li><li>连接成功, 客户端可以直接和服务通信<ul><li>接收数据</li><li>发送数据</li></ul></li><li>断开连接</li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>服务端<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);   <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    <span class="comment">//inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrCli</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(addrCli);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(fd, (struct sockaddr*)&amp;addrCli, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(connfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        write(connfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line">    close(connfd);  <span class="comment">// 通信</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>客户端<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;  <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data: %d\n&quot;</span>, i++);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>); <span class="comment">//+1多读个0结束字符串避免乱码</span></span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议</title>
      <link href="2020/04/07/C++/%E5%8D%8F%E8%AE%AE/"/>
      <url>2020/04/07/C++/%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="网络设计模式"><a href="#网络设计模式" class="headerlink" title="网络设计模式"></a>网络设计模式</h2><h3 id="B-S"><a href="#B-S" class="headerlink" title="B/S"></a>B/S</h3><ul><li>优势：跨平台，开发成本低</li><li>劣势：<ul><li>协议是固定的：http/https</li><li>不能处理数据量大的数据，因为不能操作文件，数据只能通过网络获取</li></ul></li></ul><h3 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h3><ul><li>优势：可以处理数据量大的磁盘数据</li><li>劣势：如果跨平台，开发成本高</li></ul><h2 id="IP和端口"><a href="#IP和端口" class="headerlink" title="IP和端口"></a>IP和端口</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><ul><li>ipv4<ul><li>实质为32位整型数</li><li>可以有2^32 - 1个</li></ul></li><li>ipv6<ul><li>实质是一个128位整数</li><li>格式：xxx:xxx:xxx:xxx:xxx:xxx:xxx:xxx每一部分以16进制表示，占16bits</li><li>可以有2^128 - 1个<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3></li></ul></li><li>端口号是unsigned short int型，16位整数</li><li>取值范围：0 - 65535</li></ul><h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><ul><li>OSI：开放式系统互联</li><li>ISO：国际标准化组织<br><img src="/photo/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="网络分层模型" loading="lazy"></li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><ul><li>面向连接的，安全的（数据不会丢失），流式传输协议<br><img src="/photo/tcp.png" alt="tcp" loading="lazy"></li></ul><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><ul><li>面向无连接的，不安全的（数据会丢失），报式传输协议<br><img src="/photo/udp.png" alt="udp" loading="lazy"></li></ul><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p><img src="/photo/ip.png" alt="ip" loading="lazy"></p><h3 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h3><p><img src="/photo/mac.png" alt="mac" loading="lazy"></p><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><p><img src="/photo/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85.png" alt="网络数据封装" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="2020/04/04/C++/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>2020/04/04/C++/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h3><ul><li>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作。</li><li>在多个线程操作一块共享数据的时候，按照先后顺序依次访问，并行变为串行。</li></ul><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><ul><li>一次只允许一个线程使用的资源。</li></ul><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul><li>一个访问共用资源的程序片段，而这些共用资源又无法同时被多个线程访问，这个区域称之为临界区。当有线程进入临界区段时，其他线程或必须等待，以确保这些共用资源是被互斥使用的。</li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ul><li><code>#include &lt;pthread.h&gt;</code></li></ul><h3 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h3><ul><li>初始化互斥锁</li><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li><li>mutex: 互斥锁的地址</li><li>attr: 互相锁的属性, 使用默认属性, 赋值为NULL就可以</li></ul><h3 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy"></a>pthread_mutex_destroy</h3><ul><li>释放互斥锁资源</li><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li></ul><h3 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h3><ul><li>加锁，如果是锁上的会阻塞</li><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li></ul><h3 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock"></a>pthread_mutex_trylock</h3><ul><li>加锁，如果是锁上的不会阻塞，函数直接返回</li><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li></ul><h3 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a>pthread_mutex_unlock</h3><ul><li>解锁</li><li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">funcA_num</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> cur = number;</span><br><span class="line">        <span class="keyword">int</span> a = cur;</span><br><span class="line">        <span class="keyword">int</span> b = a;</span><br><span class="line">        <span class="keyword">int</span> c = b;</span><br><span class="line">        a++;</span><br><span class="line">        b = a;</span><br><span class="line">        b++;</span><br><span class="line">        c = b;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        c--;</span><br><span class="line">        cur = c;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">funcB_num</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥锁资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>忘记释放锁</li><li>单线程重复加锁</li><li>多线程多锁<br><img src="/photo/%E6%AD%BB%E9%94%81.png" alt="死锁" loading="lazy"></li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul><li><code>#include &lt;pthread.h&gt;</code></li><li>读操作可以并行</li><li>写操作独占资源</li><li>写的优先级高于读</li><li>使用场景<ol><li>线程A加读锁成功, 又来了三个线程, 做读操作, 可以加锁成功</li><li>线程A加写锁成功, 又来了三个线程, 做读操作, 三个线程阻塞</li><li>线程A加读锁成功, 又来了B线程加写锁阻塞, 又来了C线程加读锁阻塞<ul><li>这就是加读锁的意义，不防止别人读，防止别人写</li></ul></li></ol></li><li>当读频率高时适用读写锁</li></ul><h3 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a>pthread_rwlock_init</h3><ul><li>初始化读写锁</li><li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li><li>rwlock: 读写锁地址</li><li>attr: 读写锁属性, 使用默认属性, 设置为: NULL</li></ul><h3 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a>pthread_rwlock_destroy</h3><ul><li>释放读写锁资源</li><li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></li></ul><h3 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h3><ul><li>加读锁</li><li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li></ul><h3 id="pthread-rwlock-tryrdlock"><a href="#pthread-rwlock-tryrdlock" class="headerlink" title="pthread_rwlock_tryrdlock"></a>pthread_rwlock_tryrdlock</h3><ul><li>尝试加读锁</li><li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li></ul><h3 id="pthread-rwlock-wrlock"><a href="#pthread-rwlock-wrlock" class="headerlink" title="pthread_rwlock_wrlock"></a>pthread_rwlock_wrlock</h3><ul><li>加写锁</li><li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li></ul><h3 id="pthread-rwlock-trywrlock"><a href="#pthread-rwlock-trywrlock" class="headerlink" title="pthread_rwlock_trywrlock"></a>pthread_rwlock_trywrlock</h3><ul><li>尝试加写锁</li><li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li></ul><h3 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a>pthread_rwlock_unlock</h3><ul><li>解锁</li><li><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">writeNum</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        number++;</span><br><span class="line"><span class="comment">//        usleep(100);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++ write, tid: %ld, number: %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">readNum</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=== read, tid: %ld, number: %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> wtid[<span class="number">3</span>], rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建写的线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建读的线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件变量-主要看代码"><a href="#条件变量-主要看代码" class="headerlink" title="条件变量(主要看代码)"></a>条件变量(主要看代码)</h2><ul><li><code>#include &lt;pthread.h&gt;</code></li><li>条件变量不是锁</li><li>条件变量能引起或解除某个线程的阻塞</li><li>需要配合互斥锁解决数据共享问题</li></ul><h3 id="pthread-cond-init"><a href="#pthread-cond-init" class="headerlink" title="pthread_cond_init"></a>pthread_cond_init</h3><ul><li>初始化条件变量</li><li><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li><li>cond: 条件变量的地址</li><li>attr: 使用默认属性, 这个值设置为NULL</li></ul><h3 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy"></a>pthread_cond_destroy</h3><ul><li>释放资源</li><li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li></ul><h3 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a>pthread_cond_wait</h3><ul><li>阻塞当前线程</li><li><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></li><li>cond: 条件变量</li><li>mutex: 互斥锁</li></ul><h3 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="pthread_cond_timedwait"></a>pthread_cond_timedwait</h3><ul><li>一段时间内阻塞当前线程</li><li><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></li><li>cond: 条件变量</li><li>mutex: 互斥锁</li><li>abstime: 阻塞的时间<ul><li>当前时间 + 要阻塞的时长</li></ul></li></ul><h3 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a>pthread_cond_signal</h3><ul><li>唤醒一个或多个被条件变量阻塞的线程</li><li><code>int pthread_cond_signal(pthread_cond_t *cond);</code></li></ul><h3 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast"></a>pthread_cond_broadcast</h3><ul><li>唤醒所有被条件变量阻塞的线程</li><li><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者、消费者、容器</span></span><br><span class="line"><span class="comment">// 生产者在链表中加节点，消费者在链表中删节点</span></span><br><span class="line"><span class="comment">// 消费者发现列表时空的，就调用cond_wait阻塞</span></span><br><span class="line"><span class="comment">// 生产者生产出来东西就解除消费者的阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向链表第一个节点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建新的链表节点</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, number: %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产者者生产了东西, 通知消费者消费</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        <span class="comment">//pthread_cond_broadcast(&amp;cond);</span></span><br><span class="line"><span class="comment">//        sleep(rand() % 3);</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">customer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建指针变量指向头结点</span></span><br><span class="line">        <span class="comment">// 判断头结点是不是为空</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)<span class="comment">//这里用if会段错误，必须得重复判定，方式其他线程消费空链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 链表为空, 不能删除, 线程阻塞</span></span><br><span class="line">            <span class="comment">// 假设线程阻塞在了这个函数上, 这个函数会给互斥锁解锁</span></span><br><span class="line">            <span class="comment">// 当线程从这个函数上解除阻塞, 会给这个互斥锁加锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ptid[<span class="number">5</span>], ctid[<span class="number">5</span>];</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建写的线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量-主要看代码"><a href="#信号量-主要看代码" class="headerlink" title="信号量(主要看代码)"></a>信号量(主要看代码)</h2><ul><li><code>#include &lt;semaphore.h&gt;</code></li><li>信号量主要阻塞线程, 不能完全保证线程安全</li><li>如果要保证线程安全, 需要信号量和互斥锁一起使用</li></ul><h3 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h3><ul><li>初始化信号量</li><li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></li><li>sem: 信号量的地址</li><li>pshared: 0处理线程, 1处理进程</li><li>value: sem_t中整形数初始化</li></ul><h3 id="sem-destroy"><a href="#sem-destroy" class="headerlink" title="sem_destroy"></a>sem_destroy</h3><ul><li>释放资源</li><li><code>int sem_destroy(sem_t *sem);</code></li></ul><h3 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait"></a>sem_wait</h3><ul><li>如果sem中的数为0当前线程阻塞，否则sem中的数自减1</li><li><code>int sem_wait(sem_t *sem);</code></li></ul><h3 id="sem-trywait"><a href="#sem-trywait" class="headerlink" title="sem_trywait"></a>sem_trywait</h3><ul><li>数为0不阻塞，函数返回</li><li><code>int sem_trywait(sem_t *sem);</code></li></ul><h3 id="sem-timedwait"><a href="#sem-timedwait" class="headerlink" title="sem_timedwait"></a>sem_timedwait</h3><ul><li>数为0阻塞一定时间</li><li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></li></ul><h3 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h3><ul><li>sem中的数自增1</li><li><code>int sem_post(sem_t *sem);</code></li></ul><h3 id="sem-getvalue"><a href="#sem-getvalue" class="headerlink" title="sem_getvalue"></a>sem_getvalue</h3><ul><li>查看sem中的数，通过第二个参数返回</li><li><code>int sem_getvalue(sem_t *sem, int *sval);</code></li></ul><p><img src="/photo/sem.png" alt="sem" loading="lazy"></p><ul><li>这个图里，生产者只关心有多少空余车位，消费者关心有多少车在车位上</li><li>生产者开进去一台车，自己sval–，通知消费者，消费者sval++，通过sem做互相通知的操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过信号量实现的生产者消费者模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者的信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> csem;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向链表第一个节点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 创建新的链表节点</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, number: %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知消费者已经生产了一个</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">customer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建指针变量指向头结点</span></span><br><span class="line">        <span class="comment">// 判断头结点是不是为空</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ptid[<span class="number">5</span>], ctid[<span class="number">5</span>];</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建写的线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作函数</title>
      <link href="2020/04/03/C++/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>2020/04/03/C++/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="文件属性函数"><a href="#文件属性函数" class="headerlink" title="文件属性函数"></a>文件属性函数</h2><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><ul><li>判断文件权限, 或者文件是否存在</li><li><code>int access(const char *pathname, int mode);</code></li><li>参数:<ul><li>pathname: 文件名</li><li>mode:<ul><li>R_OK: 判断文件是不是有读权限</li><li>W_OK: 判断文件是不是有写权限</li><li>X_OK: 判断文件是不是有执行权限</li><li>F_OK: 判断当前文件是否存在</li></ul></li></ul></li><li>返回值:<ul><li>判断成功: 0, 失败: -1</li></ul></li></ul><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul><li>修改文件权限</li><li><code>int chmod(const char *filename, int mode);</code></li><li>filename: 要修改文件权限的文件的名字</li><li>mod: 八进制数</li></ul><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><ul><li>修改文件所有者</li><li><code>int chown(const char *path, uid_t owner, gid_t group);</code></li><li>path: 要修改的文件名</li><li>owner: 用户ID, stat /etc/passwd</li><li>group: 组ID, /etc/group</li></ul><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><ul><li>修改文件大小</li><li><code>int truncate(const char *path, off_t length);</code></li><li>path: 要操作的文件</li><li>length: 最终的文件大小</li></ul><h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><ul><li>文件重命名</li><li><code>int rename(const char *oldpath, const char *newpath);</code></li><li>oldpath: 旧的文件名</li><li>newpath: 新的文件名</li></ul><h3 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h3><ul><li>修改进程的工作目录</li><li><code>int chdir(const char *path);</code></li></ul><h3 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd"></a>getcwd</h3><ul><li>相当于pwd命令</li><li><code>char *getcwd(char *buf, size_t size);</code></li><li>参数:<ul><li>buf: 存储路径, 指向一个由内存大小的数组</li><li>size: 修饰buf大小</li></ul></li><li>返回值:<ul><li>指针指向一块内存, 这个内存就是第一个参数</li></ul></li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><ul><li>创建目录, 这个目录必须要有执行权限</li><li><code>int mkdir(const char *pathname, mode_t mode);</code></li><li>pathname: 目录名</li><li>mode: 目录的权限 mod &amp; ~umask</li></ul><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><ul><li>只能删除空目录</li><li><code>int rmdir(const char *pathname);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="2020/04/03/C++/%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/04/03/C++/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>线程是轻量级的进程（LWP:light weight process），linux下线程的本质仍是进程</p><p>进程是资源分配的最小单位，线程是操作系统执行调度的最小单位</p><p>多个子线程和父线程共用一个虚地址空间，内核会把线程当作进程，线程也会争抢cpu资源</p><p>安装线程man page：sudo apt-get install manpages-posix-dev</p></blockquote><h2 id="查看线程号"><a href="#查看线程号" class="headerlink" title="查看线程号"></a>查看线程号</h2><ul><li>ps -Lf</li><li>线程号是给内核看的</li></ul><h2 id="线程之间的共享和非共享资源"><a href="#线程之间的共享和非共享资源" class="headerlink" title="线程之间的共享和非共享资源"></a>线程之间的共享和非共享资源</h2><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><ul><li>文件描述符表</li><li>每种信号捕获的回调函数</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间（.text/.data/.bss/heap/共享库）<h3 id="非共享资源"><a href="#非共享资源" class="headerlink" title="非共享资源"></a>非共享资源</h3></li><li>线程ID（无符号长整型）</li><li>处理器现场和栈指针（内核栈）</li><li>独立的栈空间</li><li>errno变量</li><li>阻塞信号集</li><li>线程的优先级</li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li>程序中默认只有一个进程, fork -&gt; 2个进程</li><li>程序中默认只有一个进程, pthread_create -&gt; 得到2个线程, 父(主)线程[就是原来的进程], 子线程</li><li>include &lt;pthread.h&gt;</li><li>pthread_t 线程id的类型, 无符号长整形</li><li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void*), void *arg);</code></li><li>参数:<ul><li>thread: 传出参数, 线程创建成功之后, 子线程的线程ID被写到该变量中</li><li>attr: 设置线程属性, 一般使用默认值, NULL</li><li>start_routine: 函数指针, 这个函数就是子线程的处理逻辑</li><li>arg: 给第三个参数传参</li></ul></li><li>返回值:<ul><li>成功: 0, 失败: 错误号, 这个错误号和之前的errno不一样</li><li>打印错误信息: <code>char *strerror(int errnum);</code></li></ul></li><li>在编译程序的时候需要添加线程库的名字<code>gcc pthread_create.c -lpthread</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span>*)&amp;number);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* err = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_creat: %s\n&quot;</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid = %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="获取当前线程ID"><a href="#获取当前线程ID" class="headerlink" title="获取当前线程ID"></a>获取当前线程ID</h2><ul><li>include &lt;pthread.h&gt;</li><li><code>pthread_t pthread_self(void);</code></li></ul><h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><ul><li>当前线程退出, 不会影响其他线程的正常运行</li><li>include &lt;pthread.h&gt;</li><li><code>void pthread_exit(void *retval);</code></li><li>参数: retval, 线程退出时候的返回值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span>*)&amp;number);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* err = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_creat: %s\n&quot;</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid = %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="回收子线程资源"><a href="#回收子线程资源" class="headerlink" title="回收子线程资源"></a>回收子线程资源</h2><ul><li>include &lt;pthread.h&gt;</li><li>这是个阻塞函数, 调用一次回收一个子线程</li><li>这个函数在主线程(父线程)中使用</li><li>`int pthread_join(pthread_t thread, void **retval);``</li><li>thread: 要回收的子线程的线程ID</li><li>retval: 使用这个变量接收子线程退出的时候返回的值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    t.age  = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(t.name, <span class="string">&quot;Lilei&quot;</span>);</span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span>*)&amp;number);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* err = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_creat: %s\n&quot;</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid = %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">ptr</span>;</span></span><br><span class="line">    pthread_join(tid, (<span class="keyword">void</span>**)&amp;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age: %d, name: %s\n&quot;</span>, ptr-&gt;age, ptr-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><ul><li>如果设置了线程分离, 子线程结束之后, 对应的资源不需要父线程释放</li><li>如果设置了线程分离, 如果在调用 pthread_join 该函数会报错</li><li>include &lt;pthread.h&gt;</li><li><code>int pthread_detach(pthread_t thread);</code></li><li>thread: 子线程线程ID<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    t.age  = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(t.name, <span class="string">&quot;Lilei&quot;</span>);</span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span>*)&amp;number);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* err = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_creat: %s\n&quot;</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子线程创建成功, 设置线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid = %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><ul><li>在父线程(主线程)中调用了线程取消函数, 可以终止某个子线程的运行</li><li>该函数调用之后, 并不能马上终止子线程, 当子线程的处理函数运行到一个取消点的位置, 线程就终止了</li><li>如果没有取消点, 子线程是不会被终止的</li><li>取消点: 在程序中有从用户区到内核区的切换, 这个位置称之为取消点</li><li>include &lt;pthread.h&gt;</li><li><code>int pthread_cancel(pthread_t thread);</code></li><li>thread: 子线程的线程ID<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    t.age  = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(t.name, <span class="string">&quot;Lilei&quot;</span>);</span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span>*)&amp;number);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* err = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_creat: %s\n&quot;</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子线程创建成功, 设置线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid = %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="比较线程ID是否相同"><a href="#比较线程ID是否相同" class="headerlink" title="比较线程ID是否相同"></a>比较线程ID是否相同</h2><ul><li>在linux下线性ID - 无符号长整形</li><li>在不同的平台下, pthread_t封装有可能不同, 有些平台下pthread_t是一个结构体</li><li>include &lt;pthread.h&gt;</li><li>`int pthread_equal(pthread_t t1, pthread_t t2);``</li><li>返回值:相同非0, 不同0</li></ul><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><ul><li>需要属性的变量 -&gt; 对应一块内存</li><li>首先要申请一块内存, 并且初始化, 保存属性信息</li><li>当属性信息对应的变量使用完毕, 需要释放</li><li>线程属性类型：<code>pthread_attr_t t;</code></li><li>初始化：<code>int pthread_attr_init(pthread_attr_t *attr);</code></li><li>释放资源：<code>int pthread_attr_destroy(pthread_attr_t *attr);</code></li><li>通过设置属性实现线程分离<ul><li><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code><ul><li>detachstate:<ul><li>PTHREAD_CREATE_DETACHED: 设置线程分离</li><li>PTHREAD_CREATE_JOINABLE: 设置父子线程不分离<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span>*)arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    t.age  = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(t.name, <span class="string">&quot;Lilei&quot;</span>);</span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    pthread_exit(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span>*)&amp;number);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* err = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_creat: %s\n&quot;</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子线程创建成功, 设置线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid = %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>守护进程</title>
      <link href="2020/04/03/C++/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>2020/04/03/C++/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><blockquote><p>Daemon Process，又叫精灵进程，是linux中的后台服务进程，生存期较长，通常独立于控制终端并周期性的执行某种任务，或等待处理某些发生的事件，一般用d作为名字的结尾，比如mysqld，httpd…</p></blockquote><h2 id="守护进程的特点"><a href="#守护进程的特点" class="headerlink" title="守护进程的特点"></a>守护进程的特点</h2><ul><li>名字一般以d结尾</li><li>脱离终端，没有输入输出</li><li>周期性执行某些特定操作</li></ul><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><blockquote><p>一个及以上进程的集合，在linux中所有进程都属于一个进程组，默认父子进程在同一个进程组中</p></blockquote><ul><li>进程组的第一个进程就是组长</li><li>进程组ID和组长进程ID相同<h3 id="getgrp"><a href="#getgrp" class="headerlink" title="getgrp"></a>getgrp</h3></li><li><code>pid_t getgrp(void);</code></li><li>posix标准，获取当前进程所在进程组ID</li></ul><h3 id="getpgid"><a href="#getpgid" class="headerlink" title="getpgid"></a>getpgid</h3><ul><li><code>pid_t getpgid(pid_t pid);</code></li><li>bsd标准，获取指定进程所在进程组ID</li></ul><h3 id="setpgid"><a href="#setpgid" class="headerlink" title="setpgid"></a>setpgid</h3><ul><li><code>int setpgid(pid_t pid, pid_t pgid);</code></li><li>可以将一个进程送到另一个进程组</li><li>也可以创建一个新进程组，pgid = pid</li></ul><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><blockquote><p> 一个及以上进程组的集合</p></blockquote><ul><li>创建会话的注意事项<ul><li>该进程不能为进程组长</li><li>创建会话的进程成为新进程组组长</li><li>某些linux发行版需要root权限</li><li>创建出的新会话会丢弃原有控制终端</li><li>一般步骤：fork -&gt; 父进程死亡 -&gt; 子进程创建会话</li></ul></li></ul><h3 id="getsid"><a href="#getsid" class="headerlink" title="getsid"></a>getsid</h3><ul><li><code>pid_t getsid(pid_t pid);</code></li><li>include &lt;unistd.h&gt;</li><li>获取进程所在会话ID</li><li>成功返回会话ID，失败返回-1</li></ul><h3 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h3><ul><li><code>pid_t setsid(void);</code></li><li>include &lt;unistd.h&gt;</li><li>当前进程会被提升为会话，当前进程不能为进程组长</li><li>当前进程会脱离原控制终端</li></ul><h2 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h2><ol><li>父进程创建子进程，杀死父进程（必需）</li><li>将子进程提升为会话（必需）</li><li>修改进程工作目录，切换到不可卸载的目录中（非必需）<ul><li>chdir();</li><li>如果工作目录在u盘，是可以被卸载的</li></ul></li><li>修改umask掩码（非必需）<ul><li>umask();</li></ul></li><li>关闭或重定向文件描述符（非必需）<ul><li>关闭：close(0); close(1); close(2);</li><li>重定向：int fd = open(“/dev/null”,O_RDWR); dup2(0,fd); dup2(1,fd); dup2(2,fd);</li></ul></li><li>写核心操作流程（必需）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">working</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前系统时间</span></span><br><span class="line">    <span class="comment">// 得到了秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> tm = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 时间的转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">loc</span> =</span> localtime(&amp;tm);</span><br><span class="line">    <span class="comment">//char buf[1024];</span></span><br><span class="line">    <span class="comment">//sprintf(buf, &quot;%d-%d-%d %d:%d:%d&quot;, loc-&gt;tm_year, loc-&gt;tm_mon, loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// 通过函数格式化时间</span></span><br><span class="line">    <span class="keyword">char</span>* curTim = asctime(loc);</span><br><span class="line">    <span class="comment">// 写入到文件中</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;time.log&quot;</span>, O_WRONLY|O_CREAT|O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, curTim, <span class="built_in">strlen</span>(curTim));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子进程, 杀死父进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只剩下子进程 -&gt; 提升为会话</span></span><br><span class="line">    <span class="comment">// 脱离操作终端, 进程直接后台运行</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改进程的工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/robin&quot;</span>);</span><br><span class="line">    <span class="comment">// 修改掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line">    <span class="comment">// 重定向fd 0, 1, 2 -&gt; /dev/null</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心操作</span></span><br><span class="line">    <span class="comment">// 设置信号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>;</span></span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    newact.sa_handler = working;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 设置定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">myval</span>;</span></span><br><span class="line">    <span class="comment">// 第一次发信号倒计时</span></span><br><span class="line">    myval.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    myval.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置第一次以后的频率</span></span><br><span class="line">    myval.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    myval.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;myval, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止当前进程退出</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="2020/04/02/C++/%E4%BF%A1%E5%8F%B7/"/>
      <url>2020/04/02/C++/%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号的相关概念"><a href="#信号的相关概念" class="headerlink" title="信号的相关概念"></a>信号的相关概念</h2><h3 id="信号的特点"><a href="#信号的特点" class="headerlink" title="信号的特点"></a>信号的特点</h3><ul><li>简单</li><li>携带的信息量很少</li></ul><h3 id="linux中的信号"><a href="#linux中的信号" class="headerlink" title="linux中的信号"></a>linux中的信号</h3><ul><li>linux系统的消息机制</li><li>信号的优先级非常高</li><li>可以完成进程通信，但是没人这么用，会破坏程序完整性</li></ul><h3 id="产生信号的场景"><a href="#产生信号的场景" class="headerlink" title="产生信号的场景"></a>产生信号的场景</h3><ul><li>终端操作</li><li>shell命令</li><li>函数调用</li><li>硬件错误</li></ul><h3 id="查看系统定义信号列表"><a href="#查看系统定义信号列表" class="headerlink" title="查看系统定义信号列表"></a>查看系统定义信号列表</h3><ul><li><code>$ kill -l</code></li></ul><h3 id="查看信号详细信息"><a href="#查看信号详细信息" class="headerlink" title="查看信号详细信息"></a>查看信号详细信息</h3><ul><li><code>$ man 7 signal</code></li><li>进程收到信号的处理动作<ul><li>Term：终止进程</li><li>Ign：忽略</li><li>Core：终止进程并生成core文件（详情见gdb篇）</li><li>Stop：暂停进程</li><li>Cont：继续被暂停的进程</li></ul></li></ul><h3 id="信号状态"><a href="#信号状态" class="headerlink" title="信号状态"></a>信号状态</h3><ul><li>产生</li><li>未决（未被处理）<ul><li>阻塞时未决的一种特殊状态</li></ul></li><li>递达（已被处理）</li></ul><h2 id="信号的相关函数"><a href="#信号的相关函数" class="headerlink" title="信号的相关函数"></a>信号的相关函数</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><ul><li>通过这个函数给某个进程发送信号<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure></li><li>pid:<ul><li><blockquote><p>0: 将信号发送给指定的进程 -&gt; 最常用</p></blockquote></li><li>=0: 将信号发送给当前的进程组</li><li>-1: 将信号发送给每一个有权限接收这个信号的进程</li><li>&lt;1: 这个pid=某个进程组的ID取负</li></ul></li><li>sig: 要送的的信号(宏值/整数)</li></ul><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><ul><li>给当前进程发信号<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure></li><li>参数:<ul><li>sig: 要发送的信号</li></ul></li><li>返回值:<ul><li>成功: 0</li><li>失败: 非0</li></ul></li></ul><h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><ul><li>发送 SIGABRT 给当前进程, 杀死当前进程<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><ul><li>函数调用, 开始倒计时, 当倒计时为0的时候, 函数会给当前进程发送一个信号: SIGALRM</li><li>SIGALRM -&gt; 默认终止当前进程<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure></li><li>参数:<pre><code>- seconds: 倒计时有多长, 单位: 秒, 如果该参数为0: 定时器无效(不倒计时, 不发信号)</code></pre></li><li>返回值: 上一次alarm的剩余时间</li><li>取消alarm：alarm(0);</li></ul><h3 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h3><ul><li>可以实现周期性定时<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 7小时后起床[it_value], 闹钟每隔5分钟响一次[it_interval]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">// 第二次以及以后定时器每隔多长时间被触发一次, 频率</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">// 第一次触发定时器的时长, 倒计时的时长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总时间 = tv_sec + tv_usec</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="keyword">time_t</span>      tv_sec;         <span class="comment">// 秒</span></span><br><span class="line">  <span class="keyword">suseconds_t</span> tv_usec;        <span class="comment">// 微秒</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_val, struct itimerval *old_value)</span></span>;</span><br></pre></td></tr></table></figure></li><li>which: 定时器以什么时间计时<ul><li>ITIMER_REAL: 真实时间, 时间达到, 发送信号: SIGALRM -&gt; 常用</li><li>ITIMER_VIRTUAL: 用户时间, 时间达到, 发送信号: SIGVTALRM</li><li>ITIMER_PROF: 内核时间, 时间达到, 发送信号: SIGPROF</li></ul></li><li>new_val: 设置定时器的属性</li><li>old_value: 记录了上一次定时器设置的属性信息, 一般不使用, 指定为NULL<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myalarm</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号编号: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 定时器触发之后的逻辑</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxx---\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置一个定时器, 倒计时 5s -&gt; 定时器第一次触发</span></span><br><span class="line">    <span class="comment">// 第一次以后, 使用一定的频率触发该定时器: 2s</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">newVal</span>;</span></span><br><span class="line">    <span class="comment">// 设置倒计时时间</span></span><br><span class="line">    newVal.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">    newVal.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置定时器重复的频率</span></span><br><span class="line">    newVal.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    newVal.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该函数并不会阻塞</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;newVal, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 保证进程不退出</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><h3 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a>信号捕捉函数</h3><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><ul><li>signum: 要捕捉的信号</li><li>handler: 回调函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int型参数 -&gt; 捕捉到的信号的编号</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* <span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><ul><li>参数:<ul><li>signum: 要捕捉的信号</li><li>act: 捕捉到信号之后的处理动作</li><li>oldact: 上一次对信号捕捉的相关设置, 不使用-&gt; NULL</li></ul></li><li>返回值:<pre><code>- 成功: 0</code></pre><ul><li>失败: -1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// posix标准</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sa_flags = 0, 默认值, 使用: sa_handler</span></span><br><span class="line"><span class="comment">// sa_flags = SA_SIGINFO, 使用: sa_sigaction</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>     (* sa_handler)(<span class="keyword">int</span>);<span class="comment">// 函数指针, 指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">  <span class="keyword">void</span>     (* sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span>*, <span class="keyword">void</span>*);<span class="comment">// 不常用，信号通信的时候会用到</span></span><br><span class="line">  <span class="keyword">sigset_t</span>   sa_mask;<span class="comment">// 临时阻塞信号集, 在信号捕捉函数执行过程中, 临时阻塞某些信号</span></span><br><span class="line">  <span class="keyword">int</span>        sa_flags;<span class="comment">// 使用哪个函数指针进行捕捉到信号的处理动作</span></span><br><span class="line">  <span class="keyword">void</span>     (* sa_restorer)(<span class="keyword">void</span>);<span class="comment">// 被废弃了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myalarm</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号编号: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 定时器触发之后的逻辑</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxx---\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置一个定时器, 倒计时 5s -&gt; 定时器第一次触发</span></span><br><span class="line">    <span class="comment">// 第一次以后, 使用一定的频率触发该定时器: 2s</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">newVal</span>;</span></span><br><span class="line">    <span class="comment">// 设置倒计时时间</span></span><br><span class="line">    newVal.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">    newVal.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置定时器重复的频率</span></span><br><span class="line">    newVal.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    newVal.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">//signal(SIGALRM, myalarm);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该函数并不会阻塞</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;newVal, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 保证进程不退出</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="信号传参（不会这么用）"><a href="#信号传参（不会这么用）" class="headerlink" title="信号传参（不会这么用）"></a>信号传参（不会这么用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将信号发送到某个进程</span></span><br><span class="line">kill();</span><br><span class="line"><span class="comment">// 将信号发送到某个进程, 并传递一些额外的数据</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>   sival_int;<span class="comment">// 两个没有血缘关系的进程间通信</span></span><br><span class="line"><span class="keyword">void</span> * sival_ptr;<span class="comment">// 有血缘关系</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号捕捉 -&gt; sigaction</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);<span class="comment">// 函数指针, 指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line"><span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span>*, <span class="keyword">void</span>*);<span class="comment">// 不常用，void*就是通过信号传来的数据</span></span><br><span class="line"><span class="keyword">sigset_t</span>   sa_mask;<span class="comment">// 临时阻塞信号集, 在信号捕捉函数执行过程中, 临时阻塞某些信号</span></span><br><span class="line"><span class="keyword">int</span>        sa_flags;<span class="comment">// 使用哪个函数指针进行捕捉到信号的处理动作</span></span><br><span class="line"><span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);<span class="comment">// 被废弃了</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_flags = SA_SIGINFO;</span><br><span class="line">act.sa_sigaction = xxx;</span><br></pre></td></tr></table></figure><h3 id="内核实现信号捕捉的过程"><a href="#内核实现信号捕捉的过程" class="headerlink" title="内核实现信号捕捉的过程"></a>内核实现信号捕捉的过程</h3><p><img src="/photo/kernel.png" alt="kernel" loading="lazy"></p><h3 id="信号捕捉的特性"><a href="#信号捕捉的特性" class="headerlink" title="信号捕捉的特性"></a>信号捕捉的特性</h3><ol><li>进程正常运行时，默认PCB中有一个阻塞信号集，假定为 block_mask，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由 block_mask 来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为 block_mask。</li><li>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽，即这期间新来的XXX信号不影响函数执行<ul><li>act.sa_handler = myalarm;</li><li>在myalarm执行期间, 自动屏蔽2号信号, 不需要设置, 执行完成, 屏蔽解除</li><li>sigaction(2, &amp;act, NULL);</li></ul></li><li>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）。<ul><li>未决信号集中每个信号只有一标志位, 因此只能标记一次的状态 0, 1</li></ul></li></ol><h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><h3 id="阻塞-未决信号集"><a href="#阻塞-未决信号集" class="headerlink" title="阻塞/未决信号集"></a>阻塞/未决信号集</h3><ul><li>在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。对于阻塞信号集可以自定义另外一个集合，借助信号集操作函数来进行修改。</li><li>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</li><li>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</li><li>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。<br><img src="/photo/%E4%BF%A1%E5%8F%B7%E9%9B%86.png" alt="信号集" loading="lazy"></li></ul><ol><li>用户通过键盘 ctrl+c -&gt; 产生2号信号 sigint (信号被创建)</li><li>信号产生但是没有被处理 -&gt; 未决<ul><li>在内核中将所有没有被处理信号存储在一个表中 -&gt; 未决信号集</li><li>sigint信号状态被存储在 第二个标志位上<ul><li>这个标志位值 == 0, 这个信号不是未决状态</li><li>标志位 == 1, 这个信号处于未决状态</li></ul></li></ul></li><li>这个未决状态的信号, 需要被处理, 处理之前需要和另一个信号集(阻塞信号集)进行比较<ul><li>阻塞信号集中默认不阻塞任何信号</li><li>如果想阻塞某些信号需要用户设置的 -&gt; 调用系统的API</li></ul></li><li>在处理的时候和阻塞信号集中的这个标志位进行查询, 看是不是对该信号设置了阻塞<ul><li>如果设置了阻塞: 这个信号继续处于未决状态, 直到解除阻塞, 这个信号就被处理了</li><li>如果没有设置阻塞: 这个信号直接被处理掉了</li></ul></li></ol><h3 id="信号集相关函数"><a href="#信号集相关函数" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h3><ul><li><code>#include &lt;signal.h&gt;</code></li><li>前四个函数成功返回0，失败返回-1</li></ul><h4 id="sigemptyset"><a href="#sigemptyset" class="headerlink" title="sigemptyset"></a>sigemptyset</h4><ul><li><code>int sigemptyset(sigset_t *set);</code></li><li>信号集所有标志位置0</li><li>set：自定义的信号集</li></ul><h4 id="sigfillset"><a href="#sigfillset" class="headerlink" title="sigfillset"></a>sigfillset</h4><ul><li><code>int sigfillset(sigset_t *set);</code></li><li>信号集所有标志位置1</li></ul><h4 id="sigaddset"><a href="#sigaddset" class="headerlink" title="sigaddset"></a>sigaddset</h4><ul><li><code>int sigaddset(sigset_t *set, int signum);</code></li><li>添加阻塞信号</li><li>signum：要阻塞的信号</li></ul><h4 id="sigdelset"><a href="#sigdelset" class="headerlink" title="sigdelset"></a>sigdelset</h4><ul><li><code>int sigdelset(sigset_t *set, int signum);</code></li><li>取消某个信号的阻塞</li></ul><h4 id="sigismember"><a href="#sigismember" class="headerlink" title="sigismember"></a>sigismember</h4><ul><li><code>int sigismember(const sigset_t *set, int signum);</code></li><li>判断某个信号的值</li><li>返回值：<ul><li>1：已设置</li><li>0：未设置</li><li>-1：失败</li></ul></li></ul><h4 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask"></a>sigprocmask</h4><ul><li><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></li><li>将自定义信号集设置到内核中</li><li>修改的是内核的阻塞信号集</li><li>how: 如何对内核阻塞信号集进行处理<ul><li>SIG_BLOCK: 将用户设置的阻塞信息添加到内核中, 内核中原来的数据不变<ul><li>假设内核中默认的信号集mask, mask |= set</li></ul></li><li>SIG_UNBLOCK: 清除用户在内核中设置的数据</li><li>SIG_SETMASK: 覆盖内核中原来的值</li></ul></li><li>set: 已经初始化完成的自定义的阻塞信号集</li><li>oldset: 保存设置之前内核中阻塞信号集的状态<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建自定义信号集变量, 设置信号的阻塞</span></span><br><span class="line">    <span class="keyword">sigset_t</span> myset;</span><br><span class="line">    <span class="comment">// 初始化变量, 所有标志位清零</span></span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    <span class="comment">// 设置阻塞某些信号, 2-&gt;ctrl+c, 3-&gt;ctrl+\, term</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);</span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自定义的阻塞信号集中的数据设置到内核中</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写个循环不停的读内核的未决信号集</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读内核的未决信号集</span></span><br><span class="line">        <span class="keyword">sigset_t</span> pend;</span><br><span class="line">        sigpending(&amp;pend);</span><br><span class="line">        <span class="comment">// 遍历pend中的各个标志位, 每个标志位对应一个信号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">31</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = sigismember(&amp;pend, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;sigismember&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        number++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;myset, <span class="literal">NULL</span>);<span class="comment">//清除阻塞设置，信号生效，程序终止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><ul><li><code>int sigpending(sigset_t *set);</code></li><li>读取内核未决信号集</li><li>set: 传出参数, 保存了内核未决信号集中的信息</li></ul><h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><ol><li>子进程死了, 自杀, 他杀</li><li>子进程被暂停了</li><li>子进程由暂停状态重新恢复运行</li></ol><ul><li>以上三种情况子进程都会给父进程发送信号: SIGCHLD, 父进程默认会忽略这个信号</li><li>在父进程中拦截该信号 -&gt; 写处理函数(回收子进程资源wait)</li></ul><h3 id="使用SIGCHLD回收子进程"><a href="#使用SIGCHLD回收子进程" class="headerlink" title="使用SIGCHLD回收子进程"></a>使用SIGCHLD回收子进程</h3><ul><li>下面程序的阻塞信号集也会被子进程继承下去<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch num: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 回收子进程资源</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 还有子进程存货，死了的子进程回收完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有的子进程死光了, 回收完成!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置信号阻塞</span></span><br><span class="line">    <span class="keyword">sigset_t</span> myset;</span><br><span class="line">    sigemptyset(&amp;myset);<span class="comment">// 这里是先阻塞SIGCHLD，防止捕获还没执行，信号就递达了</span></span><br><span class="line">    sigaddset(&amp;myset, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建子进程 - 20</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid: %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册新号捕捉</span></span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = recycle;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;myset, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 父进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid: %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存映射</title>
      <link href="2020/04/01/C++/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
      <url>2020/04/01/C++/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><blockquote><p>将磁盘文件的数据映射到内存，通过修改内存就能够修改磁盘文件，映射的内存在虚地址空间的共享库加载区域</p></blockquote><p><img src="/photo/mmap.png" alt="mmap" loading="lazy"></p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><h3 id="内存映射函数"><a href="#内存映射函数" class="headerlink" title="内存映射函数"></a>内存映射函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>addr:NULL，由内核指定</li><li>length:要映射的数据的长度，这个值不能为0，可以通过stat、lseek获取文件大小</li><li>prot:对申请的内存映射区的操作权限<ul><li>PROT_READ: 读权限，这个权限必须要有</li><li>PROT_WRITE: 写权限</li><li>PROT_READ | PROT_WRITE: 读写权限</li></ul></li><li>flags:<ul><li>MAP_SHARED: 映射区数据会自动和磁盘文件进行同步，进程间通信必须设置这个选项</li><li>MAP_PRIVATE: 不同步</li></ul></li><li>fd:文件描述符<ul><li>通过open得到的，open的是一个磁盘文件<ul><li>文件大小不能为0</li><li>open的时候需要指定flags<ul><li>这个权限要和prot参数值对应<ul><li>prot:PROT_READ，flag=只读/读写</li><li>prot:PROT_READ | PROT_WRITE，flag=读写</li></ul></li></ul></li></ul></li></ul></li><li>offset:偏移量，一定得的4k的整数倍，0是可以的</li></ul></li><li>返回值:<ul><li>成功: 指向映射区起始位置的指针</li><li>失败: MAP_FAILED ((void*)-1)</li></ul></li></ul><h3 id="释放内存映射区函数"><a href="#释放内存映射区函数" class="headerlink" title="释放内存映射区函数"></a>释放内存映射区函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>addr:mmap的返回值</li><li>length:和mmap函数的第二个参数相同即可</li></ul><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><blockquote><p>使用内存映射区通信，不阻塞</p></blockquote><h3 id="有血缘关系"><a href="#有血缘关系" class="headerlink" title="有血缘关系"></a>有血缘关系</h3><ul><li>还没有子进程的时候<ul><li>通过唯一的父进程，先创建内存映射区</li></ul></li><li>内存映射区有了之后，创建子进程</li><li>父子进程共享创建的内存映射区<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="keyword">void</span>* ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 写内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="keyword">char</span>*)ptr, <span class="string">&quot;你是我儿子吗?&quot;</span>);</span><br><span class="line"><span class="comment">//        sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 读内存</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="keyword">char</span>*)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有血缘关系"><a href="#没有血缘关系" class="headerlink" title="没有血缘关系"></a>没有血缘关系</h3></li><li>准备一个大小非0的磁盘文件</li><li>进程1 通过磁盘文件创建内存映射区<ul><li>得到一个操作这块内存的指针</li></ul></li><li>进程2 通过磁盘文件创建内存映射区<ul><li>得到一个操作这块内存的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="keyword">void</span>* ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="keyword">char</span>*)ptr, <span class="string">&quot;你是我儿子吗?&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="keyword">void</span>* ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读内存</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, (<span class="keyword">char</span>*)ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read data: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ol><li>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?<ul><li>映射区的起始地址必须要保留下来, 用于映射区的释放</li></ul></li><li>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?<ul><li>mmap返回 MAP_FAILED</li></ul></li><li>如果文件偏移量为1000会怎样?<ul><li>mmap调用失败, 返回: MAP_FAILED</li></ul></li><li>mmap什么情况下会调用失败?<ul><li>第二个参数: length == 0</li><li>第三个参数: prot<ul><li>指定了写权限</li><li>prot:PROT_READ | PROT_WRITE且第5个参数fd通open打开文件的时候指定了 O_RDONY/O_WRONLY</li></ul></li></ul></li><li>可以open的时候O_CREAT一个新文件来创建映射区吗?</li></ol><ul><li>创建的新文件大小肯定为0, 这是不行的</li><li>可以对新得到的文件进行拓展<ul><li>lseek(fd, 拓展的长度, SEEK_END);然后对文件进行一次写操作: write(fd, “ “, 1);</li><li>int truncate(const char* path, off_t length);</li><li>int ftruncate(int fd, off_t length);</li></ul></li></ul><ol start="6"><li>mmap后关闭文件描述符，对mmap映射有没有影响？<ul><li>无，映射区还存在，可以理解为文件描述符被拷贝了一份</li></ul></li><li>对ptr越界操作会怎样？<ul><li>映射区的最小单位是4k<ul><li>越界大概率段错误，也有可能是访问野内存(无人管理的内存)则不会但错误</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管道</title>
      <link href="2020/04/01/C++/%E7%AE%A1%E9%81%93/"/>
      <url>2020/04/01/C++/%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h2 id="管道的本质？"><a href="#管道的本质？" class="headerlink" title="管道的本质？"></a>管道的本质？</h2><ul><li>内核缓冲区</li><li>拥有文件特质，可以读写</li><li>匿名管道：没有文件的实体</li><li>具名管道：有文件实体，不存数据</li><li>可以使用文件操作处理管道</li></ul><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><h3 id="匿名管道的特点？"><a href="#匿名管道的特点？" class="headerlink" title="匿名管道的特点？"></a>匿名管道的特点？</h3><ul><li>在磁盘上没有实体，是内存中的一块缓冲区</li><li>这个缓冲区是fork前得到的</li><li>内核缓冲区有两部分<ul><li>读端 -&gt; 可读文件描述符</li><li>写端 -&gt; 可写文件描述符</li></ul></li><li>父进程被销毁，管道被释放</li><li>默认阻塞</li></ul><h3 id="管道的原理？"><a href="#管道的原理？" class="headerlink" title="管道的原理？"></a>管道的原理？</h3><ul><li>循环队列</li><li>默认容量4k，可以使用<code>ulimit -a</code>查看<br><img src="/photo/%E7%AE%A1%E9%81%93%E5%8E%9F%E7%90%86.png" alt="管道原理" loading="lazy"></li></ul><h3 id="匿名管道的局限性"><a href="#匿名管道的局限性" class="headerlink" title="匿名管道的局限性"></a>匿名管道的局限性</h3><ul><li>管道中的数据只能读一次</li><li>半双工：数据是单向流动的</li><li>只能用于有亲缘关系的进程通信</li></ul><h3 id="创建匿名管道"><a href="#创建匿名管道" class="headerlink" title="创建匿名管道"></a>创建匿名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>pipefd: 传出参数</li><li>pipefd[0] -&gt; 管道的读端</li><li>pipefd[1] -&gt; 管道的写端</li></ul></li><li>返回值:<ul><li>0: 调用成功</li><li>-1: 失败</li></ul></li><li>一般读端会关闭fd[2]，写端会关闭fd[1]</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>父子进程间通信，实现 ps aux</li><li>子进程 -&gt; ps aux</li><li>子进程得到的结果，给到父进程</li><li>涉及到有血缘关系的进程通信 -&gt; pipe</li><li>创建进程 -&gt; fork()</li><li>子进程做的事儿: execlp()，执行命令数据会默认写到终端<ul><li>重定向: stdout_fileno-&gt;管道的写端 dup2<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程, 读管道</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程, 写管道</span></span><br><span class="line">        <span class="comment">// 文件描述符重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        <span class="comment">// 执行shell命令 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><ul><li><p>读操作</p><ul><li>如果管道中有数据<ul><li>read读，read返回值是读到的字节数</li></ul></li><li>管道中没有数据<ul><li>写端没有关闭，但是写的慢<ul><li>read阻塞</li></ul></li><li>写端关闭了<ul><li>read解除阻塞，返回值为0<ul><li>数据读完了</li></ul></li></ul></li></ul></li></ul></li><li><p>写数据</p><ul><li>管道有空间<ul><li>接着写，写满之后阻塞</li></ul></li><li>没有空间<ul><li>直接阻塞</li></ul></li><li>写数据的时候，读端关闭了<ul><li>管道破裂</li><li>进程被 SIGPIPE 信号杀死</li></ul></li></ul></li><li><p>设置管道非阻塞(默认两端都是阻塞的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 fcntl 函数</span></span><br><span class="line"><span class="comment">// 设置读端为非阻塞  -&gt; fd[0]</span></span><br><span class="line"><span class="keyword">int</span> flag = fcntl(fd[<span class="number">0</span>], F_GETFL)</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flag);</span><br></pre></td></tr></table></figure></li></ul><h2 id="具名管道"><a href="#具名管道" class="headerlink" title="具名管道"></a>具名管道</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>在磁盘上有一个文件 -&gt; 伪文件<ul><li>通过这个伪文件给不同 的进程搭建一个桥梁 -&gt; 找到同一块内核缓冲区</li><li>这个磁盘文件大小，永远为0</li></ul></li><li>内核缓冲区 -&gt; 环形队列实现的</li><li>数据只能被读一次</li><li>两端默认阻塞</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>有血缘关系的进程间通信</li><li>没有血缘关系的进程通信</li></ul><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><ul><li>shell命令：<code>$ mkfifo 名字</code></li><li>系统函数：<ul><li>pathname: 创建的管道文件对应路径和名字</li><li>mode: 用户对管道文件的操作权限，八进制的数，最终权限: (mode &amp; ~umask)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建有名管道</span></span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n&quot;</span>, i);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC</title>
      <link href="2020/04/01/C++/IPC/"/>
      <url>2020/04/01/C++/IPC/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="IPC-InterProcess-Communication"><a href="#IPC-InterProcess-Communication" class="headerlink" title="IPC - InterProcess Communication"></a>IPC - InterProcess Communication</h1><h2 id="进程间通信的目的？"><a href="#进程间通信的目的？" class="headerlink" title="进程间通信的目的？"></a>进程间通信的目的？</h2><ul><li>进程是一个独立的个体，对一个进程操作不会对其他进程产生任何影响<ul><li>数据传递</li><li>数据共享</li><li>进程控制</li></ul></li></ul><h2 id="进程间通信方式？"><a href="#进程间通信方式？" class="headerlink" title="进程间通信方式？"></a>进程间通信方式？</h2><ul><li>管道<ul><li>匿名管道</li><li>具名管道</li></ul></li><li>内存映射</li><li>本地套接字</li><li>网络套接字</li><li>消息队列</li><li>共享内存</li></ul><h2 id="父子进程始终共享什么？"><a href="#父子进程始终共享什么？" class="headerlink" title="父子进程始终共享什么？"></a>父子进程始终共享什么？</h2><ul><li>文件描述符</li><li>内存映射区</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程控制</title>
      <link href="2020/03/31/C++/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>2020/03/31/C++/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><blockquote><p>每个进程结束之后，都会释放自己虚地址空间中用户区的数据，内核区的pcb没办法自己释放，需要父进程释放。</p></blockquote><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c库函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux系统函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><ul><li>父进程先结束，子进程就成为孤儿进程</li><li>PID为1的进程会成为该孤儿的父进程，负责回收子进程的pcb</li></ul><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><ul><li>子进程先结束，但父进程没有做回收工作，子进程成为僵尸进程</li><li>僵尸进程没有用户区，只有一个pcb，不能称为一个h存活的进程</li><li>僵尸进程不能被kill -9杀死</li></ul><h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><ul><li><p><code>pid_t wait(int *status);</code></p><ul><li>是一个阻塞函数</li><li>当前进程还有子进程时，调用wait会阻塞</li><li>子进程被全部回收，调用wait不会阻塞</li><li>wait调用一次只能回收一个子进程</li><li>status：记录子进程退出时的状态<ul><li>正常退出：走的exit函数，return下面也是exit</li><li>异常退出：被信号干掉</li></ul></li><li>返回值：<ul><li>大于零：被回收的子进程PID</li><li>-1：调用失败<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 有一个父进程, 5个子进程(兄弟)</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            <span class="keyword">int</span> s;</span><br><span class="line">            <span class="keyword">int</span> ret = wait(&amp;s);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(s))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码: %d\n&quot;</span>, WEXITSTATUS(s));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(s))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被那个信号干掉了: %d\n&quot;</span>, WTERMSIG(s));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>pid_t waitpid(pid_t pid, int *status, int options);</code></p><ul><li>pid:<ul><li>&gt;0:某个子进程PID</li><li>=0:回收当前进程组的子进程</li><li>-1:回收所有子进程 == wait(NULL)，用的最多</li><li>&lt;0:某个进程组ID，回收指定进程组子进程</li></ul></li><li>option:<ul><li>0:阻塞</li><li>WNOHANG:非阻塞</li></ul></li><li>返回值:<ul><li>&gt;0:回收的子进程PID</li><li>=0:options = WNOHANG，还有子进程存活</li><li>-1:错误，已经没有子进程了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 有一个父进程, 5个子进程(兄弟)</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            <span class="keyword">int</span> s;</span><br><span class="line">            <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, &amp;s, WNOHANG);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(s))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码: %d\n&quot;</span>, WEXITSTATUS(s));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(s))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被那个信号干掉了: %d\n&quot;</span>, WTERMSIG(s));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程还没死...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exec函数族</title>
      <link href="2020/03/31/C++/exec%E5%87%BD%E6%95%B0%E6%97%8F/"/>
      <url>2020/03/31/C++/exec%E5%87%BD%E6%95%B0%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h1><blockquote><p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容。exec函数族执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代(即整个虚地址空间用户区被全部取代)，只留下进程ID等一些表面上的信息仍保持原样，只有调用失败，才会返回-1，从原程序的调用点接着往下执行。一般都是先fork一个子进程，然后在子进程中使用exec函数族。</p></blockquote><p><img src="/photo/exec.png" alt="exec" loading="lazy"></p><ul><li>exec函数族原型，其中execl和execlp时最常用的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是linux系统函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line">- path：可执行文件名</span><br><span class="line">- envp：字符串数组，可执行文件的搜索路径</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line">- path：可执行文件路径</span><br><span class="line">- argv：就是execl的参数，写在了字符串数组里</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line">- file：可执行文件名</span><br><span class="line">- argv：就是execlp的参数</span><br><span class="line"><span class="comment">// linux系统函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line">- path：可执行文件名</span><br><span class="line">- argv：execle的arg + 可变参数</span><br><span class="line">- envp：execle的envp</span><br></pre></td></tr></table></figure></li></ul><h2 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h2><ul><li><code>int execl(const char *path, const char *arg, ...);</code></li><li>path：可执行程序的路径，建议写绝对路径</li><li>arg：不会被用到，一搬写程序名</li><li>可变参数：程序执行需要用到的参数</li><li>最后一个参数：NULL表示结束<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">                execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(++i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h2><ul><li><code>int execlp(const char *file, const char *arg, ...);</code></li><li>file：可执行程序的名字，会自动搜索环境变量，当前目录程序是不行的</li><li>后面的参数和execl一致<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">                execl(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(++i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程创建</title>
      <link href="2020/03/31/C++/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
      <url>2020/03/31/C++/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>获取当前进程的进程ID</li><li>获取当前进程父进程的进程ID<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> = getpid(<span class="keyword">void</span>); <span class="comment">//当前进程</span></span><br><span class="line"><span class="keyword">pid_t</span> = getppid(<span class="keyword">void</span>); <span class="comment">//父进程</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程返回值大于零，子进程返回值等于零</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/photo/fork.png" alt="fork" loading="lazy"></p><h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>fork的返回值不同</li><li>pcb的一些数据<ul><li>pid</li><li>ppid</li><li>信号集<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3></li></ul></li><li>fork之前<ul><li>用户区数据一致</li><li>文件描述符表一致<h3 id="变量共享"><a href="#变量共享" class="headerlink" title="变量共享"></a>变量共享</h3></li></ul></li><li>刚开始的时候一样，数据被修改后不共享</li><li>读时共享，被写则复制<br><img src="/photo/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%98%E9%87%8F.png" alt="父子进程变量" loading="lazy"></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程概述</title>
      <link href="2020/03/31/C++/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>2020/03/31/C++/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="一-程序和进程"><a href="#一-程序和进程" class="headerlink" title="一.程序和进程"></a>一.程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul><li>就是一个文件，占用磁盘空间</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>进程不占磁盘空间，系统会分配cpu内存资源</li><li>进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，是竞争计算机系统资源的基本单位</li><li>每一个进程都有自己的虚地址空间</li></ul><h2 id="二-并行和并发"><a href="#二-并行和并发" class="headerlink" title="二.并行和并发"></a>二.并行和并发</h2><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><ul><li>多个人在某个时间点做同一件事</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li>描述的是在一个非常短的时间段内处理若干个工作</li></ul><h3 id="cpu时间片"><a href="#cpu时间片" class="headerlink" title="cpu时间片"></a>cpu时间片</h3><ul><li>时间片即分配给各个程序的时间，每个进程被分配一个时间段，称作它的时间片</li><li>进程走完自己的时间片会被强制挂起，等待下一次执行</li></ul><h2 id="三-PCB"><a href="#三-PCB" class="headerlink" title="三.PCB"></a>三.PCB</h2><h3 id="PCB进程控制块，在内核中是task-struct结构体"><a href="#PCB进程控制块，在内核中是task-struct结构体" class="headerlink" title="PCB进程控制块，在内核中是task_struct结构体"></a>PCB进程控制块，在内核中是task_struct结构体</h3><ul><li>进程id，每个进程有唯一的id，C语言中用pid_t表示，是个非负整数</li><li>进程的状态，有就绪，运行，挂起，停止</li><li>进程切换时需要保存和恢复的一些cpu寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li><li>当前工作目录</li><li>umask掩码</li><li>文件描述符表，包含很多指向file结构体的指针</li><li>和信号相关的信息</li><li>用户id和组id</li><li>会话和进程组，多个进程属于一个进程组，多个进程组属于一个会话</li><li>进程可以使用的资源上限，<code>ulimit -a</code>查看，这些值是可以被改变的，比如最大可打开文件数不一定是1024</li></ul><h2 id="四-进程状态"><a href="#四-进程状态" class="headerlink" title="四.进程状态"></a>四.进程状态</h2><ul><li>创建态：初始化系统资源</li><li>就绪态：不能运行，需要抢cpu资源</li><li>运行态：进程抢到了cpu，一个时间片过后回到就绪态</li><li>阻塞态：运行态的进程受到某些干扰（比如sleep）失去cpu，阻塞解除回到就绪态</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>活着</title>
      <link href="2020/03/31/record/%E6%B4%BB%E7%9D%80/"/>
      <url>2020/03/31/record/%E6%B4%BB%E7%9D%80/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是我第一次读出版文学，小时候父母给买的书也有看过，但根本也读不进去，一直以来都觉得文学类作品读了也无用，一心只想着搞小钱钱，今天又在微信读书薅了一个多月的羊毛，本着微信读书里的网络小说虽然不能用无限卡白嫖了，但也不能浪费的原则，想着找出版文学看一看，看到豆瓣上读书榜单第二是《活着》，久闻其名，就打开看了看。</p><p>篇幅不长，一个上午的时间就读完了，一开篇就被作者的笔力深深吸引到了，正经的文学作品里又带着一点ghs的嫌疑，感觉很有趣，让我很想看下去，但又觉得作者为了描绘的真实而有点过头，小时候自己也是生活在农村，可能因为年代不一样吧。</p><p>全篇的故事主线是徐家人一个接着一个的离开，故事很沉痛，让我感觉不太真实，怀疑这个故事是作者虚构出来的，后来网上查了查，果然是虚构的，但不影响这篇故事带给我的思考。</p><p>全文第一个让我记忆犹新的点是福贵年轻时的行为，妓女，银币，福贵的嚣张，一个时代的样子呈现在我的眼前，我不知道现在是什么样子，但是能感受到解放战争那段时期女性地位的地下，更无法想象封建社会是不是会更加的变本加厉。</p><p>第二个是福贵被抓去打仗，让我意外的是那连长误认为家丁是县令家公子时，也还是要带他走的情景，和连长对生命的玩笑，和后文医生为了救县长夫人抽干有庆的血的情节有了一个呼应，让我体会到了战争年代世道的残酷。</p><p>第三个是有庆这个角色的刻画，在父亲面前穿上鞋子，走远后又脱下鞋子在雪地奔跑的场景格外记忆犹新，在我看来，穷人家的孩子早当家也是有一定道理的，这一点在福贵年轻时也看得出来，后来家产被输光，福贵也成长了起来。</p><p>第四个是有庆的死，医生角色的描绘让人咬牙切齿，难以置信，春生的出现让人意外，从有庆想要献血的热切，到医生的冷漠，再到春生的表现，整个剧情只让人觉得冷冰冰的，或许这刻画的才是真实的人性。</p><p>第五个是凤霞的死，和二喜的“我没要小的”那句话，刚刚看到说大人孩子都保住了，心里一阵安慰，翻到下一页就是凤霞大出血死亡，剧情的急转而下让我不太舒服。</p><p>还有很多都让我难以释怀，龙二的“是我替你去死”，给人一种塞翁失马，焉知非福的感觉，还有用水煮钢铁的滑稽，队长贪了一把小米，后面却对福贵一家仁至义尽，家珍知道自己的病没得治反而松一口气，二喜临死前高呼苦根的名字，和苦根被豆子活活撑死，看似滑稽实则让人心疼。</p><p>还有最后徐福贵牵着牛福贵，唱着“年少游荡，中年掘藏，老年做和尚”，写出了一个老人一生的波折与体悟，到最后给我一种释然和洒脱的感觉。</p><p>福贵年少荒唐，本以为以后的日子会平淡而美满，但我的思想显然不可能和作者一致，福贵的后半生以家人一个个的离开自己而结束，想来自己人生二十年平淡无味，每每回忆起过往，脑子里也只一些儿女情长，“年少游荡，中年掘藏，老年做和尚”总结的精辟，自己的少年时光已经过去了，当真如这句话一样，自己高中的时候不好好学习，总觉得学习没用，现在则想着要是自己高中有自己现在这么认学自己何至于此，难道一些坑真的就是必须自己踩过，自己爬上来才能懂得么，现如今满脑子都是小钱钱，成天想着以后能不能找到工作，能不能赚大钱，这些日子每天都关注着春招的动态，看着自己肚子里那点知识愁的脑壳疼，当真是被欲望支配着。</p><p>年少游荡，中年掘藏，我不想这么活着，但偏偏生活有时候由不得我…难不成每个人的一生都逃不脱这句话么？</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="2020/03/29/C++/IO/"/>
      <url>2020/03/29/C++/IO/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="Linux系统IO和C标准库IO"><a href="#Linux系统IO和C标准库IO" class="headerlink" title="Linux系统IO和C标准库IO"></a>Linux系统IO和C标准库IO</h2><h3 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h3><p><img src="/photo/stdcio.png" alt="标准C库IO" loading="lazy"></p><h3 id="标准C库IO和Linux系统IO的关系"><a href="#标准C库IO和Linux系统IO的关系" class="headerlink" title="标准C库IO和Linux系统IO的关系"></a>标准C库IO和Linux系统IO的关系</h3><p><img src="/photo/IO%E5%85%B3%E7%B3%BB.png" alt="IO关系" loading="lazy"></p><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="/photo/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="虚拟内存" loading="lazy"><br><img src="/photo/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="内存布局" loading="lazy"></p><h3 id="文件描述符表"><a href="#文件描述符表" class="headerlink" title="文件描述符表"></a>文件描述符表</h3><ul><li>文件描述符表默认大小1024</li><li>每个进程启动后，都有一个文件描述符表</li><li>所以每个进程默认能打开1024个文件</li><li>前三个文件描述符是默认被使用的<ul><li>stdin 0</li><li>stdout 1</li><li>stderr 2</li></ul></li><li>关闭文件会释放文件描述符</li><li>每次分配文件描述符选择最小的且未被占用的<br><img src="/photo/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.png" alt="文件描述符表" loading="lazy"></li></ul><h2 id="Linux系统IO函数"><a href="#Linux系统IO函数" class="headerlink" title="Linux系统IO函数"></a>Linux系统IO函数</h2><h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><ul><li>属于linux系统函数库，里的一个全局变量，记录的是错误号</li></ul><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><ul><li>include<ul><li>sys/types.h</li><li>sys/stat.h</li><li>fcntl.h</li></ul></li><li>打开一个已存在的文件<ul><li><code>int open(const char *pathname, int flags);</code></li><li>pathname：要打开的文件的路径</li><li>flags:对文件的操作权限设置<ul><li>O_RDONLY O_WRONLY O_RDWR 这三个设置是互斥的</li></ul></li><li>返回文件描述符</li></ul></li><li>创建一个新文件<ul><li><code>int open(const char *pathname, int flags, mode_t mode);</code></li><li>pathname：要打开的文件的路径</li><li>flags:对文件的操作权限设置<ul><li>必选项：O_RDONLY O_WRONLY O_RDWR 这三个设置是互斥的</li><li>可选项：O_CREAT 文件不存在则创建文件</li></ul></li><li>mode：八进制的数，创建出的文件权限 = mode &amp; ~umask（$ umask终端查看值）</li><li>返回文件描述符</li></ul></li></ul><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><ul><li>include &lt;unistd.h&gt;</li><li><code>int close(int fd);</code><ul><li>成功返回0</li><li>失败返回-1，并设置errno</li></ul></li></ul><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><ul><li>include &lt;unistd.h&gt;</li><li><code>ssize_t read(int fd, void *buf, size_t count);</code> size_t是无符号整数，ssize_t是有符号整数<ul><li>fd：open得到的文件描述符</li><li>buf：存储读到的数据</li><li>count：buf大小</li><li>返回正数，为实际读到的字节数</li><li>返回0，代表文件读完了</li><li>失败返回-1</li></ul></li></ul><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><ul><li>include &lt;unistd.h&gt;</li><li><code>ssize_t write(int fd, const void *buf, size_t count);</code><ul><li>fd：open得到的文件描述符</li><li>buf：要写入的数据</li><li>count：要写入数据的大小</li><li>成功返回写入字节数</li><li>失败返回-1</li></ul></li></ul><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><ul><li><p>include</p><ul><li>sys/types.h</li><li>unistd.h</li></ul></li><li><p><code>off_t lseek(int fd, off_t offset, int whence);</code></p><ul><li>fd：open得到的文件描述符</li><li>offset：偏移量</li><li>whence：<ul><li>SEEK_SET：设置偏移量为offset</li><li>SEEK_CUR：设置偏移量为当前位置+offset</li><li>SEEK_END：设置偏移量为文件大小+offset</li></ul></li><li>跟fseek很像：<code>int fseek(FILE *stream, long offset, int whence);</code></li></ul></li><li><p>使用</p><ul><li>移动文件指针到文件头：<code>lseek(fd, 0, SEEK_SET);</code></li><li>获取当前文件指针的位置：<code>lseek(fd, 0, SEEK_CUR);</code></li><li>获取文件长度：<code>lseek(fd, 0, SEEK_END);</code></li><li>拓展文件大小100字节：<code>lseek(fd, 100, SEEK_END);</code><ul><li>需要进行一次写操作：<code>write(fd, &quot; &quot;, 1);</code></li></ul></li></ul></li></ul><h2 id="Linux其他系统函数"><a href="#Linux其他系统函数" class="headerlink" title="Linux其他系统函数"></a>Linux其他系统函数</h2><h3 id="stat-lstat"><a href="#stat-lstat" class="headerlink" title="stat/lstat"></a>stat/lstat</h3><ul><li>include<ul><li>sys/types.h</li><li>sys/stat.h</li><li>unistd.h</li></ul></li><li><code>int stat(const char *pathname, struct stat *buf);</code><ul><li>pathname：操作的文件的路径</li><li>buf：传出的结构体变量</li></ul></li><li>可以使用<code>$ stat 文件名</code>shell命令查看文件信息</li><li>stat结构体<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="keyword">dev_t</span>          st_dev;        <span class="comment">//文件的设备编号</span></span><br><span class="line"><span class="keyword">ino_t</span>           st_ino;        <span class="comment">//节点</span></span><br><span class="line"><span class="keyword">mode_t</span>      st_mode;      <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line"><span class="keyword">nlink_t</span>        st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line"><span class="keyword">uid_t</span>           st_uid;       <span class="comment">//用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span>           st_gid;       <span class="comment">//组ID</span></span><br><span class="line"><span class="keyword">dev_t</span>          st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line"><span class="keyword">off_t</span>         st_size;      <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line"><span class="keyword">blksize_t</span>     st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line"><span class="keyword">blkcnt_t</span>      st_blocks;    <span class="comment">//块数</span></span><br><span class="line"><span class="keyword">time_t</span>         st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line"><span class="keyword">time_t</span>         st_mtime;     <span class="comment">//最后一次修改时间</span></span><br><span class="line"><span class="keyword">time_t</span>         st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>st_mode<ul><li>一个十六位整数</li><li>可以通过位运算来获取文件的类型和存取的权限</li></ul></li></ul><p><img src="/photo/st_mode.png" alt="st_mode" loading="lazy"></p><h3 id="文件属性函数"><a href="#文件属性函数" class="headerlink" title="文件属性函数"></a>文件属性函数</h3><ul><li><code>int access(const char *pathname, int mode);</code></li><li><code>int chmod(const char *filename, int mode);</code></li><li><code>int chown(const char *path, uid_t owner, gid_t group);</code></li><li><code>int truncate(const char *path, off_t length);</code></li></ul><h3 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h3><ul><li><code>int rename(const char *oldpath, const char *newpath);</code></li><li><code>int chdir(const char *path);</code></li><li><code>char *getcwd(char *buf, size_t size);</code></li><li><code>int mkdir(const char *pathname, mode_t mode);</code></li><li><code>int rmdir(const char *pathname);</code></li></ul><h3 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h3><ul><li><code>DIR *opendir(const char *name);</code><ul><li>name：要打开的目录</li></ul></li><li>返回值：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span> d_ino;               <span class="comment">// 此目录进入点的inode</span></span><br><span class="line">    <span class="keyword">ff_t</span> d_off;                <span class="comment">// 目录文件开头至此目录进入点的位移</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span> d_reclen; <span class="comment">// d_name 的长度, 不包含NULL 字符</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;      <span class="comment">// d_name 所指的文件类型</span></span><br><span class="line">    har d_name[<span class="number">256</span>];       <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>d_type:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DT_BLK - 块设备</span><br><span class="line">DT_CHR - 字符设备</span><br><span class="line">DT_DIR - 目录</span><br><span class="line">DT_LNK - 软连接</span><br><span class="line">DT_FIFO - 管道</span><br><span class="line">DT_REG - 普通文件</span><br><span class="line">DT_SOCK - 套接字</span><br><span class="line">DT_UNKNOWN - 未知</span><br></pre></td></tr></table></figure></li><li><code>struct dirent *readdir(DIR *dirp);</code><ul><li>返回一个结构体，对应一个文件</li></ul></li><li><code>int closedir(DIR *dirp);</code></li><li>应用案例：获取目录下普通文件个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读某个目录下普通文件的个数</span></span><br><span class="line"><span class="comment">// 需要用到递归, 想明白递归结束的条件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;file num: %d\n&quot;</span>, num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读指定目录下文件个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 打开指定目录</span></span><br><span class="line">DIR* dir = opendir(path);</span><br><span class="line"><span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 读打开的目录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>( (ptr = readdir(dir)) != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果是目录, 需要递归读子目录, 跳过. 和.. 目录</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是一个普通文件</span></span><br><span class="line"><span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 文件个数+1</span></span><br><span class="line">total ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是一个目录</span></span><br><span class="line"><span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 进去, 打开目录</span></span><br><span class="line"><span class="keyword">char</span> newpath[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s/%s&quot;</span>, path, ptr-&gt;d_name);</span><br><span class="line">total += getFileNum(newpath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><ul><li>include &lt;unistd.h&gt;</li><li><code>int dup(int oldfd);</code></li><li>返回空闲且最小的文件描述符，这时候返回的描述符指向oldfd指向的文件</li></ul><h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><ul><li>include &lt;unistd.h&gt;</li><li><code>int dup2(int oldfd, int newfd);</code></li><li>重定向文件描述符</li><li>使newfd指向oldfd指向的文件</li><li>两个参数相同等于什么也没做</li><li>返回值是newfd，失败则返回-1</li><li>oldfd必须是有效的，newfd是个0-1023的数就行</li></ul><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><ul><li>include<ul><li>unistd.h</li><li>fcntl.h</li></ul></li><li><code>int fcntl(int fd, int cmd, ...);</code></li><li>复制文件描述符 === dup<ul><li><code>int ret = fcntl(fd,F_DUPFD);</code></li></ul></li><li>设置/获取文件的状态标志<ul><li>就是open函数的flags参数，其中必选项只读/只写/读写时无法更改的，只能修改可选项</li><li>常用可选项<ul><li>O_APPEND 数据追加</li><li>O_NONBLOCK 设置非阻塞<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>,O_WRONLY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = fcntl(fd,F_GETFL);</span><br><span class="line">flag |= O_APPEND;</span><br><span class="line">fcntl(fd,F_SETFL,flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello linux\n&quot;</span>;</span><br><span class="line">write(fd,p,<span class="built_in">strlen</span>(p));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb</title>
      <link href="2020/03/29/other/gdb/"/>
      <url>2020/03/29/other/gdb/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><ul><li>通常在调试编译时，会关掉编译器优化”-O0”，打开调试选项”-g”，打开警告提示”-Wall”，避免不必要的bug</li><li>“-g”的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但不是把整个源文件嵌入到可执行文件中，所以调试时必须保证gdb能找到源文件</li></ul><h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><h3 id="启动和退出"><a href="#启动和退出" class="headerlink" title="启动和退出"></a>启动和退出</h3><ul><li>启动：gdb 可执行程序</li><li>传递参数：(gdb) set args 8 9</li><li>显示参数：(gdb) show args</li><li>退出：(gdb) quit</li></ul><h3 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h3><ul><li>当前文件(l === list)<ul><li>(gdb) l</li><li>(gdb) l 行号</li><li>(gdb) l 函数名</li></ul></li><li>非当前文件(l === list)<ul><li>(gdb) l 文件名:行号</li><li>(gdb) l 文件名:函数名</li></ul></li><li>查看默认显示行数(list === listsize)<ul><li>(gdb) show list</li></ul></li><li>更改显示行数(list === listsize)<ul><li>(gdb) set list 行数</li></ul></li></ul><h2 id="断点操作-b-break"><a href="#断点操作-b-break" class="headerlink" title="断点操作(b === break)"></a>断点操作(b === break)</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul><li>(gdb) b 行号</li><li>(gdb) b 函数名</li><li>(gdb) b 文件名:行号</li><li>(gdb) b 文件名:函数名</li></ul><h3 id="查看断点-i-info"><a href="#查看断点-i-info" class="headerlink" title="查看断点(i === info)"></a>查看断点(i === info)</h3><ul><li>(gdb) i b</li></ul><h3 id="删除断点-d-del-delete"><a href="#删除断点-d-del-delete" class="headerlink" title="删除断点(d === del === delete)"></a>删除断点(d === del === delete)</h3><ul><li>(gdb) d 断点编号</li></ul><h3 id="设置断点无效-dis-disable"><a href="#设置断点无效-dis-disable" class="headerlink" title="设置断点无效(dis === disable)"></a>设置断点无效(dis === disable)</h3><ul><li>(gdb) dis 断点编号</li></ul><h3 id="无效断点生效-ena-enable"><a href="#无效断点生效-ena-enable" class="headerlink" title="无效断点生效(ena === enable)"></a>无效断点生效(ena === enable)</h3><ul><li>(gdb) ena 断点编号</li></ul><h3 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a>设置条件断点</h3><ul><li>(gdb) b 行号 if 条件语句</li></ul><h2 id="调试命令-1"><a href="#调试命令-1" class="headerlink" title="调试命令"></a>调试命令</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li>(gdb) start:只运行一行</li><li>(gdb) run:运行直到断点</li></ul><h3 id="运行到下一个断点-c-continue"><a href="#运行到下一个断点-c-continue" class="headerlink" title="运行到下一个断点(c === continue)"></a>运行到下一个断点(c === continue)</h3><ul><li>(gdb) c</li></ul><h3 id="打印变量-p-print"><a href="#打印变量-p-print" class="headerlink" title="打印变量(p === print)"></a>打印变量(p === print)</h3><ul><li>(gdb) print 变量名</li><li>(gdb) print/x 变量名 十六进制</li><li>(gdb) print/o 变量名 八进制</li></ul><h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><ul><li>(gdb) ptype 变量名</li></ul><h3 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h3><ul><li>会进入函数体(s === step)<ul><li>(gdb) s</li><li>跳出函数体：(gdb) finsh<ul><li>函数体内不能有断点</li></ul></li></ul></li><li>不会进入函数体(n === next)<ul><li>(gdb) n</li></ul></li><li>变量自动显示<ul><li>(gdb) display 变量名</li><li>查看自动打印哪些变量(i === info)：(gdb) i display</li></ul></li><li>取消变量自动显示<ul><li>(gdb) undisplay 编号</li></ul></li><li>设定变量值<ul><li>(gdb) set var 变量名=值</li></ul></li><li>跳出循环<ul><li>(gdb) until</li><li>循环体内不能有断点</li><li>执行完循环体最后一行才会跳出</li></ul></li></ul><h2 id="多进程调试"><a href="#多进程调试" class="headerlink" title="多进程调试"></a>多进程调试</h2><ul><li>默认跟踪父进程</li><li>设置跟踪父进程：<code>set follow-fork-mode parent</code></li><li>设置跟踪子进程：<code>set follow-fork-mode child</code></li></ul><h2 id="core文件"><a href="#core文件" class="headerlink" title="core文件"></a>core文件</h2><ul><li><code>$ ulimit -a</code>查看core文件大小，为0是不会创建core文件的</li><li><code>$ ulimit -c 1024</code>改变core文件大小</li><li><code>gcc main.c -g</code>生成可调试程序</li><li>运行程序如果出错了就会生成core文件</li><li><code>(gdb) core-file core</code>查看错误信息</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile</title>
      <link href="2020/03/29/other/makefile/"/>
      <url>2020/03/29/other/makefile/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><ul><li>makefile</li><li>Makefile</li></ul><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标...:依赖...# 规则</span></span><br><span class="line">shell命令</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>一个makefile文件中可以有一个或多个规则</li><li>目标：最重要生成的文件，伪目标不算</li><li>依赖：生成目标的原材料</li><li>命令：tab缩进，生成目标需要的命令</li><li>后面的规则都是为第一条规则服务的</li><li>make命令生成第一条规则的目标</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>命令在执行之前，需要先检测规则中的依赖是否存在<ul><li>如果存在：执行命令</li><li>如果不存在：向下检测其他的规则<ul><li>看一看有没有一个规则是用来生成这个依赖的</li><li>如果找到了，执行该规则中的命令</li></ul></li></ul></li><li>检测更新</li><li>在执行规则中的命令的时候，会比较目标和依赖文件时间<ul><li>如果依赖的时间比目标的时间晚<ul><li>需要重新生成目标</li></ul></li><li>如果依赖的时间比目标的时间早<ul><li>目标不需要更新，对应规则中的命令不需要执行</li></ul></li></ul></li><li>伪目标不会做时间的比较<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>自定义变量<ul><li>格式：变量名=变量值</li><li>变量名小写</li></ul></li><li>默认的自带变量<ul><li>变量名大写</li><li>例如：CC == cc</li></ul></li><li>自动变量<ul><li>$@：规则中的目标</li><li>$&lt;：规则中的第一个依赖</li><li>$^：规则中的全部依赖</li></ul></li><li>获取变量值<ul><li>value=$(CC)</li></ul></li></ul><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p><img src="/photo/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.png" alt="模式匹配" loading="lazy"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>获取指定目录下指定类型的文件列表：<strong>wildcard</strong><ul><li><code>srcfile=$(wildcard *.c ./src/*.c)</code> 获取当前目录和src目录的.c文件</li><li>返回值：”A.c B.c C.c”</li></ul></li><li>模式字符串替换函数：<strong>patsubst</strong><ul><li><code>objfile=$(patsubst %.c,%.o,$(srcfile))</code> 把srcfile中.c换成.o，这里的%可以用\%转义表示%字符</li><li>返回值：”A.o B.o C.o”</li></ul></li></ul><h3 id="makefile的编写"><a href="#makefile的编写" class="headerlink" title="makefile的编写"></a>makefile的编写</h3><ul><li><p>版本1</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺点：任意一个源文件被修改，所有的源文件都需要被重新编译</span></span><br><span class="line"><span class="section">app:main.c add.c sub.c</span></span><br><span class="line">        gcc -o app main.c add.c sub.c</span><br></pre></td></tr></table></figure></li><li><p>版本2</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺点：书写麻烦，不适用于文件比较多的情况</span></span><br><span class="line"><span class="section">app:main.o add.o sub.o                        </span></span><br><span class="line">    gcc -o app main.o add.o sub.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">    gcc -c add.c</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">    gcc -c sub.c</span><br></pre></td></tr></table></figure></li><li><p>版本3</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺点：书写麻烦，这些.o文件名，需要手写</span></span><br><span class="line">objs=main.o add.o sub.o</span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">gcc <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p>版本4</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺点：需要自己手动清理.o文件</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">gcc <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p>版本5</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">gcc <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean# 声明为伪目标，当./有clean文件也可以正常执行make clean</span></span><br><span class="line"><span class="section">clean:# 当使用make clean命令，就只执行该规则，使用make是生成第一条规则的目标</span></span><br><span class="line">rm <span class="variable">$(objs)</span> <span class="variable">$(target)</span> -f</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc</title>
      <link href="2020/03/28/other/gcc/"/>
      <url>2020/03/28/other/gcc/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>GNU编译器套件(GNU Compiler Collection)原名GNU C语言编译器(GUN C Compiler)，原本只能处理C语言，随后很快的得到扩展。GCC的初衷是为GNU操作系统专门编写的编译器。</p></blockquote><h2 id="gcc与g-有什么区别？"><a href="#gcc与g-有什么区别？" class="headerlink" title="gcc与g++有什么区别？"></a>gcc与g++有什么区别？</h2><h3 id="gcc和g-都是GNU的一个编译器"><a href="#gcc和g-都是GNU的一个编译器" class="headerlink" title="gcc和g++都是GNU的一个编译器"></a>gcc和g++都是GNU的一个编译器</h3><h3 id="误区一：gcc只能编译c代码，g-只能编译c-代码。两者都可以，但是请注意："><a href="#误区一：gcc只能编译c代码，g-只能编译c-代码。两者都可以，但是请注意：" class="headerlink" title="误区一：gcc只能编译c代码，g++只能编译c++代码。两者都可以，但是请注意："></a>误区一：gcc只能编译c代码，g++只能编译c++代码。两者都可以，但是请注意：</h3><ul><li>后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序</li><li>后缀为.cpp的，两者都会认为是c++程序，C++的语法规则更加严谨一些</li><li>编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的<h3 id="误区二：gcc不会定义-cplusplus宏，而g-会"><a href="#误区二：gcc不会定义-cplusplus宏，而g-会" class="headerlink" title="误区二：gcc不会定义__cplusplus宏，而g++会"></a>误区二：gcc不会定义<code>__cplusplus</code>宏，而g++会</h3></li><li>实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释</li><li>如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义<h3 id="误区三：编译只能用gcc，链接只能用g"><a href="#误区三：编译只能用gcc，链接只能用g" class="headerlink" title="误区三：编译只能用gcc，链接只能用g++"></a>误区三：编译只能用gcc，链接只能用g++</h3></li><li>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用<code>g++</code>或者<code>gcc -lstdc++</code></li><li>gcc命令不能自动和C++程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价</li></ul><h2 id="gcc常用参数选项"><a href="#gcc常用参数选项" class="headerlink" title="gcc常用参数选项"></a>gcc常用参数选项</h2><table><thead><tr><th align="center">gcc编译选项</th><th align="center">选项的意义</th></tr></thead><tbody><tr><td align="center">-E</td><td align="center">预处理指定的源文件，不进行编译</td></tr><tr><td align="center">-S</td><td align="center">编译指定的源文件，但是不进行汇编</td></tr><tr><td align="center">-c</td><td align="center">编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td align="center">-o [file1] [file2] / [file2] -o [file1]</td><td align="center">将文件 file2 编译成可执行文件 file1</td></tr><tr><td align="center">-I</td><td align="center">指定include包含文件的搜索目录</td></tr><tr><td align="center">-g</td><td align="center">在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td align="center">-D</td><td align="center">在程序编译的时候，指定一个宏</td></tr><tr><td align="center">-w</td><td align="center">不生成任何警告信息</td></tr><tr><td align="center">-Wall</td><td align="center">生成所有警告信息(默认不是所有警告都提示的，比如已定义未使用的变量)</td></tr><tr><td align="center">-On</td><td align="center">n的取值范围：0~3，编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td align="center">-l</td><td align="center">在程序编译的时候，指定使用的库</td></tr><tr><td align="center">-L</td><td align="center">指定编译的时候，搜索的库的路径</td></tr><tr><td align="center">-fPIC/fpic</td><td align="center">生成与位置无关的代码</td></tr><tr><td align="center">-shared</td><td align="center">生成共享目标文件，通常用在建立共享库时</td></tr><tr><td align="center">-std</td><td align="center">指定标准，如:-std=c99，gcc默认的标准是GNU C</td></tr></tbody></table><h3 id="D的使用场景"><a href="#D的使用场景" class="headerlink" title="-D的使用场景"></a>-D的使用场景</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调试信息...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -DDEBUG hello.c</span><br><span class="line">./a.out</span><br><span class="line">调试信息...</span><br><span class="line">Hello world!</span><br><span class="line"></span><br><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="2020/03/28/other/vim/"/>
      <url>2020/03/28/other/vim/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="切换编辑模式："><a href="#切换编辑模式：" class="headerlink" title="切换编辑模式："></a>切换编辑模式：</h3><ul><li>i：向光标所在位置前插入</li><li>I：向光标所在行的行首插入</li><li>a: 向光标所在位置后插入</li><li>A：向光标所在行的行尾插入</li><li>o: 向光标所在位置下一行插入</li><li>O：向光标所在位置上一行插入</li><li>s：以删除光标选中字符为前提插入</li><li>S：以删除光标所在行为前提插入</li></ul><h3 id="光标移动："><a href="#光标移动：" class="headerlink" title="光标移动："></a>光标移动：</h3><ul><li>hjkl 左下上右</li><li>gg 跳转至文件的首行</li><li>GG 跳转至文件的末行</li><li>nG 跳转至第n行</li><li>0    跳转至光标所在行行首</li><li>$    跳转至光标所在行行尾</li><li>:n回车，末行命令，跳转至第n行</li></ul><h3 id="复制粘贴："><a href="#复制粘贴：" class="headerlink" title="复制粘贴："></a>复制粘贴：</h3><ul><li>单行复制：<ul><li>光标挪动至待复制行的任意字符上，使用yy复制。移动光标到目标位置，p向下一行粘，P向上一行粘。</li></ul></li><li>多行复制：<ul><li>光标挪动至待复制多行的首行的任意字符上，使用nyy复制。移动光标到目标位置，p向下一行粘，P向上一行粘。</li></ul></li><li>区域复制：<ol><li>将光标挪动至待复制区域的首字符上</li><li>命令模式下按V。左下角出现“可视”提示</li><li>使用hjkl挪移光标，选中待复制区域</li><li>按y复制</li><li>移动光标到目标位置p向后粘，P向前粘</li></ol></li></ul><h3 id="剪切、删除："><a href="#剪切、删除：" class="headerlink" title="剪切、删除："></a>剪切、删除：</h3><ul><li>vim当中的删除，靠剪切实现。</li><li>单行剪切、删除：<ul><li>光标挪动至待剪切行的任意字符上，使用dd剪切。移动光标到目标位置，p向下一行粘，P向上一行粘。不粘即为删除。</li></ul></li><li>删除、剪切多行：<ul><li>光标挪动至待剪切多行的首行的任意字符上，使用ndd剪切。移动光标到目标位置，p向下一行粘，P向上一行粘。不粘即为删除。</li></ul></li><li>区域剪切：<ol><li>将光标挪动至待剪切制区域的首字符上。</li><li>命令模式下，按V。左下角出现 “可视”提示</li><li>使用hjkl挪移光标，选中待剪切区域</li><li>按d剪切</li><li>移动光标到目标位置p向后粘，P向前粘。不粘即为删除</li></ol></li><li>剪切到行尾：<ul><li>d$、D：剪切光标位置到行尾</li><li>d0：剪切光标位置到行首</li><li>dw：剪切光标位置到单词的结尾（通常将光标移至单词首字符上）</li><li>x：删除一个字符。不改变工作模式</li><li>r：替换一个字符。通常将光标移至待替换字符上，按r，再按新字符。原被选中字符被新字符替换</li></ul></li></ul><h3 id="撤销和反撤销："><a href="#撤销和反撤销：" class="headerlink" title="撤销和反撤销："></a>撤销和反撤销：</h3><ul><li>u 命令模式下，撤销</li><li>Ctrl+r 命令模式下，反撤销</li></ul><h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><ol><li>想象一个字符串，去文档中查找<ul><li>命令模式下，按 “/”，光标出现在末行位置。键入待查找字符串</li><li>按 n 查找下一个</li></ul></li><li>看到一个字符串，查找它后续出现的位置<ul><li> 将光标移至字符串任意字符上</li><li> 按”*”向后找，按”#”向前找</li></ul></li></ol><h3 id="替换：【末行模式】"><a href="#替换：【末行模式】" class="headerlink" title="替换：【末行模式】"></a>替换：【末行模式】</h3><ul><li>单行替换：<ul><li>:s/旧字符串/新字符串，默认只替换光标所在行的一个，想替换全部加上”/g”</li></ul></li><li>通篇替换：<ul><li>:%s/旧字符串/新字符串，默认只替换每行的一个，想替换全部使用加上”/g”</li></ul></li><li>部分替换：<ul><li>:起始行号,终止行号s/旧字符串/新字符串，如果一行有多个，加上”/g”</li></ul></li></ul><h3 id="其他的vim指令："><a href="#其他的vim指令：" class="headerlink" title="其他的vim指令："></a>其他的vim指令：</h3><ul><li>:sp 横屏分 后面可以跟着文件名</li><li>:vsp 竖屏分 后面可以跟着文件名</li><li>vim -o file1 file2 上下打开</li><li>vim -O file1 file2 左右打开</li><li>ctrl+w+w 切换编辑屏幕</li><li>:wqall 退出所有</li><li>:!shell命令 可以在vim中执行shell命令。</li></ul><h3 id="vim的配置："><a href="#vim的配置：" class="headerlink" title="vim的配置："></a>vim的配置：</h3><ul><li>有两处配置位置：<ol><li>系统的配置目录位置：/etc/vim/vimrc    </li><li>用户的配置：~/.vimrc (注意：是隐藏文件。该文件默认不存在，需要手动创建。)</li></ol></li></ul><h3 id="远程文件传输："><a href="#远程文件传输：" class="headerlink" title="远程文件传输："></a>远程文件传输：</h3><ul><li>scp -r</li><li>上传：<ul><li>scp -r  本地文件的访问（相对、绝对） 目标主机用户名@目标主机IP:绝对存储路径（不能使用相对）</li></ul></li><li>下载：<ul><li>scp -r  目标主机用户名@目标主机IP:待下载文件的绝对存储路径（不能使用相对） 本地存储位置（相对、绝对）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.文件类型</title>
      <link href="2020/03/26/linux/8.%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/03/26/linux/8.%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ol><li><strong>普通文件-</strong>    占用磁盘存储</li><li><strong>目录文件d</strong>   占用磁盘存储</li><li><strong>软链接文件l</strong>  占用磁盘存储</li><li><strong>块设备文件b</strong>      伪文件，不占用磁盘存储</li><li><strong>字符设备文件c</strong>    伪文件，不占用磁盘存储</li><li><strong>管道文件p</strong>        伪文件，不占用磁盘存储</li><li><strong>套接字s</strong>          伪文件，不占用磁盘存储</li></ol><p>此外还有一种叫未知文件</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul><li>创建语法：<code>ln 源文件 硬链接文件</code></li><li>实现原理：源文件和硬链接文件之间有相同的inode (i节点) 指向同一块扇区，有点类似引用</li><li>硬链接计数：(使用ls -l查看时现实的)代表的是目录项的个数，目录项：包含文件名、inode</li><li>不能给目录创建硬链接</li><li>删除硬链接：即是删除目录项，断开和扇区的联系</li><li>目录也有硬链接计数，指的是进入该目录的方式有几种，使用.或..也算<br><img src="/photo/%E7%A1%AC%E9%93%BE%E6%8E%A5.png" alt="硬链接.png" loading="lazy"></li></ul><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ul><li>相当于windows的快捷方式</li><li>创建语法：<code>ln -s 源文件 软链接文件</code></li><li>软链接的大小取决于源文件路径的长度</li><li>建议使用绝对路径创建软链接</li><li>可以给目录创建软链接</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HelloWorld</title>
      <link href="2020/03/26/C++/helloworld/"/>
      <url>2020/03/26/C++/helloworld/</url>
      
        <content type="html"><![CDATA[<p>Hello World的正确打(zhuang)开(bi)方式</p><a id="more"></a><p>开始先上一段在<a href="https://www.youtube.com/watch?v=HPMvU64RUTY&t=193s">C++ Weekly</a>上看到的一段代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    [out = <span class="built_in">std</span>::ref(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello &quot;</span>)]()&#123;out.get() &lt;&lt; <span class="string">&quot;World!\n&quot;</span>;&#125;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们使用如下命令编译这段程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello -std=c++14</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>你会得到”Hello World!”的输出，然而想要搞懂这段代码，还要从C++11说起。</p><hr><p>C++11引入了lambda表达式可以用来创建匿名函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个匿名函数,但是匿名函数后续无法使用</span></span><br><span class="line">[]()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world!&quot;</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并使用匿名函数</span></span><br><span class="line">[]()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world!&quot;</span>;&#125;(); <span class="comment">// &quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure><p>匿名函数体内使用外部变量需要”捕获”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以得到与上面代码相同的结果</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">[str]()&#123;<span class="built_in">cout</span> &lt;&lt; str;&#125;(); <span class="comment">// &quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure><p>但是通过值捕获的str在匿名函数体内是只读的，你需要使用引用捕获的方式来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">[&amp;str]()&#123;</span><br><span class="line">  str = <span class="string">&quot;hello lambda!&quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; str;  <span class="comment">// &quot;hello lambda!&quot;</span></span><br><span class="line">&#125;();  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;    <span class="comment">// &quot;hello lambda&quot;</span></span><br></pre></td></tr></table></figure><p>关于lambda更多的内容我们就不再介绍，这里只铺垫了一些本文需要知道的一些知识。</p><hr><p>那么我们现在应该了解了文章开始的那段代码正是通过lambda表达式来实现的，下面我们由浅入深，一步一步来讲解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向cout写入&quot;hello &quot;，并为它创建一个引用</span></span><br><span class="line">ostream&amp; out = <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello &quot;</span>;  <span class="comment">// &quot;hello &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值捕获的本质是拷贝构造，但是ios_base的拷贝构造函数是私有的，所以下面这行代码会报错</span></span><br><span class="line"><span class="comment">// error [out]()&#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们需要使用引用捕获</span></span><br><span class="line">[&amp;out]()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;world!&quot;</span>;&#125;(); <span class="comment">// &quot;world!&quot;</span></span><br></pre></td></tr></table></figure><p>上面的程序会输出”hello world!”.我们也可以把两行代码并到一行来写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&amp;out = <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello &quot;</span>]()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;world!&quot;</span>;&#125;();</span><br></pre></td></tr></table></figure><p>由于lambda capture initializers是C++14标准提供的，所以我们需要使用如下命令编译我们的程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello -std=c++14</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>C++11中引入了std::ref用于取某个变量的引用，它包含在头文件functional中，所以上面的代码可以改成下面的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[out = ref(<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello &quot;</span>)]()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;world!&quot;</span>;&#125;();</span><br></pre></td></tr></table></figure><p>编译执行，我们可以得到输出”hello world!”，需要注意的是，要自己手动编译执行，亲测在dev-cpp中会报错。而这里ref返回的对象相当于ostream&amp;&amp;，我们可以调用ref.get()得到ostream&amp;类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[out = ref(<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello &quot;</span>)]()&#123;out.get() &lt;&lt; <span class="string">&quot;world!&quot;</span>;&#125;();</span><br></pre></td></tr></table></figure><p>lambda表达式是C++11带来的一颗语法糖(即不通过该形式也可达到同样的效果)，但考虑到代码的可读性，在较复杂的一些情况还是不要使用lambda表达式为好。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lambda</title>
      <link href="2020/03/25/C++/lambda/"/>
      <url>2020/03/25/C++/lambda/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="lambda表达式-std-c-11"><a href="#lambda表达式-std-c-11" class="headerlink" title="lambda表达式 -std=c++11"></a>lambda表达式 -std=c++11</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">[=]() &#123;</span><br><span class="line">    a = <span class="number">1</span>;  <span class="comment">//不可以，这里a只读</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[a]() &#123;     <span class="comment">//只传a</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">0</span>;</span><br><span class="line">[=]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">   a = <span class="number">1</span>;   <span class="comment">//可以，但是只是修改了函数内拷贝的a</span></span><br><span class="line">   b = <span class="number">1</span>;   <span class="comment">//不可以，外部的b是只读的，加了mutable也没用</span></span><br><span class="line">&#125;();        <span class="comment">//()调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">[&amp;]() &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;();    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">[&amp;a]() &#123;    <span class="comment">//只传a的引用</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = []()-&gt;<span class="keyword">int</span> &#123; <span class="comment">//返回值为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r;  <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">this</span>]() &#123;  <span class="comment">//会把lambda所在作用域的this指针传进来</span></span><br><span class="line"></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.常用算法</title>
      <link href="2020/03/24/C++/20.%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>2020/03/24/C++/20.%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ul><li>算法主要是由头文件algorithm functional numeric组成。</li><li>algorithm是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…</li><li>numeric体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</li><li>functional定义了一些模板类,用以声明函数对象。</li></ul><h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历算法 遍历容器元素</span></span><br><span class="line"><span class="comment">@param beg 开始迭代器</span></span><br><span class="line"><span class="comment">@param end 结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback  函数回调或者函数对象</span></span><br><span class="line"><span class="comment">@return 函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">transform算法 将指定容器区间元素搬运到另一容器中</span></span><br><span class="line"><span class="comment">注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span></span><br><span class="line"><span class="comment">@param beg1 源容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 源容器结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@param _cakkback 回调函数或者函数对象</span></span><br><span class="line"><span class="comment">@return 返回目标容器迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">transform(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br></pre></td></tr></table></figure><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><ul><li>有返回值</li><li>可以绑定参数进行输出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template&lt;class _InIt,class _Fn1&gt; inline</span></span><br><span class="line"><span class="comment">void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">for (; _First != _Last; ++_First)</span></span><br><span class="line"><span class="comment">_Func(*_First);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print001</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print001());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print02</span>&#123;</span></span><br><span class="line">print02()&#123;</span><br><span class="line">mCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">mCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print02 p = for_each(v.begin(), v.end(), print02());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.mCount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print03</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt;&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> bindParam)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val + bindParam &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each绑定参数输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind2nd(print03(),<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><ul><li>注意：目标容器必须有容量才可以搬运<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform 将一个容器中的值搬运到另一个容器中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline </span></span><br><span class="line"><span class="comment">_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (; _First != _Last; ++_First, ++_Dest)</span></span><br><span class="line"><span class="comment">*_Dest = _Func(*_First);</span></span><br><span class="line"><span class="comment">return (_Dest);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline</span></span><br><span class="line"><span class="comment">_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)</span></span><br><span class="line"><span class="comment">*_Dest = _Func(*_First1, *_First2);</span></span><br><span class="line"><span class="comment">return (_Dest);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">transformTest01</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">print01</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vSource;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">vSource.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//给vTarget开辟空间</span></span><br><span class="line">vTarget.resize(vSource.size());</span><br><span class="line"><span class="comment">//将vSource中的元素搬运到vTarget</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器1和容器2中的元素相加放入到第三个容器中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">transformTest02</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vSource1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vSource2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">vSource1.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//给vTarget开辟空间</span></span><br><span class="line">vTarget.resize(vSource1.size());</span><br><span class="line">transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find算法 查找元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value 查找的元素</span></span><br><span class="line"><span class="comment">@return 返回查找元素的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">find(iterator beg, iterator end, value)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find_if算法 条件查找</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return bool 查找返回true 否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">find_if(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">adjacent_find算法 查找相邻重复元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param  _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return 返回相邻元素的第一个位置的迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">adjacent_find(iterator beg, iterator end, _callback);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">binary_search算法 二分查找法</span></span><br><span class="line"><span class="comment">注意: 在无序序列中不可用</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value 查找的元素</span></span><br><span class="line"><span class="comment">@return bool 查找返回true 否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(iterator beg, iterator end, value)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param  value回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return int返回元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">count(iterator beg, iterator end, value);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count_if算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return int返回元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">count_if(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li>按值进行查找</li><li>如果查找的是自定义数据类型，需要重载==<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找5元素是否存在</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ret = find(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != v.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素：&quot;</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找大于5的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ret2 = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (ret2 != v.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了大于5的元素：&quot;</span> &lt;&lt; *ret2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><ul><li>按条件进行查找</li><li>可以查找自定义数据类型指针，配合适配器使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;v;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找p4 的数据</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator ret = find(v.begin(), v.end(), p);</span><br><span class="line"><span class="keyword">if</span> (ret != v.end())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了 姓名：&quot;</span> &lt;&lt; (*ret).m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; ret-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myCompare</span>:</span><span class="keyword">public</span> binary_function&lt;Person*,Person*,<span class="keyword">bool</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person * p1 , Person * p2)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p1-&gt;m_Name == p2-&gt;m_Name  &amp;&amp; p1-&gt;m_Age == p2-&gt;m_Age)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person*&gt;v;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line">Person * person = <span class="keyword">new</span> Person(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person *&gt;::iterator ret = find_if(v.begin(), v.end(), bind2nd( myCompare(), person ));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret != v.end())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素姓名： &quot;</span> &lt;&lt; (*ret)-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; (*ret)-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><ul><li>查找相邻重复元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = adjacent_find(v.begin(), v.end());</span><br><span class="line"><span class="keyword">if</span> (it != v.end())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到相邻重复元素为： &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><ul><li>二分查找，必须在有序序列中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v.push_back(3); 容器必须是有序序列！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = binary_search(v.begin(), v.end(), <span class="number">9</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul><li>按值统计元素个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计5的元素个数  按值统计个数</span></span><br><span class="line"><span class="keyword">int</span> num= count(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5的个数为：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><ul><li>按条件统计元素个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9 5 5 5 5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找大于等于5的元素个数</span></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), GreaterFive1());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于等于5的个数为：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">merge算法 容器元素合并，并存储到另一容器中</span></span><br><span class="line"><span class="comment">注意:两个容器必须是有序的</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sort算法 容器元素排序</span></span><br><span class="line"><span class="comment">@param beg 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sort(iterator beg, iterator end, _callback)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">random_shuffle算法 对指定范围内的元素随机调整次序</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">random_shuffle(iterator beg, iterator end)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reverse算法 反转指定范围的元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reverse(iterator beg, iterator end)</span><br></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><ul><li>将两个有序的容器，合并到目标容器中</li><li>注意：目标容器必须提前开辟容量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">    v2.push_back(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line">vTarget.resize(v1.size() + v2.size());</span><br><span class="line">merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">// []()&#123;&#125; 匿名函数  lambda表达式</span></span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), [](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用sort降序</span></span><br><span class="line">sort(v1.begin(), v1.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">for_each(v1.begin(), v1.end(), [](<span class="keyword">int</span> val)&#123; <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><ul><li>洗牌算法，随机打乱容器中元素顺序</li><li>配合随机数种子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">random_shuffle(v1.begin(), v1.end());</span><br><span class="line">for_each(v1.begin(), v1.end(), [](<span class="keyword">int</span> val)&#123; <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">v1.push_back(<span class="number">100</span>);</span><br><span class="line">v1.push_back(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转前遍历结果： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v1.begin(), v1.end(), [](<span class="keyword">int</span> val)&#123; <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">reverse(v1.begin(), v1.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转后遍历结果： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v1.begin(), v1.end(), [](<span class="keyword">int</span> val)&#123; <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">copy算法 将容器内指定范围的元素拷贝到另一容器中</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标起始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">copy(iterator beg, iterator end, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">replace算法 将容器内指定范围的旧元素修改为新元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param oldvalue 旧元素</span></span><br><span class="line"><span class="comment">@param newvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">replace(iterator beg, iterator end, oldvalue, newvalue)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param callback函数回调或者谓词(返回Bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@param oldvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">replace_if(iterator beg, iterator end, _callback, newvalue)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">swap算法 互换两个容器的元素</span></span><br><span class="line"><span class="comment">@param c1容器1</span></span><br><span class="line"><span class="comment">@param c2容器2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">swap(container c1, container c2)</span><br></pre></td></tr></table></figure><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2.resize(v.size());</span><br><span class="line">copy(v.begin(), v.end(), v2.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each(v2.begin(), v2.end(), [](int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用copy做迭代输出，头文件iterator</span></span><br><span class="line">copy(v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="replace-replace-if"><a href="#replace-replace-if" class="headerlink" title="replace/replace_if"></a>replace/replace_if</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceIF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的3  替换为 3000</span></span><br><span class="line">replace(v.begin(), v.end(), <span class="number">3</span>, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 0 1 2 3000 4 5 6 7 8 9 </span></span><br><span class="line">copy(v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有大于3的值 替换为30000</span></span><br><span class="line">replace_if(v.begin(), v.end(), ReplaceIF(), <span class="number">30000</span>);</span><br><span class="line"><span class="comment">// // 0 1 2 30000  30000 ....</span></span><br><span class="line">copy(v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">    v2.push_back(i+<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前的结果为：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">copy(v1.begin(), v1.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">copy(v2.begin(), v2.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">swap(v1, v2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后的结果为：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">copy(v1.begin(), v1.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">copy(v2.begin(), v2.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="常用算数生成算法"><a href="#常用算数生成算法" class="headerlink" title="常用算数生成算法"></a>常用算数生成算法</h2><ul><li>头文件：numeric<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">accumulate算法 计算容器元素累计总和</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value初始累加值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">accumulate(iterator beg, iterator end, value)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fill算法 向容器中添加元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value t填充元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fill(iterator beg, iterator end, value)</span><br></pre></td></tr></table></figure></li></ul><h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>;i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = accumulate(v.begin(), v.end(), <span class="number">1000</span>); <span class="comment">//参数3 累加起始值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">v.resize(<span class="number">10</span>);</span><br><span class="line">fill(v.begin(), v.end(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">copy(v.begin(), v.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_intersection算法 求两个set集合的交集</span></span><br><span class="line"><span class="comment">注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_union算法 求两个set集合的并集</span></span><br><span class="line"><span class="comment">注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_difference算法 求两个set集合的差集</span></span><br><span class="line"><span class="comment">注意:两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest  目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br></pre></td></tr></table></figure><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><ul><li>注意:两个集合必须是有序序列<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">    v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget;</span><br><span class="line">vTarget.resize(min(v1.size(), v2.size()));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里使用vTarget.end()会把整个容量都打出来，itEnd只打印有效范围</span></span><br><span class="line">for_each(vTarget.begin(), itEnd, [](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><ul><li>注意:两个集合必须是有序序列<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">    v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget;</span><br><span class="line">vTarget.resize( v1.size() + v2.size() );</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, [](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><ul><li>注意:两个集合必须是有序序列<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.push_back(i);</span><br><span class="line">    v2.push_back(i + <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget;</span><br><span class="line">vTarget.resize( max(v1.size(),v2.size()) );</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, [](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, [](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19.适配器</title>
      <link href="2020/03/24/C++/19.%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>2020/03/24/C++/19.%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">void</span>&gt; &#123; <span class="comment">//因为是二元函数，所以继承binary_function，模板参数对应下面的参数类型和返回值类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num , <span class="keyword">int</span> start)</span> <span class="keyword">const</span> </span>&#123;    <span class="comment">//父类有写const，是个虚函数，这里也要写</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt;  num &lt;&lt; <span class="string">&quot; start = &quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot; sum = &quot;</span> &lt;&lt; num  + start  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入起始累加值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; start;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind2nd(MyPrint(), start)); <span class="comment">//推荐，这里把start绑定在函子的第二个参数上</span></span><br><span class="line"><span class="comment">//for_each(v.begin(), v.end(), bind1st(MyPrint(), start));  //start绑定在第一个参数上</span></span><br></pre></td></tr></table></figure><h3 id="取反适配器"><a href="#取反适配器" class="headerlink" title="取反适配器"></a>取反适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; &#123;   <span class="comment">//一元函数继承unary_function</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元取反适配器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator ret = find_if(v.begin(), v.end(), not1(GreaterFive()));</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ret = find_if(v.begin(), v.end(), not1(bind2nd(greater&lt;<span class="keyword">int</span>&gt;(),<span class="number">5</span>)));   <span class="comment">//一元函数取反not1</span></span><br><span class="line"><span class="keyword">if</span> (ret != v.end()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到小于5的数据为&quot;</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二元取反适配器</span></span><br><span class="line">sort(v.begin(), v.end(), not2(less&lt;<span class="keyword">int</span>&gt;()));    <span class="comment">//二元函数取反not2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end();it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="函数指针适配器"><a href="#函数指针适配器" class="headerlink" title="函数指针适配器"></a>函数指针适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val + start &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入起始累加值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; start;</span><br><span class="line"><span class="comment">//将myPrint函数指针 适配成 函数对象 即可</span></span><br><span class="line"><span class="comment">//利用 ptr_fun</span></span><br><span class="line">for_each(v.begin(), v.end(), bind2nd(ptr_fun(myPrint), start));</span><br></pre></td></tr></table></figure><h3 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="成员函数适配器"></a>成员函数适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用mem_fun_ref 将成员函数进行适配</span></span><br><span class="line">for_each(v.begin(), v.end(), mem_fun_ref( &amp;Person::showPerson));</span><br><span class="line">for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::addAge));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::showPerson));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数对象和谓词</title>
      <link href="2020/03/24/C++/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%B0%93%E8%AF%8D/"/>
      <url>2020/03/24/C++/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%B0%93%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><ol><li>重载了()的类，称仿函数</li><li>通过仿函数实例化的对象称为函数对象</li><li>可以拥有内部自己的状态，超出普通函数的概念</li><li>类内实现的函数可以内联编译</li><li>可以作为函数参数传递</li></ol><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><ul><li>返回值为bool的函数或仿函数</li><li>一个参数叫一元谓词，两个参数叫二元谓词</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18.STL</title>
      <link href="2020/03/22/C++/18.STL/"/>
      <url>2020/03/22/C++/18.STL/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><ul><li>STL是惠普实验室开发的一系列软件的统称，现主要出现在C++中，但是在C++出现之前STL就已经存在很长时间了</li><li>STL从广义上分为：容器、算法、迭代器，容器和算法之间通过迭代器进行无缝连接<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3></li><li>容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数</li></ul><ol><li>容器(class template)<ul><li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</li><li>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器。</li></ul></li><li>算法(function template)</li><li>迭代器(class template)<ul><li>重载了* -&gt; ++ –等运算符</li><li>原生指针也是一种迭代器</li></ul></li><li>仿函数(class template)<ul><li>重载了()运算符</li></ul></li><li>适配器<ul><li>一种用来修饰容器或仿函数或迭代器接口的东西</li></ul></li><li>空间配置器(class template)<ul><li>负责空间的配置与管理</li><li>实现了动态空间配置，空间管理，空间释放<h3 id="迭代器的种类"><a href="#迭代器的种类" class="headerlink" title="迭代器的种类"></a>迭代器的种类</h3></li></ul></li></ol><ul><li>一般双向迭代器起步</li></ul><table><thead><tr><th align="center">名字</th><th align="center">功能</th><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">输入迭代器</td><td align="center">提供对数据的只读访问</td><td align="center">只读，支持++、==、！=</td></tr><tr><td align="center">输出迭代器</td><td align="center">提供对数据的只写访问</td><td align="center">只写，支持++</td></tr><tr><td align="center">前向迭代器</td><td align="center">提供读写操作，并能向前推进迭代器</td><td align="center">读写，支持++、==、！=</td></tr><tr><td align="center">双向迭代器</td><td align="center">提供读写操作，并能向前和向后操作</td><td align="center">读写，支持++、–，</td></tr><tr><td align="center">随机访问迭代器</td><td align="center">提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td><td align="center">读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><ul><li>iterator普通迭代器</li><li>reverse_iterator反向迭代器</li><li>const_iterator只读迭代器(函数传一个const vector<int> &amp;v，遍历需要只读迭代器)<h3 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h3></li></ul><ol><li>高可重用性：STL中几乎所有代码都采用了模板类和模板函数的方式实现</li><li>高性能：如map可以高效的从上亿记录中查找出指定的记录，底层是采用红黑树的变体实现的</li><li>高移植性：如项目A用STL编写的模块，可以直接移植到项目B上</li></ol><h3 id="容器使用时机"><a href="#容器使用时机" class="headerlink" title="容器使用时机"></a>容器使用时机</h3><ul><li>vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</li><li>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</li><li>vector与deque的比较：<pre><code>1. vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置    却是不固定的。</code></pre><ol start="2"><li>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li><li>deque支持头部的快速插入与快速移除，这是deque的优点。</li></ol></li><li>list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</li><li>set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </li><li>map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</li></ul><h2 id="二-string容器"><a href="#二-string容器" class="headerlink" title="二. string容器"></a>二. string容器</h2><blockquote><p>string也是通过char*实现的</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str;      </span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">int</span> n, <span class="keyword">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br></pre></td></tr></table></figure><h3 id="基本赋值操作"><a href="#基本赋值操作" class="headerlink" title="基本赋值操作"></a>基本赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span> c);<span class="comment">//字符赋值给当前的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure><h3 id="存取字符操作"><a href="#存取字符操作" class="headerlink" title="存取字符操作"></a>存取字符操作</h3><ul><li>[]如果越界了，程序会终止</li><li>at如果越界了，会抛出out_of_range异常<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n);<span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">at</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="拼接操作"><a href="#拼接操作" class="headerlink" title="拼接操作"></a>拼接操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class="line"><span class="comment">大写的A比小写的a小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> <span class="keyword">const</span></span>;<span class="comment">//与字符串s比较</span></span><br></pre></td></tr></table></figure><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> pos = <span class="number">0</span>, <span class="keyword">int</span> n = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure><h3 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符 </span></span><br></pre></td></tr></table></figure><h3 id="string和c-style字符串转换"><a href="#string和c-style字符串转换" class="headerlink" title="string和c-style字符串转换"></a>string和c-style字符串转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"><span class="comment">//char* 转 string </span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>&amp; a = s[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span>&amp; b = s[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">b = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;pppppppppppppppppppppppp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = &#x27;1&#x27;; </span></span><br><span class="line"><span class="comment">//b = &#x27;2&#x27;; 会崩掉，s重新分配内存了，但如果s=&quot;pppp&quot;没那么长就不会重新分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;heLLo&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">    s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">    s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><blockquote><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是容量的概念。换句话说，一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。<br><strong>注意</strong></p></blockquote><ul><li>所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间，不像relloc还要看看后面有没有足够的位置)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。这是程序员容易犯的一个错误，务必小心。</li><li>vector是单端数组，虽然可以头插头删，但是效率低<br><img src="/photo/vector.png" alt="vector" loading="lazy"></li></ul><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.begin(), v.end());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> <span class="built_in">vector</span> &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>; </span><br></pre></td></tr></table></figure><h3 id="常用赋值操作"><a href="#常用赋值操作" class="headerlink" title="常用赋值操作"></a>常用赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">vector</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>  &amp;vec);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(vec);<span class="comment">// 将vec与本身的元素互换。</span></span><br></pre></td></tr></table></figure><h3 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line">resize(<span class="keyword">int</span> num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">resize(<span class="keyword">int</span> num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class="line">capacity();<span class="comment">//容器的容量</span></span><br><span class="line">reserve(<span class="keyword">int</span> len);<span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure><h3 id="数据存取操作"><a href="#数据存取操作" class="headerlink" title="数据存取操作"></a>数据存取操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(<span class="keyword">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line">front();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line">back();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure><h3 id="插入和删除操作-1"><a href="#插入和删除操作-1" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert(const_iterator pos, <span class="keyword">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line">push_back(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line">pop_back();<span class="comment">//删除最后一个元素</span></span><br><span class="line">erase(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line">erase(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line">clear();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure><h3 id="巧用swap收缩内存空间"><a href="#巧用swap收缩内存空间" class="headerlink" title="巧用swap收缩内存空间"></a>巧用swap收缩内存空间</h3><ul><li>vector<int>(v).swap(v);</li><li>v可能cap很大，size很小</li><li>vector<int>(v)通过拷贝构造一个匿名对象，其cap等于v的size</li><li>交换，然后匿名对象会被释放<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时 通过resize改变容器大小</span></span><br><span class="line">v.resize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量没有改变</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="reserve预留空间"><a href="#reserve预留空间" class="headerlink" title="reserve预留空间"></a>reserve预留空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预先开辟空间</span></span><br><span class="line">v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* pStart = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i ++)&#123;   <span class="comment">//count统计多少次重新开辟内存</span></span><br><span class="line">    v.push_back(i);</span><br><span class="line">    <span class="keyword">if</span> (pStart != &amp;v[<span class="number">0</span>])&#123;</span><br><span class="line">        pStart = &amp;v[<span class="number">0</span>];</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="逆序遍历"><a href="#逆序遍历" class="headerlink" title="逆序遍历"></a>逆序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit = v.rbegin(); rit != v.rend(); ++rit);</span><br></pre></td></tr></table></figure><h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><ul><li>vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受</li><li>deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能</li><li>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque</li></ul><p><img src="/photo/deque.png" alt="deque" loading="lazy"></p><ul><li>deque实现原理:分段存储，内存不连续</li></ul><p><img src="/photo/deque%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="deque" loading="lazy"></p><h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line">swap(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure><h3 id="大小操作-1"><a href="#大小操作-1" class="headerlink" title="大小操作"></a>大小操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">deque</span>.empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num);<span class="comment">//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num, elem); <span class="comment">//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure><h3 id="双端插入删除操作"><a href="#双端插入删除操作" class="headerlink" title="双端插入删除操作"></a>双端插入删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line">pop_back();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line">pop_front();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line">front();<span class="comment">//返回第一个数据。</span></span><br><span class="line">back();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure><h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><ul><li>没有迭代器</li></ul><h3 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作-1"><a href="#赋值操作-1" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line">pop();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line">top();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure><h3 id="大小操作-2"><a href="#大小操作-2" class="headerlink" title="大小操作"></a>大小操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();<span class="comment">//判断堆栈是否为空</span></span><br><span class="line">size();<span class="comment">//返回堆栈的大小</span></span><br></pre></td></tr></table></figure><h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><ul><li>没有迭代器</li></ul><h3 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; queT;<span class="comment">//queue采用模板类实现，queue对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h3 id="存取插入删除操作"><a href="#存取插入删除操作" class="headerlink" title="存取插入删除操作"></a>存取插入删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line">pop();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line">back();<span class="comment">//返回最后一个元素</span></span><br><span class="line">front();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作-2"><a href="#赋值操作-2" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure><h3 id="大小操作-3"><a href="#大小操作-3" class="headerlink" title="大小操作"></a>大小操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();<span class="comment">//判断队列是否为空</span></span><br><span class="line">size();<span class="comment">//返回队列的大小</span></span><br></pre></td></tr></table></figure><h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><ul><li>双向循环链表，提供双向迭代器</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。<br><img src="/photo/list.png" alt="list" loading="lazy"></li></ul><h3 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><h3 id="插入删除操作"><a href="#插入删除操作" class="headerlink" title="插入删除操作"></a>插入删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line">pop_back();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line">pop_front();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line">insert(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line">remove(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure><h3 id="大小操作-4"><a href="#大小操作-4" class="headerlink" title="大小操作"></a>大小操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line">resize(num);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><h3 id="赋值操作-3"><a href="#赋值操作-3" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">assign(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">list</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure><h3 id="数据存取-1"><a href="#数据存取-1" class="headerlink" title="数据存取"></a>数据存取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front();<span class="comment">//返回第一个元素。</span></span><br><span class="line">back();<span class="comment">//返回最后一个元素。</span></span><br></pre></td></tr></table></figure><h3 id="反转排序"><a href="#反转排序" class="headerlink" title="反转排序"></a>反转排序</h3><ul><li>标准sort()算法只适用于支持随机访问迭代器的容器</li><li>不支持随机访问迭代器的容器内部会提供sort()方法，这里的sort()也可以提供cmp回调函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line">sort(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h2><ul><li>set的元素既是key又是value</li><li>set不允许有重复key，multiset允许，这是唯一的区别</li><li>不可以通过set迭代器修改set元素的值，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator</li><li>set的底层实现是红黑树</li><li>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外</li></ul><h3 id="构造函数-6"><a href="#构造函数-6" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;T&gt; st;<span class="comment">//set默认构造函数：</span></span><br><span class="line">mulitset&lt;T&gt; mst; <span class="comment">//multiset默认构造函数: </span></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作-4"><a href="#赋值操作-4" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><h3 id="大小操作-5"><a href="#大小操作-5" class="headerlink" title="大小操作"></a>大小操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><h3 id="插入删除操作-1"><a href="#插入删除操作-1" class="headerlink" title="插入删除操作"></a>插入删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line">clear();<span class="comment">//清除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(elem);<span class="comment">//删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line">count(key);<span class="comment">//查找键key的元素个数</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。返回类型pair&lt;iterator,iterator&gt;</span></span><br></pre></td></tr></table></figure><h3 id="insert返回值和排序规则"><a href="#insert返回值和排序规则" class="headerlink" title="insert返回值和排序规则"></a>insert返回值和排序规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入成功:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入失败:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(ret.second)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入成功:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入失败:&quot;</span> &lt;&lt; *ret.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare02</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set从大到小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare02&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">s.insert(rand() % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set容器中存放对象，也可以通过重载运算符解决自定义类型的问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare03</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1,<span class="keyword">const</span> Person&amp; p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p1.mAge &gt; p2.mAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Person, MyCompare03&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; it-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; it-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pair类模板"><a href="#pair类模板" class="headerlink" title="pair类模板"></a>pair类模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法创建一个对组</span></span><br><span class="line">pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.first &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//访问pair第一个值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//访问pair第二个值</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2 = <span class="built_in">make_pair</span>(<span class="string">&quot;name&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//pair=赋值</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3 = pair2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h2><ul><li>map的键值会自动排序，map的所有元素都是pair</li><li>不可以通过迭代器修改元素键值</li><li>底层通过红黑树实现</li><li>multimap键值可重复</li><li>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外</li></ul><h3 id="构造函数-7"><a href="#构造函数-7" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;T1, T2&gt; mapTT;<span class="comment">//map默认构造函数: </span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作-5"><a href="#赋值操作-5" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(mp);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><h3 id="大小操作-6"><a href="#大小操作-6" class="headerlink" title="大小操作"></a>大小操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><h3 id="插入数据元素操作"><a href="#插入数据元素操作" class="headerlink" title="插入数据元素操作"></a>插入数据元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStu;</span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.inset(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//删除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure><h3 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span></span><br><span class="line">count(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure><h3 id="自定义排序规则"><a href="#自定义排序规则" class="headerlink" title="自定义排序规则"></a>自定义排序规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;    <span class="comment">//key值</span></span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, myCompare&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, myCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常对象</title>
      <link href="2020/03/14/C++/%E5%B8%B8%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/03/14/C++/%E5%B8%B8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>常对象只能调用常成员函数，无法修改成员变量，mutable除外</p><pre><code class="C++">class T &#123;public:    int a;    mutable int b;    void f1()&#123;&#125;    void f2() const &#123;&#125;&#125;const T t;t.a = 10;   //nokt.b = 10;   //okt.f1();     //nokt.f2();     //ok</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关键字大全</title>
      <link href="2020/03/14/C++/%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E5%85%A8/"/>
      <url>2020/03/14/C++/%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><table><thead><tr><th align="center">关键字</th><th align="center">作用</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">mutable</td><td align="center">修饰类成员变量，使其在常函数或常对象中可以被修改</td><td align="center">C++</td></tr><tr><td align="center">register</td><td align="center">修饰需要高频繁使用的变量，使其存储在寄存器中，不能取地址</td><td align="center">C</td></tr><tr><td align="center">volatile</td><td align="center">防止编译器优化，如果一个变量频繁使用，防止编译器将其存储在寄存器，该关键字可以强制内存访问</td><td align="center">C</td></tr><tr><td align="center"><a href="/post/explicit">explicit</a></td><td align="center">抑制隐式转换调用构造函数</td><td align="center">C++</td></tr><tr><td align="center">restrict</td><td align="center">被修饰的对象指针不能被其他指针引用</td><td align="center">C</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类的存储</title>
      <link href="2020/03/14/C++/%E7%B1%BB%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>2020/03/14/C++/%E7%B1%BB%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li>空类大小为1字节</li><li>非静态成员存储在对象上</li><li>静态成员不存储在对象上</li><li>非静态成员函数不存储在对象上</li><li>静态成员函数不存储在对象上</li><li>类的成员变量和成员函数是分开存储的</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>externc</title>
      <link href="2020/03/12/C++/externc/"/>
      <url>2020/03/12/C++/externc/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>编译器为了实现C++的函数重载会为函数重新命名，但是C语言中没有函数重载，所以C++中想要使用C定义的函数需要用extern “C”修饰函数声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cpluscplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>C语言中是没法使用extern “C”的，所以需要条件编译</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调用惯例</title>
      <link href="2020/03/11/C++/%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B/"/>
      <url>2020/03/11/C++/%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="调用惯例-主调函数和被调函数需要一个共同遵守的约定，函数才能被正确调用"><a href="#调用惯例-主调函数和被调函数需要一个共同遵守的约定，函数才能被正确调用" class="headerlink" title="调用惯例:主调函数和被调函数需要一个共同遵守的约定，函数才能被正确调用"></a>调用惯例:主调函数和被调函数需要一个共同遵守的约定，函数才能被正确调用</h3><ol><li>参数传递顺序与方式<ul><li>函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。</li></ul></li><li>栈的维护方式<ul><li>在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。</li></ul></li><li>函数名修饰<ul><li>为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。</li></ul></li></ol><p><strong>事实上，在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是：<code>int _cdecl func(int a,int b);</code></strong></p><p>注意: <em>cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在<em>cdecl这样的关键字，而是使用__attribute</em></em>((cdecl)).</p><table><thead><tr><th align="center">调用惯例</th><th align="center">出栈方(由谁来释放形参)</th><th align="center">参数传递</th><th align="center">名字修饰</th></tr></thead><tbody><tr><td align="center">cdecl</td><td align="center">函数调用方</td><td align="center">从右至左参数入栈</td><td align="center">下划线+函数名</td></tr><tr><td align="center">stdcall</td><td align="center">函数本身</td><td align="center">从右至左参数入栈</td><td align="center">下划线+函数名+@+参数字节数</td></tr><tr><td align="center">fastcall</td><td align="center">函数本身</td><td align="center">前两个参数由寄存器传递，其余参数通过堆栈传递</td><td align="center">@+函数名+@+参数字节数</td></tr><tr><td align="center">pascal</td><td align="center">函数本身</td><td align="center">从左至右参数入栈</td><td align="center">较为复杂，参见相关文档</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const增强</title>
      <link href="2020/03/11/C++/const%E5%A2%9E%E5%BC%BA/"/>
      <url>2020/03/11/C++/const%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>在C++中对const做了增强</p><p>就全局const变量而言，与C一样，存放在文字常量区，通过指针间接修改，语法可以通过，但是会受到操作系统的保护导致程序崩溃(C++中需要注意的是给指针赋值需要做类型转换)</p><p>对局部const变量而言，C语言中，变量开辟在栈中，所以可以通过指针间接修改变量的值，但是在C++中，变量存放在程序自己维护的符号表中，一个const变量名就对应一个值，当对该变量取地址的时候，会生成一个临时变量，分配临时内存，通过指针修改的也是临时变量，所以在C++中可以把const变量当作常量使用</p><p>上述是指使用常量初始化const变量的情况，但如果是使用变量初始化局部const变量，是会分配内存的，也可以通过指针间接修改const局部变量的值。const自定义数据类型也会分配内存</p><p><strong>总结：C++局部const变量使用常量初始化是可以当作常量使用的</strong></p><p>const在C语言中是外部链接的，在C++中默认是内部链接的，想要提高作用域需要extern关键字修饰</p><h3 id="尽量用const代替-define"><a href="#尽量用const代替-define" class="headerlink" title="尽量用const代替#define"></a>尽量用const代替#define</h3><ol><li>define的宏常量没有作用域限制</li><li>define的宏常量没有数据类型</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RK算法</title>
      <link href="2020/03/10/algo/RK%E7%AE%97%E6%B3%95/"/>
      <url>2020/03/10/algo/RK%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>RK算法是一种字符串匹配算法,传统的字符串匹配可以用暴力搜索(BF),遍历母串每一个字符，与字串相比较，时间复杂度为O(mn)</p><p>母串和子串之间的比较是一位一位的比较，时间很慢，但如果比较两个串的hash值，就可以很快的判定两个串是否相等了，hash算法有很多种</p><p>如果在母串的某个位置的hash值与字串相等，还要继续按位比较，因为有可能会产生hash冲突</p><p>但是计算串的hash值也需要遍历才能计算，时间复杂度还是O(mn)，这时候可以通过上一个串的hash值计算得到当前串的hash值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret += s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用如上hash算法，可得hash(“ace”) = 9</p><p>设母串为”cdbbeacepp”</p><h3 id="匹配过程："><a href="#匹配过程：" class="headerlink" title="匹配过程："></a>匹配过程：</h3><ol><li>hash(“cdb”) = 9                          == 9 按位匹配失败，继续</li><li>hash(“dbb”) = hash(“cdb”)-3+2 = 8        != 9 继续</li><li>hash(“bbe”) = hash(“dbb”)-4+5 = 9        == 9 按位匹配失败，继续</li><li>…</li><li>…</li><li>hash(“ace”) = 9                          == 9 按位匹配成功，返回</li></ol>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="2020/03/10/algo/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2020/03/10/algo/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="树的表示方法："><a href="#树的表示方法：" class="headerlink" title="树的表示方法："></a>树的表示方法：</h3><ol><li>图形表示法</li><li>广义表</li><li>左孩子右兄弟(把N叉树转换为2叉树)</li></ol><h3 id="二叉树的性质："><a href="#二叉树的性质：" class="headerlink" title="二叉树的性质："></a>二叉树的性质：</h3><ol><li>在二叉树的第i层上，至多有2^(i-1)个节点(i &gt; 0)</li><li>深度为k的二叉树上，至多有2^k-1个节点(k &gt; 0)</li><li>对于任一二叉树，若度为2的节点有n2个，则叶子数(n0)必为n2+1，即n0=n2+1</li><li>具有n个节点的完全二叉树的深度必为int(log2n)+1</li><li>对于完全二叉树，若从上至下，从左至右编号，则编号为i的节点，其左孩子节点为2i，右孩子节点为2i+1，双亲为i/2(i = 1为根节点)</li></ol><h3 id="求二叉树叶子数量："><a href="#求二叉树叶子数量：" class="headerlink" title="求二叉树叶子数量："></a>求二叉树叶子数量：</h3><ul><li>递归统计，左右子树为NULL认定为叶子</li></ul><h3 id="求二叉树高度："><a href="#求二叉树高度：" class="headerlink" title="求二叉树高度："></a>求二叉树高度：</h3><ul><li>递归统计，取max(左子高度，右子高度)+1</li></ul><h3 id="二叉树的拷贝："><a href="#二叉树的拷贝：" class="headerlink" title="二叉树的拷贝："></a>二叉树的拷贝：</h3><ol><li>拷贝左子树</li><li>拷贝右子树</li><li>malloc新节点</li><li>挂载左右子树</li><li>返回新节点</li></ol><h3 id="释放二叉树："><a href="#释放二叉树：" class="headerlink" title="释放二叉树："></a>释放二叉树：</h3><ol><li>释放左子树</li><li>释放右子树</li><li>free根节点</li></ol><h3 id="二叉树非递归遍历："><a href="#二叉树非递归遍历：" class="headerlink" title="二叉树非递归遍历："></a>二叉树非递归遍历：</h3><ol><li>为每一个节点加一个标志位 flag = 0</li><li>root入栈</li><li>while(!stack.isEmpty()):</li><li>e = pop()</li><li>e.flag == 1 ? 输出 : e.flag = 1, e.l e.r e依次入栈(先序)/e.l e e.r依次入栈(中序)/e e.l e.r依次入栈(后序)</li><li>continue</li></ol><h2 id="二叉树后继节点"><a href="#二叉树后继节点" class="headerlink" title="二叉树后继节点"></a>二叉树后继节点</h2><p>后继节点即在二叉树中序序列中，某节点的下一个节点</p><p>如果某节点的右子树不空，那么该节点后继节点为右子树最左节点</p><p>如果某节点x的右子树为空，那么找一个节点q，q的左子树的最右节点为x，则q为x的后继节点。寻找方法：令x父节点为p，如果x为左子节点，那么x的后继节点为p；如果x非左子节点，令x为p，p为新x父节点，直到x为左子节点（则p为所求节点的后继节点）或p为空（所求节点无后继节点）。</p><h2 id="判断二叉树平衡"><a href="#判断二叉树平衡" class="headerlink" title="判断二叉树平衡"></a>判断二叉树平衡</h2><p>从根开始递归，先判断左子树是否平衡，若平衡，再判断右子树是否平衡，若平衡，比较左子树和右子树高度判断该节点是否平衡，若平衡，返回当前节点平衡性及深度（子树更大深度+1）</p><h2 id="判断二叉搜索树"><a href="#判断二叉搜索树" class="headerlink" title="判断二叉搜索树"></a>判断二叉搜索树</h2><p>中序序列是升序的</p><h2 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h2><p>按层遍历，发现任何一个节点有右子无左子即可返回false，若发现节点有左子无右子（或无子，所以判断右子为空就行），则该节点后续的节点必须是叶节点</p><h2 id="求完全二叉树节点个数"><a href="#求完全二叉树节点个数" class="headerlink" title="求完全二叉树节点个数"></a>求完全二叉树节点个数</h2><ul><li>时间复杂度：$O(log^2 n)$</li></ul><ol><li>先遍历二叉树左边界，确定二叉树深度</li><li>遍历根节点右子树左遍历，判断是否走到最后一层<ul><li>是，则根左子树为满二叉树，利用公式$2^n-1$可得左子树节点数量<ul><li>递归求根右子树</li></ul></li><li>否，则根右子树为满二叉树，利用公式$2^n-1$可得右子树节点数量<ul><li>递归求根左子树</li></ul></li></ul></li></ol><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="2020/03/09/algo/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>2020/03/09/algo/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>一个数组，想要查询[L.R]内的和，时间复杂度为O(n),查询某一个点的值，时间复杂度为O(1)</p><p>使用前缀和，则查询[L,R]内的和，时间复杂度为O(1),查询某一个点的值，时间复杂度为O(n)</p><p>使用线段树，则查询[L,R]内的和与查询某一个点的值，时间复杂度都为O(logn)</p><p><img src="/photo/%E7%BA%BF%E6%AE%B5%E6%A0%91.png" alt="线段树" loading="lazy"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">tree[node] = arr[start];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> left_node  = <span class="number">2</span>*node+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right_node = <span class="number">2</span>*node+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">build_tree(arr,tree,left_node,start,mid);</span><br><span class="line">build_tree(arr,tree,right_node,mid+<span class="number">1</span>,end);</span><br><span class="line">tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> tree[MAX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">build_tree(arr,tree,<span class="number">0</span>,<span class="number">0</span>,size<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,tree[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单点更新</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_tree</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">arr[idx] = val;</span><br><span class="line">tree[node] = val;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> left_node  = <span class="number">2</span>*node+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right_node = <span class="number">2</span>*node+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(idx &gt;= start &amp;&amp; idx &lt;= mid) &#123;</span><br><span class="line">update_tree(arr,tree,left_node,start,mid,idx,val);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">update_tree(arr,tree,right_node,mid+<span class="number">1</span>,end,idx,val);;</span><br><span class="line">&#125;</span><br><span class="line">tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区间和查询</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_tree</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;<span class="comment">//区间查询，这里是[L,R]</span></span><br><span class="line"><span class="keyword">if</span>(R &lt; start || L &gt; end) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(L &lt;= start &amp;&amp; end &lt;= R) &#123;</span><br><span class="line"><span class="keyword">return</span> tree[node];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> left_node  = <span class="number">2</span>*node+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right_node = <span class="number">2</span>*node+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sum_left = query_tree(arr,tree,left_node,start,mid,L,R);</span><br><span class="line"><span class="keyword">int</span> sum_right = query_tree(arr,tree,right_node,mid+<span class="number">1</span>,end,L,R);</span><br><span class="line"><span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后缀表达式</title>
      <link href="2020/03/08/algo/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2020/03/08/algo/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>*<em>中缀：8 + (3 - 1) * 5*</em></p><p>*<em>后缀：8 3 1 - 5 * +*</em></p><h3 id="中缀转后缀算法："><a href="#中缀转后缀算法：" class="headerlink" title="中缀转后缀算法："></a>中缀转后缀算法：</h3><ol><li>遍历中缀表达式的数字和符号<ul><li>对于数字：直接输出</li><li>对于符号：<ul><li>左括号：进栈</li><li>运算符号：与栈顶符号优先级比较<ul><li>若栈顶符号优先级低：此符号进栈（默认栈顶若是左括号，左括号优先级最低）</li><li>若栈顶符号优先级不低：弹出栈顶符号并输出，之后该符号进栈</li></ul></li><li>右括号：弹出栈顶符号并输出，直到匹配到左括号，将左右括号同时舍弃</li></ul></li></ul></li><li>遍历结束：将栈中所有符号弹出并输出</li></ol><h3 id="后缀计算方法："><a href="#后缀计算方法：" class="headerlink" title="后缀计算方法："></a>后缀计算方法：</h3><ol><li>遍历后缀表达式的数字和符号<ul><li>对于数字：进栈</li><li>对于符号：<ul><li>从栈中弹出右操作数</li><li>从栈中弹出左操作数</li><li>根据符号进行运算</li><li>将运算结果压入栈中</li></ul></li></ul></li><li>遍历结束：栈中的唯一数字为计算结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向接口编程</title>
      <link href="2020/03/07/C++/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
      <url>2020/03/07/C++/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>甲方先自己写好函数指针类型，然后传进自己的函数里正常使用，这时候是可以编译成功的</p><p>乙方拿到甲方的接口，实现具体的函数功能</p><p>接口是通过函数指针实现的，这样甲方就可以当作函数已经存在来使用它了</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="2020/03/05/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>2020/03/05/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>处于效率的考量，cpu从内存拿数据不是一个字节一个字节拿的，而是成块拿的</p><p>块的大小2 4 8..不等，根据不同的计算机有不同的大小</p><p>对齐模数默认为8，可以通过#pragma pack (i)来设置，i为2的n次方</p><h3 id="对齐规则："><a href="#对齐规则：" class="headerlink" title="对齐规则："></a>对齐规则：</h3><ol><li>第一个属性开始，从0计算偏移量</li><li>第二个属性要放在该属性的大小 与 对齐模数 取小的值的 整数倍上</li><li>当所有属性都计算完后，整体做二次偏移</li><li>将上面的计算结果 扩充到这个结构体中最大数据类型 与对齐模数 取小的值的整数倍</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">//0-3</span></span><br><span class="line"><span class="keyword">char</span> b; <span class="comment">//4-7</span></span><br><span class="line"><span class="keyword">double</span> c; <span class="comment">//8-15</span></span><br><span class="line"><span class="keyword">float</span> d; <span class="comment">//16-19 扩展到8的整数倍，24 </span></span><br><span class="line">&#125; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p)); <span class="comment">//24 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack (1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">//0-3</span></span><br><span class="line"><span class="keyword">char</span> b; <span class="comment">//4 </span></span><br><span class="line"><span class="keyword">double</span> c; <span class="comment">//5-12 </span></span><br><span class="line"><span class="keyword">float</span> d; <span class="comment">//13-16 </span></span><br><span class="line">&#125; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p)); <span class="comment">//17 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">//0-3</span></span><br><span class="line"><span class="keyword">char</span> b; <span class="comment">//4 </span></span><br><span class="line"><span class="keyword">double</span> c; <span class="comment">//5-12 </span></span><br><span class="line"><span class="keyword">float</span> d; <span class="comment">//13-16 </span></span><br><span class="line">&#125; p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> a;<span class="comment">//0-3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> <span class="title">p</span>;</span><span class="comment">//4-23p中最大是8跟4比，选4 </span></span><br><span class="line"><span class="keyword">double</span> c;<span class="comment">//24-32最大8，这里的c和p都是8，和4比，32是4的整数倍 </span></span><br><span class="line">&#125; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(p)); <span class="comment">//20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(q));<span class="comment">//32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组指针</title>
      <link href="2020/03/04/C++/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/"/>
      <url>2020/03/04/C++/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;arr;      <span class="comment">//这个是不可以的，&amp;arr的步长是数组的大小</span></span><br><span class="line"></span><br><span class="line">typedef int(ARRAY_TYPE)[5]; //ARRAY_TYPE是一个有5个int元素的数组类型</span><br><span class="line">ARRAY_TYPE *p = &amp;arr;   <span class="comment">//数组指针的定义    *p === arr</span></span><br><span class="line"></span><br><span class="line">typedef int(*ARRAY_TYPE)[5]; //ARRAY_TYPE 数组指针类型</span><br><span class="line">ARRAY_TYPE p = &amp;arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(*p)[<span class="number">5</span>] = &amp;arr;  <span class="comment">//直接定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>][<span class="number">3</span>] = &amp;arr;  <span class="comment">//二维数组指针</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = arr;  <span class="comment">//第一排数组的指针</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>b树</title>
      <link href="2020/03/02/algo/b%E6%A0%91/"/>
      <url>2020/03/02/algo/b%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="sql语句在mysql中是如何查找的？"><a href="#sql语句在mysql中是如何查找的？" class="headerlink" title="sql语句在mysql中是如何查找的？"></a>sql语句在mysql中是如何查找的？</h3><p><strong>hash查找？暴力？索引？</strong></p><p>索引的数据结构有哪些？数组、链表、红黑树、哈希表，b树(b树，b+树)</p><p>数据量大的时候数组和链表是不行的</p><p>范围查找的时候，hash是不行的，部分索引查询也不行</p><p>什么时候hash？查询条件不会变，而且没有部分查询和范围查询</p><p><strong>为什么红黑树不可以？</strong></p><p>数据量大的时候，红黑树的io操作也很大</p><p>而且磁盘按页读取，但每次只能用到一个数据单位，一页16k，但一个数据可能只有4字节，很浪费</p><p>但是C++的map可以用红黑树，因为它是存在内存的</p><p>磁盘io次数过多？ -&gt; N叉树</p><p>读取浪费？ -&gt; 连续空间，每个节点是一个线性表</p><h3 id="b树的性质："><a href="#b树的性质：" class="headerlink" title="b树的性质："></a>b树的性质：</h3><ol><li>m阶b树最多含m个指针，m-1个关键字，m&gt;=2</li><li>除根节点和叶子节点，其他每个节点至少有m/2个指针</li><li>若根节点不是叶子节点，则至少有两个指针</li></ol><h3 id="b树的操作："><a href="#b树的操作：" class="headerlink" title="b树的操作："></a>b树的操作：</h3><ol><li>分裂</li></ol><p><img src="/photo/b%E6%A0%91.png" alt="b树" loading="lazy"></p><blockquote><p>b树适合作mysql的索引么？</p></blockquote><p>b树不适合范围查找，还是会有树的遍历操作，而且每一个key都对应一条记录的地址，存储开销大</p><p>这些问题可以用b+树解决</p><p><img src="/photo/b+%E6%A0%91.png" alt="b+树" loading="lazy"></p><p><code>select * from student where id = 0 and name = &quot;张三&quot;</code></p><p>建立id的索引，先找到id=0，然后找name=张三，这是索引建立的最左原则，当然也可以建立id+name的索引</p><p>不过索引不是建的越多越好，如果数据有改动，维护索引很麻烦的</p><p>即便查询不涉及到索引字段，也是会走索引的叶子节点进行遍历查找的，比全表搜索还是要快一些</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="2020/03/01/algo/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>2020/03/01/algo/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="查找算法有哪些？"><a href="#查找算法有哪些？" class="headerlink" title="查找算法有哪些？"></a>查找算法有哪些？</h3><p>遍历、二分、hash、AVL、b树、b+树、红黑树、二叉搜索树（又称二叉排序树，二叉查找树）</p><p>hash的时间复杂度为O(1)，java的hashmap中，当hash冲突过多，每一个键对多个值，这时候就要使用链表+红黑树解决冲突</p><p>红黑树是一种高效的查找算法数据结构</p><p><img src="/photo/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="hash表" loading="lazy"></p><p>二分查找转换成数据结构就是二叉搜索树，左子小于根，右子大于根</p><p>但是二叉搜索树有可能退化成链表，解决方法可以使用AVL(平衡二叉树)和红黑树</p><p>AVL树追求极致的平衡，构造出的二叉树是最完美的，左右子树高度差不超过1，红黑树不然，只能达到近似平衡</p><p>按综合性能考量，红黑树更优</p><h3 id="红黑树的性质："><a href="#红黑树的性质：" class="headerlink" title="红黑树的性质："></a>红黑树的性质：</h3><ol><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li></ol><h3 id="红黑树的三种变换规则："><a href="#红黑树的三种变换规则：" class="headerlink" title="红黑树的三种变换规则："></a>红黑树的三种变换规则：</h3><ol><li>变颜色</li><li>左旋</li><li>右旋</li></ol><p><img src="/photo/%E6%97%8B%E8%BD%AC.png" alt="旋转" loading="lazy"></p><h3 id="变换规则：所有插入的点默认为红色"><a href="#变换规则：所有插入的点默认为红色" class="headerlink" title="变换规则：所有插入的点默认为红色"></a>变换规则：所有插入的点默认为红色</h3><p><img src="/photo/%E5%8F%98%E6%8D%A2.webp" alt="变换" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="2020/02/20/C++/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>2020/02/20/C++/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-Internet网络协议"><a href="#一-Internet网络协议" class="headerlink" title="一. Internet网络协议"></a>一. Internet网络协议</h1><ol><li><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><ul><li>Internet主流协议族</li><li>分层、多协议的通信体系</li></ul><ol><li><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul><li>网卡接口的网络驱动程序，处理数据在物理媒介上的传输；不同的物理网络具有不同的电气特性，网络驱动程序隐藏实现细节，为上层协议提供一致的接口</li><li>数据链路层常用协议：地址解析协议（ARP）和反向地址解析协议（RARP），实现IP地址与机器物理地址（通常为MAC地址）之间的相互转换</li></ul></li><li><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul><li>实现数据包的路由和转发</li><li>常用协议：IP、ICMP</li><li>IP协议：逐跳发送模式；根据数据包的目的地IP地址决定数据如何发送；如果数据包不能直接发送至目的地，IP协议负责寻找一个合适的下一跳路由器，并将数据包交付给该路由器转发</li><li>ICMP协议：因特网控制报文协议，用于检测网络连接</li></ul></li><li><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul><li>为两台主机的应用程序提供端到端通信</li><li>传输层使用的主要协议：TCP、UDP</li><li>TCP：传输控制协议，为应用层提供可靠的、面向连接的、基于流的可靠服务；使用超时重发、数据确认等方式确保数据被正确发送至目的地</li><li>UDP：用户数据报协议，为应用层提供不可靠的、无连接的、基于数据报的服务；不保证数据能正确发送</li></ul></li><li><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li>应用程序逻辑实现</li><li>常用协议：ping、telnet、DNS、HTTP、FTP、DHCP等</li></ul></li></ol></li><li><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ol><li><h4 id="超文本传输协议：应用层协议"><a href="#超文本传输协议：应用层协议" class="headerlink" title="超文本传输协议：应用层协议"></a>超文本传输协议：应用层协议</h4></li><li><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul><li>支持客户/服务器模式</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径；请求方法常用GET、HEAD、POST等，每种方法规定了客户与服务器联系的不同类型；HTTP协议简单，服务器程序规模小，通信速度较快</li><li>灵活：HTTP允许传输任意类型的数据对象；正在传输的类型由Content-Type加以标记</li></ul></li><li><h4 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h4><ul><li>无连接：无连接是指每次连接只处理一个请求；服务器处理完客户请求，并收到客户应答后，即断开连接，节省传输时间</li><li>无状态：无状态是指协议对于事务处理没有记忆能力；应答较快，但传输数据量较大</li></ul></li><li><h4 id="HTTP-URL：定位网络资源"><a href="#HTTP-URL：定位网络资源" class="headerlink" title="HTTP URL：定位网络资源"></a>HTTP URL：定位网络资源</h4><ul><li><code>http://host[:port][abs_path]</code></li></ul></li><li><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><ul><li>由三部分组成：请求行、消息报头、请求正文</li><li>格式：Method Request-URI HTTP-Version CRLF</li><li>Method：请求方法，GET、POST等</li><li>Request-URI：统一资源标识符</li><li>HTTP-Version：请求的HTTP协议版本</li><li>CRLF：回车换行</li></ul></li><li><h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><ul><li>由三部分组成：状态行、消息报头、响应正文</li><li>状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF</li><li>HTTP-Version：服务器HTTP协议版本</li><li>Status-Code：服务器返回的响应状态码</li><li>Reason-Phrase：状态码的文本描述</li></ul></li><li><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ul><li>状态代码有三位数字组成，首数字定义响应类别<ul><li>1xx：指示信息，表示请求已接收，继续处理；2xx：成功；3xx：重定向，要完成请求必须进行更进一步的操作；4xx：客户端错误，请求有语法错误或请求无法实现；5xx：服务器端错误，服务器未能实现合法的请求</li></ul></li><li>常见状态代码<ul><li>200：OK，请求成功；400：Bad Request，请求有语法错误，不能被服务器所理解；401：Unauthorized，请求未经授权；403：Forbidden，服务器收到请求，但是拒绝提供服务；404：Not Found，请求资源不存在；500：Internal Server Error，服务器发生不可预期的错误；503：Server Unavailable，服务器不能处理客户请求</li></ul></li></ul></li></ol></li></ol><h1 id="二-套接字"><a href="#二-套接字" class="headerlink" title="二. 套接字"></a>二. 套接字</h1><ol><li><h3 id="套接字的基本概念"><a href="#套接字的基本概念" class="headerlink" title="套接字的基本概念"></a>套接字的基本概念</h3><ol><li><h4 id="通信类型：控制套接字如何传输和处理数据，数据以包的形式传输"><a href="#通信类型：控制套接字如何传输和处理数据，数据以包的形式传输" class="headerlink" title="通信类型：控制套接字如何传输和处理数据，数据以包的形式传输"></a>通信类型：控制套接字如何传输和处理数据，数据以包的形式传输</h4><ul><li>连接（connection）类型：确保所有包依序传输，如果丢包，则请求重传</li><li>数据报（datagram）类型：不保证包的到达顺序，包可能丢失</li></ul></li><li><h4 id="名空间：指定套接字地址格式"><a href="#名空间：指定套接字地址格式" class="headerlink" title="名空间：指定套接字地址格式"></a>名空间：指定套接字地址格式</h4><ul><li>本地名空间：套接字地址为普通文件名</li><li>Internet名空间：套接字地址由Internet地址和端口号（用于区分一台主机上的多个套接字）确定</li></ul></li><li><h4 id="协议：确定数据如何传输"><a href="#协议：确定数据如何传输" class="headerlink" title="协议：确定数据如何传输"></a>协议：确定数据如何传输</h4></li></ol></li><li><h3 id="套接字函数：“sys-socket-h”"><a href="#套接字函数：“sys-socket-h”" class="headerlink" title="套接字函数：“sys/socket.h”"></a>套接字函数：“sys/socket.h”</h3><ol><li><h4 id="socket-函数：创建套接字"><a href="#socket-函数：创建套接字" class="headerlink" title="socket()函数：创建套接字"></a>socket()函数：创建套接字</h4><ul><li>原型：int socket( int domain, int type, int protocol );</li><li>参数：名空间、通信类型和协议</li><li>名空间：PF_LOCAL（本地）或PF_INET（Internet）</li><li>通信类型：SOCK_STREAM（连接类型）或SOCK_DGRAM（数据报类型）</li><li>协议：传递0，让系统自动选择协议（通常为最佳协议）</li><li>返回值：套接字描述符</li></ul></li><li><h4 id="close-函数：释放套接字"><a href="#close-函数：释放套接字" class="headerlink" title="close()函数：释放套接字"></a>close()函数：释放套接字</h4><ul><li>原型：<code>int close(int fd);</code></li></ul></li><li><h4 id="connect-函数：创建两个套接字之间的连接"><a href="#connect-函数：创建两个套接字之间的连接" class="headerlink" title="connect()函数：创建两个套接字之间的连接"></a>connect()函数：创建两个套接字之间的连接</h4><ul><li>客户发起此系统调用，试图与服务器建立套接字连接</li><li>原型：<code>int connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen);</code></li><li>参数：sockfd为套接字文件描述符； addr为指向套接字地址结构体的指针（服务器地址）；addrlen为服务器地址字符串的长度</li><li>返回值：0表示连接成功，-1表示连接失败</li></ul></li><li><h4 id="send-函数：发送数据"><a href="#send-函数：发送数据" class="headerlink" title="send()函数：发送数据"></a>send()函数：发送数据</h4><ul><li>原型：<code>ssize_t send(int sockfd, const void * buf, size_t len, int flags);</code></li><li>原型：<code>ssize_t sendto(int sockfd, const void * buf, size_t len, int flags, const struct sockaddr * dest_addr, socklen_t addrlen);</code></li><li>原型：<code>ssize_t sendmsg(int sockfd, const struct msghdr * msg, int flags);</code></li><li>只有在套接字处于连接状态时才可调用</li></ul></li><li><h4 id="bind-函数：绑定服务器套接字与其地址"><a href="#bind-函数：绑定服务器套接字与其地址" class="headerlink" title="bind()函数：绑定服务器套接字与其地址"></a>bind()函数：绑定服务器套接字与其地址</h4><ul><li>原型：<code>int bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen);</code></li></ul></li><li><h4 id="listen-函数：侦听客户连接"><a href="#listen-函数：侦听客户连接" class="headerlink" title="listen()函数：侦听客户连接"></a>listen()函数：侦听客户连接</h4><ul><li>原型：<code>int listen(int sockfd, int backlog);</code></li><li>参数：backlog指定有多少个挂起连接可以进入队列，超出该值的连接将被抛弃</li></ul></li><li><h4 id="accept-函数：接受连接，为该连接创建一个新的套接字"><a href="#accept-函数：接受连接，为该连接创建一个新的套接字" class="headerlink" title="accept()函数：接受连接，为该连接创建一个新的套接字"></a>accept()函数：接受连接，为该连接创建一个新的套接字</h4><ul><li>原型：<code>int accept(int sockfd, struct sockaddr * addr, socklen_t addrlen);</code></li><li>参数：addr为指向套接字地址结构体（客户地址）的指针</li><li>返回值：创建一个新的套接字，以接受客户连接，返回值为新的套接字文件描述符</li><li>原先套接字文件描述符可以继续接受新连接</li></ul></li></ol></li><li><h3 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h3><ol><li><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//  持续读取消息，直到套接字关闭或接收到客户发送的“quit”消息</span></span><br><span class="line"><span class="comment">//  前者返回true，后者返回false，服务器随后将停止服务</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Serve</span><span class="params">(<span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">char</span> *msg;</span><br><span class="line">        <span class="comment">//  从套接字中读取文本消息的长度，返回值为0表示客户连接已关闭</span></span><br><span class="line">        <span class="keyword">if</span> (read(client_socket, &amp;length, <span class="keyword">sizeof</span>(length)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        msg = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">        read(client_socket, msg, length);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(msg, <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] msg, msg = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">delete</span>[] msg, msg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> socket_name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> socket_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">name</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> serving = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//  创建套接字</span></span><br><span class="line">    socket_fd = socket(PF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//  设定服务器性质</span></span><br><span class="line">    name.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(name.sun_path, socket_name);</span><br><span class="line">    <span class="comment">//  绑定套接字</span></span><br><span class="line">    bind(socket_fd, (struct sockaddr *)&amp;name, SUN_LEN(&amp;name));</span><br><span class="line">    <span class="comment">//  侦听客户连接</span></span><br><span class="line">    listen(socket_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//  重复接受连接，直到某个客户发出“quit”消息</span></span><br><span class="line">    <span class="keyword">while</span> (serving)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">client_name</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> client_name_len;</span><br><span class="line">        <span class="keyword">int</span> client_socket_fd;</span><br><span class="line">        <span class="comment">//  接受客户连接请求</span></span><br><span class="line">        client_socket_fd = accept(socket_fd,</span><br><span class="line">                                                            (struct sockaddr *)&amp;client_name, &amp;client_name_len);</span><br><span class="line">        serving = Serve(client_socket_fd); <span class="comment">//  服务连接请求</span></span><br><span class="line">        close(client_socket_fd); <span class="comment">//  关闭客户连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    unlink(socket_name); <span class="comment">//  删除套接字文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendMsg</span><span class="params">(<span class="keyword">int</span> socket_fd, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(msg) + <span class="number">1</span>;</span><br><span class="line">    write(socket_fd, &amp;length, <span class="keyword">sizeof</span>(length));</span><br><span class="line">    write(socket_fd, msg, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> socket_name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> msg = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> socket_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">name</span>;</span></span><br><span class="line">    <span class="comment">//  创建套接字</span></span><br><span class="line">    socket_fd = socket(PF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//  在套接字地址中存储服务器名称</span></span><br><span class="line">    name.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(name.sun_path, socket_name);</span><br><span class="line">    <span class="comment">//  连接</span></span><br><span class="line">    connect(socket_fd, (struct sockaddr *)&amp;name, SUN_LEN(&amp;name));</span><br><span class="line">    <span class="comment">//  发送消息</span></span><br><span class="line">    SendMsg(socket_fd, msg);</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="程序测试运行"><a href="#程序测试运行" class="headerlink" title="程序测试运行"></a>程序测试运行</h4><ul><li>编译链接服务器端程序和客户端程序</li><li>进入服务器端程序目录，在终端中输入：./server /tmp/socket；./server为服务器端程序名，/tmp/socket为本服务器启动后的套接字文件名</li><li>进入客户端程序目录，在新终端中输入：./client /tmp/socket “Hello World!”；./client为客户端程序名</li><li>停止服务器，在客户端输入命令：./client /tmp/socket “quit”</li></ul></li></ol></li><li><h3 id="网络套接字"><a href="#网络套接字" class="headerlink" title="网络套接字"></a>网络套接字</h3><ol><li><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//  请求Web服务器的主页</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetHomepage</span><span class="params">(<span class="keyword">int</span> socket_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8192</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;GET /\n&quot;</span>);</span><br><span class="line">    write(socket_fd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> count = read(socket_fd, buffer, <span class="number">8192</span>);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        fwrite(buffer, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), count, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socket_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostinfo</span>;</span></span><br><span class="line">    socket_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    hostinfo = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (hostinfo == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        name.sin_addr = *((struct in_addr *)hostinfo-&gt;h_addr);</span><br><span class="line">    name.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, (struct sockaddr *)&amp;name,</span><br><span class="line">                            <span class="keyword">sizeof</span>(struct sockaddr_in)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failure to connect the server.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GetHomepage(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程编程</title>
      <link href="2020/02/20/C++/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>2020/02/20/C++/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-线程基本概念"><a href="#一-线程基本概念" class="headerlink" title="一. 线程基本概念"></a>一. 线程基本概念</h1><ol><li><h3 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h3><ul><li>线程是比进程更小的程序执行单位</li><li>多个线程可共享全局数据，也可使用专有数据</li></ul></li><li><h3 id="Linux线程支持史"><a href="#Linux线程支持史" class="headerlink" title="Linux线程支持史"></a>Linux线程支持史</h3><ul><li>1996年，LinuxThreads：基本符合POSIX标准，但效率低下，问题多多</li><li>2003年，内核2.6：提供线程支持库NPTL（Native POSIX Thread Library for Linux）</li></ul></li><li><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><ul><li>操作系统内核支持多线程调度与执行</li><li>内核线程使用资源较少，仅包括内核栈和上下文切换时需要的保存寄存器内容的空间</li></ul></li><li><h3 id="轻量级进程（lightweight-process，LWP）"><a href="#轻量级进程（lightweight-process，LWP）" class="headerlink" title="轻量级进程（lightweight process，LWP）"></a>轻量级进程（lightweight process，LWP）</h3><ul><li>由内核支持的独立调度单元，调度开销小于普通的进程</li><li>系统支持多个轻量级进程同时运行，每个都与特定的内核线程相关联</li></ul></li><li><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><ul><li>建立在用户空间的多个用户级线程，映射到轻量级进程后调度执行</li><li>用户线程在用户空间创建、同步和销毁，开销较低</li><li>每个线程具有独特的ID</li></ul></li><li><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li>线程功能不属于C/C++标准库，链接时需用-pthread选项</li><li>线程功能属于C++11标准库，可用C++11提供的thread类定义线程对象，C++11标准库同时提供基本的线程同步机制</li></ul></li><li><h3 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h3><ul><li>线程空间不独立，有问题的线程会影响其他线程；进程空间独立，有问题的进程一般不会影响其他进程</li><li>创建进程需要额外的性能开销</li><li>线程用于开发细颗粒度并行性，进程用于开发粗颗粒度并行性</li><li>线程容易共享数据，进程共享数据必须使用进程间通讯机制</li></ul></li></ol><h1 id="二-线程管理"><a href="#二-线程管理" class="headerlink" title="二. 线程管理"></a>二. 线程管理</h1><ol><li><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol><li><h4 id="线程创建函数"><a href="#线程创建函数" class="headerlink" title="线程创建函数"></a>线程创建函数</h4><ul><li>头文件：“pthread.h”</li><li>原型：<code>int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void *), void * arg);</code></li></ul></li><li><h4 id="线程创建流程"><a href="#线程创建流程" class="headerlink" title="线程创建流程"></a>线程创建流程</h4><ul><li>定义指向pthread_t对象的指针对象，pthread_t对象用于存储新线程的ID</li><li>定义指向线程属性pthread_attr_t对象的指针对象；线程属性对象控制线程与程序其他部分（可能是其他线程）的交互；如果传递NULL，则使用缺省属性构造新线程</li><li>定义指向线程函数的指针对象，使其指向固定格式的线程函数</li><li>实现线程函数；线程函数的参数和返回值均为哑型指针；需要传递多个参数时，打包成单个void*型的指针对象</li><li>线程退出时使用返回值将数据传递给主调线程；多个结果同样可以打包传递</li></ul></li><li><h4 id="线程创建说明"><a href="#线程创建说明" class="headerlink" title="线程创建说明"></a>线程创建说明</h4><ul><li>pthread_create()函数在线程创建完毕后立即返回，它并不等待线程结束</li><li>原线程与新线程如何执行与调度有关，程序不得依赖线程先后执行的关系</li><li>可以使用同步机制确定线程的先后执行关系</li></ul></li><li><h4 id="线程退出方式"><a href="#线程退出方式" class="headerlink" title="线程退出方式"></a>线程退出方式</h4><ul><li>线程函数结束执行</li><li>调用pthread_exit()函数显式结束</li><li>被其他线程撤销<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintAs</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintZs</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, &amp;PrintAs, <span class="literal">NULL</span>);</span><br><span class="line">    PrintZs(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="线程函数参数与返回值"><a href="#线程函数参数与返回值" class="headerlink" title="线程函数参数与返回值"></a>线程函数参数与返回值</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoPrinted</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InfoPrinted(<span class="keyword">char</span> c, <span class="keyword">int</span> n) : _c(c), _n(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n; i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; _c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> _c;</span><br><span class="line">    <span class="keyword">int</span> _n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintInfo</span><span class="params">(<span class="keyword">void</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InfoPrinted *p = <span class="keyword">reinterpret_cast</span>&lt;InfoPrinted *&gt;(info);</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        p-&gt;Show();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  注意：本程序大部分情况下不会输出任何结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//  构造InfoPrinted类的动态对象，作为线程函数参数传递给线程tid1</span></span><br><span class="line">    <span class="comment">//  输出100个‘a’</span></span><br><span class="line">    InfoPrinted *p = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(p));</span><br><span class="line">    <span class="comment">//  构造InfoPrinted类的动态对象，作为线程函数参数传递给线程tid2</span></span><br><span class="line">    <span class="comment">//  输出100个‘z’</span></span><br><span class="line">    InfoPrinted *q = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;z&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(q));</span><br><span class="line">    <span class="comment">//  使用本注释行替换上述线程，可以看到输出结果，可能仅有部分输出</span></span><br><span class="line">    <span class="comment">//  PrintInfo( reinterpret_cast&lt;void *&gt;( q ) );</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h4 id="存在的问题：一般不会产生任何输出"><a href="#存在的问题：一般不会产生任何输出" class="headerlink" title="存在的问题：一般不会产生任何输出"></a>存在的问题：一般不会产生任何输出</h4><ul><li>子线程需要使用主线程的数据，如果主线程结束，子线程如何访问这些数据？</li></ul></li><li><h4 id="解决方案：使用pthread-join-函数，等待子线程结束"><a href="#解决方案：使用pthread-join-函数，等待子线程结束" class="headerlink" title="解决方案：使用pthread_join()函数，等待子线程结束"></a>解决方案：使用pthread_join()函数，等待子线程结束</h4><ul><li>原型：<code>int pthread_join(pthread_t thread, void ** retval);</code></li><li>参数：thread为pthread_t类型的线程ID；retval接收线程返回值，不需要接收返回值时传递NULL<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  注意：无法确定两个线程的执行顺序，多次输出结果可能不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    InfoPrinted *p = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(p));</span><br><span class="line"></span><br><span class="line">    InfoPrinted *q = <span class="keyword">new</span> InfoPrinted(<span class="string">&#x27;z&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;PrintInfo, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(q));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  等待子线程结束</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="线程函数返回值"><a href="#线程函数返回值" class="headerlink" title="线程函数返回值"></a>线程函数返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">IsPrime</span><span class="params">(<span class="keyword">void</span> *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">3u</span>, t = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">sqrt</span>(p) + <span class="number">1u</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2u</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (p % <span class="number">2u</span> == <span class="number">0u</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p % i == <span class="number">0u</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">false</span>);</span><br><span class="line">        i += <span class="number">2u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  使用g++ main.cpp –pthread –lm –fpermissive编译</span></span><br><span class="line"><span class="comment">//  以防止编译器将void*到int的转型当作错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">bool</span> primalities[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        pthread_create(&amp;tids[i], <span class="literal">NULL</span>, &amp;IsPrime, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(i + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        pthread_join(tids[i], <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(&amp;primalities[i]));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; primalities[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><ol><li><h4 id="pthread-equal-函数：确认两个线程是否相同"><a href="#pthread-equal-函数：确认两个线程是否相同" class="headerlink" title="pthread_equal()函数：确认两个线程是否相同"></a>pthread_equal()函数：确认两个线程是否相同</h4><ul><li>原型：<code>int pthread_equal(pthread_t t1, pthread_t t2);</code></li></ul></li><li><h4 id="pthread-self-函数：返回当前线程的ID"><a href="#pthread-self-函数：返回当前线程的ID" class="headerlink" title="pthread_self()函数：返回当前线程的ID"></a>pthread_self()函数：返回当前线程的ID</h4><ul><li>原型：<code>pthread_t pthread_self();</code></li><li>示例：<code>if( !pthread_equal(pthread_self(), other_tid)) pthread_join(other_tid, NULL);</code></li></ul></li></ol></li><li><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ol><li><h4 id="线程属性：精细调整线程的行为"><a href="#线程属性：精细调整线程的行为" class="headerlink" title="线程属性：精细调整线程的行为"></a>线程属性：精细调整线程的行为</h4></li><li><h4 id="设置线程属性的流程"><a href="#设置线程属性的流程" class="headerlink" title="设置线程属性的流程"></a>设置线程属性的流程</h4><ul><li>创建pthread_attr_t类型的对象</li><li>调用pthread_attr_init()函数初始化线程的缺省属性，传递指向该线程属性对象的指针<ul><li>原型：<code>int pthread_attr_init(pthread_attr_t * attr);</code></li></ul></li><li>对线程属性进行必要修改</li><li>调用pthread_create()函数时传递指向线程属性对象的指针</li><li>调用pthread_attr_destroy()函数清除线程属性对象， pthread_attr_t对象本身没有被销毁，因而可以调用pthread_attr_init()函数再次初始化<ul><li>原型：<code>int pthread_attr_destroy(pthread_attr_t * attr);</code></li></ul></li></ul></li><li><h4 id="线程属性说明"><a href="#线程属性说明" class="headerlink" title="线程属性说明"></a>线程属性说明</h4><ul><li>单一线程属性对象可以用于创建多个线程</li><li>线程创建后，继续保留线程属性对象本身并没有意义</li><li>对大多数Linux程序，线程最重要的属性为分离状态（detach state）</li></ul></li><li><h4 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h4><ul><li>可联线程（joinable thread）：缺省设置，终止时并不自动清除（类似僵尸进程），主线程必须调用pthread_join()获取其返回值，此后才能清除</li><li>分离线程（detached thread）：结束时自动清除，不能调用pthread_join()进行线程同步</li><li>可联线程可通过pthread_detach()函数分离，分离线程不能再次联结<ul><li>原型：<code>int pthread_detach(pthread_t thread);</code></li></ul></li></ul></li><li><h4 id="pthread-attr-setdetachstate-函数：设置线程分离属性"><a href="#pthread-attr-setdetachstate-函数：设置线程分离属性" class="headerlink" title="pthread_attr_setdetachstate()函数：设置线程分离属性"></a>pthread_attr_setdetachstate()函数：设置线程分离属性</h4><ul><li>原型：<code>int pthread_attr_setdetachstate (pthread_attr_t * attr, int detachstate);</code></li><li>传递线程属性对象指针和分离线程设置参数PTHREAD_CREATE_DETACHED</li></ul></li><li><h4 id="pthread-attr-getdetachstate-函数：获取线程分离属性"><a href="#pthread-attr-getdetachstate-函数：获取线程分离属性" class="headerlink" title="pthread_attr_getdetachstate()函数：获取线程分离属性"></a>pthread_attr_getdetachstate()函数：获取线程分离属性</h4><ul><li>原型：<code>int pthread_attr_getdetachstate (pthread_attr_t * attr, int * detachstate);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//  线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="comment">//  初始化线程属性</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">//  设置线程属性的分离状态</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="comment">//  创建线程</span></span><br><span class="line">    pthread_create(&amp;thread, &amp;attr, &amp;ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//  清除线程属性对象</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="comment">//  无需联结该线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="线程撤销"><a href="#线程撤销" class="headerlink" title="线程撤销"></a>线程撤销</h3><ol><li><h4 id="pthread-cancel-函数：撤销线程"><a href="#pthread-cancel-函数：撤销线程" class="headerlink" title="pthread_cancel()函数：撤销线程"></a>pthread_cancel()函数：撤销线程</h4><ul><li>原型：<code>int pthread_cancel(pthread_t thread);</code></li><li>已撤销的线程可以联结，且必须联结，以释放其资源，除非其为分离线程</li></ul></li><li><h4 id="线程撤销类型与状态"><a href="#线程撤销类型与状态" class="headerlink" title="线程撤销类型与状态"></a>线程撤销类型与状态</h4><ul><li>异步可撤销：在其执行的任何时刻都可撤销</li><li>同步可撤销：线程可撤销，但撤销操作首先进入队列排队，在线程执行到特定撤销点时才可撤销</li><li>不可撤消：撤销不可撤消线程的企图被系统忽略，且没有任何消息反馈</li></ul></li><li><h4 id="pthread-setcanceltype-函数：设置线程的撤销类型"><a href="#pthread-setcanceltype-函数：设置线程的撤销类型" class="headerlink" title="pthread_setcanceltype()函数：设置线程的撤销类型"></a>pthread_setcanceltype()函数：设置线程的撤销类型</h4><ul><li>原型：<code>int pthread_setcanceltype(int type, int * oldtype);</code></li><li>参数：type为撤销类型，oldtype用于保存原始线程撤销类型，NULL表示不保存</li><li>PTHREAD_CANCEL_ASYNCHRONOUS：线程异步可撤销</li><li>PTHREAD_CANCEL_DEFERRED：线程同步可撤销，即延迟到下一撤销点时撤销</li></ul></li><li><h4 id="pthread-setcancelstate-函数：设置线程的撤销状态"><a href="#pthread-setcancelstate-函数：设置线程的撤销状态" class="headerlink" title="pthread_setcancelstate()函数：设置线程的撤销状态"></a>pthread_setcancelstate()函数：设置线程的撤销状态</h4><ul><li>原型：<code>int pthread_setcancelstate(int state, int * oldstate);</code></li><li>第一个参数state为可撤销状态，第二个参数oldstate用于保存原始线程可撤销状态，NULL表示不保存</li><li>PTHREAD_CANCEL_ENABLE：线程可撤销</li><li>PTHREAD_CANCEL_DISABLE：线程不可撤销</li><li>线程的撤销状态可多次设置</li></ul></li><li><h4 id="pthread-testcancel-函数：设置撤销点"><a href="#pthread-testcancel-函数：设置撤销点" class="headerlink" title="pthread_testcancel()函数：设置撤销点"></a>pthread_testcancel()函数：设置撤销点</h4><ul><li>原型：<code>void pthread_testcancel();</code></li><li>在线程函数中调用pthread_testcancel()函数设置撤销点</li><li>建议：周期性地设置撤销点，保证线程函数内部每隔一些代码就有一个撤销点，以保证资源能够正确释放</li></ul></li><li><h4 id="使用撤销状态构造临界区（critical-section）"><a href="#使用撤销状态构造临界区（critical-section）" class="headerlink" title="使用撤销状态构造临界区（critical section）"></a>使用撤销状态构造临界区（critical section）</h4><ul><li>临界区：要么全部执行，要么一条都不执行的代码段</li><li>设置线程的撤销状态，线程一旦进入临界区，就必须等到离开临界区，才可以被撤销<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  账户转账</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transfer</span><span class="params">(<span class="keyword">double</span> *accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ocs;</span><br><span class="line">    <span class="comment">//  数据有效性检查代码在此，确保转账操作合法有效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将线程设置为不可撤销的，进入临界区</span></span><br><span class="line">    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;ocs);</span><br><span class="line"></span><br><span class="line">    accounts[to] += amount;</span><br><span class="line">    accounts[from] -= amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  恢复线程的撤销状态，离开临界区</span></span><br><span class="line">    pthread_setcancelstate(ocs, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h3><ol><li><h4 id="线程局部存储（thread-local-storage，TLS）：每个线程的独有数据"><a href="#线程局部存储（thread-local-storage，TLS）：每个线程的独有数据" class="headerlink" title="线程局部存储（thread local storage，TLS）：每个线程的独有数据"></a>线程局部存储（thread local storage，TLS）：每个线程的独有数据</h4><ul><li>线程特定数据（thread-specific data）</li><li>进程的多个线程通过全局堆共享全局数据对象</li><li>每个线程拥有独立的栈</li></ul></li><li><h4 id="让线程拥有数据的独立副本：不能简单赋值或读取"><a href="#让线程拥有数据的独立副本：不能简单赋值或读取" class="headerlink" title="让线程拥有数据的独立副本：不能简单赋值或读取"></a>让线程拥有数据的独立副本：不能简单赋值或读取</h4><ul><li>pthread_key_create()函数：为线程特定数据创建一个键</li><li>参数：第一个为指向pthread_key_t类型变量的指针（每个线程都可以使用它访问自己的独立数据副本）；第二个参数为指向线程清除函数的指针，如果不存在，传递NULL</li><li>pthread_setspecific()函数：设置对应键的值</li><li>pthread_getspecific()函数：读取对应键的值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> tlk; <span class="comment">//  关联线程日志文件指针的键</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToThreadLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = (FILE *)pthread_getspecific(tlk);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d: %s\n&quot;</span>, (<span class="keyword">int</span>)pthread_self(), msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseThreadLog</span><span class="params">(<span class="keyword">void</span> *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose((FILE *)fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">255</span>];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">//  生成与线程ID配套的日志文件名</span></span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">&quot;thread%d.log&quot;</span>, (<span class="keyword">int</span>)pthread_self());</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">//  设置线程日志文件指针与键的局部存储关联</span></span><br><span class="line">    pthread_setspecific(tlk, fp);</span><br><span class="line">    <span class="comment">//  向日志中写入数据，不同的线程会写入不同的文件</span></span><br><span class="line">    WriteToThreadLog(<span class="string">&quot;Thread starting...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//  创建键，使用CloseThreadLog()函数作为其清除程序</span></span><br><span class="line">    pthread_key_create(&amp;tlk, CloseThreadLog);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, ThreadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_key_delete(tlk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="线程清除"><a href="#线程清除" class="headerlink" title="线程清除"></a>线程清除</h3><ol><li><h4 id="线程清除函数：回调函数，单void-参数，无返回值"><a href="#线程清除函数：回调函数，单void-参数，无返回值" class="headerlink" title="线程清除函数：回调函数，单void*参数，无返回值"></a>线程清除函数：回调函数，单void*参数，无返回值</h4><ul><li>目的：销毁线程退出或被撤销时未释放的资源</li></ul></li><li><h4 id="pthread-cleanup-push-函数：注册线程清除函数"><a href="#pthread-cleanup-push-函数：注册线程清除函数" class="headerlink" title="pthread_cleanup_push()函数：注册线程清除函数"></a>pthread_cleanup_push()函数：注册线程清除函数</h4><ul><li>原型：<code>void pthread_cleanup_push(void (*routine)(void*), void * arg);</code></li><li>参数：routine为指向线程清除函数的函数指针，arg为传递给回调函数的附加数据对象</li></ul></li><li><h4 id="pthread-cleanup-pop-函数：取消线程清除函数注册"><a href="#pthread-cleanup-pop-函数：取消线程清除函数注册" class="headerlink" title="pthread_cleanup_pop()函数：取消线程清除函数注册"></a>pthread_cleanup_pop()函数：取消线程清除函数注册</h4><ul><li>原型：<code>void pthread_cleanup_pop(int execute);</code></li><li>参数：整型值，非0调用回调函数释放资源，0不释放<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *  <span class="title">AllocateBuffer</span><span class="params">( <span class="keyword">size_t</span> size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>( size );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DeallocateBuffer</span><span class="params">( <span class="keyword">void</span> * buffer )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>( buffer );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DoSomeWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *  temp_buffer = AllocateBuffer( <span class="number">1024</span> );</span><br><span class="line"><span class="comment">//  注册清除处理函数</span></span><br><span class="line">pthread_cleanup_push( DeallocateBuffer, temp_buffer );</span><br><span class="line"><span class="comment">//  此处可以调用pthread_exit()退出线程或者撤销线程</span></span><br><span class="line"><span class="comment">//  取消注册，传递非0值，实施清除任务</span></span><br><span class="line">pthread_cleanup_pop( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="C-的问题"><a href="#C-的问题" class="headerlink" title="C++的问题"></a>C++的问题</h4><ul><li>对象的析构函数在线程退出时可能没有机会被调用，因而线程栈上的数据未清除</li><li>如何保证线程资源被正确释放？</li><li>解决方法<ul><li>定义异常类，线程在准备退出时引发异常，然后在异常处理中退出线程执行</li><li>引发异常时，C++确保析构函数被调用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EThreadExit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EThreadExit(<span class="keyword">void</span> *ret_val) : _thread_ret_val(ret_val) &#123;&#125;</span><br><span class="line">    <span class="comment">//  实际退出线程，使用对象构造时的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">DoThreadExit</span><span class="params">()</span> </span>&#123; pthread_exit(_thread_ret_val); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> *_thread_ret_val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (线程需要立即退出)</span><br><span class="line">            <span class="keyword">throw</span> EThreadExit(线程返回值);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> EThreadExit &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.DoThreadExit(); <span class="comment">//  执行线程实际退出动作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol></li></ol><h1 id="三-线程同步机制"><a href="#三-线程同步机制" class="headerlink" title="三. 线程同步机制"></a>三. 线程同步机制</h1><ol><li><h3 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h3><ol><li><h4 id="编程任务"><a href="#编程任务" class="headerlink" title="编程任务"></a>编程任务</h4><ul><li>存在一个任务队列，多个并发线程同时处理这些任务。每个线程在完成某项任务后，检查任务队列中是否有新任务。如果有，就处理该任务，并将该任务从任务队列中删除。</li><li>假设：两个线程碰巧完成各自任务，但队列中只有一个任务。</li><li>可能发生的情况：第一个线程发现任务队列非空，准备接收该任务，但没有完成全部设置。此时，操作系统碰巧中断该线程。第二个线程获得了执行，也发现任务队列非空，同样准备接收该任务，但发现已无法正确设置任务队列。</li><li>最坏情况：第一个线程已经从队列中摘取了任务，但是还没有将任务队列设置为空，第二个线程对任务队列的访问导致段错误，系统崩溃。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  有问题的程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span>;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Job *&gt; job_queue;</span><br><span class="line"><span class="comment">//  线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DequeueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = job_queue.front();</span><br><span class="line">        job_queue.pop_front();</span><br><span class="line">        ProcessJob(job);</span><br><span class="line">        <span class="keyword">delete</span> job, job = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ol><li><h4 id="互斥（mutex）定义与性质：MUTial-EXclusion"><a href="#互斥（mutex）定义与性质：MUTial-EXclusion" class="headerlink" title="互斥（mutex）定义与性质：MUTial EXclusion"></a>互斥（mutex）定义与性质：MUTial EXclusion</h4><ul><li>相互独占锁，与二元信号量类似</li><li>一次只有一个线程可以锁定一个数据对象，并访问</li><li>只有该线程释放锁定，其他线程才能访问该数据对象</li></ul></li><li><h4 id="pthread-mutex-init-函数：初始化互斥"><a href="#pthread-mutex-init-函数：初始化互斥" class="headerlink" title="pthread_mutex_init()函数：初始化互斥"></a>pthread_mutex_init()函数：初始化互斥</h4><ul><li>原型：<code>int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * mutexattr);</code></li><li>参数： mutex为互斥对象，mutexattr为互斥属性对象，NULL表示使用缺省属性</li><li>可使用预定义宏PTHREAD_MUTEX_INITIALIZER初始化互斥</li></ul></li><li><h4 id="pthread-mutex-destroy-函数：销毁互斥"><a href="#pthread-mutex-destroy-函数：销毁互斥" class="headerlink" title="pthread_mutex_destroy()函数：销毁互斥"></a>pthread_mutex_destroy()函数：销毁互斥</h4><ul><li>原型：<code>int pthread_mutex_destroy(pthread_mutex_t * mutex);</code></li></ul></li><li><h4 id="pthread-mutex-lock-函数：互斥加锁"><a href="#pthread-mutex-lock-函数：互斥加锁" class="headerlink" title="pthread_mutex_lock()函数：互斥加锁"></a>pthread_mutex_lock()函数：互斥加锁</h4><ul><li>原型：<code>int pthread_mutex_lock(pthread_mutex_t * mutex);</code></li><li>如果无法锁定，则调用将阻塞，至该互斥被解除锁定状态</li></ul></li><li><h4 id="pthread-mutex-trylock-函数：互斥加锁"><a href="#pthread-mutex-trylock-函数：互斥加锁" class="headerlink" title="pthread_mutex_trylock()函数：互斥加锁"></a>pthread_mutex_trylock()函数：互斥加锁</h4><ul><li>原型：<code>int pthread_mutex_trylock(pthread_mutex_t * mutex);</code></li><li>如果无法锁定，则立即返回，不阻塞</li></ul></li><li><h4 id="pthread-mutex-unlock-函数：互斥解锁"><a href="#pthread-mutex-unlock-函数：互斥解锁" class="headerlink" title="pthread_mutex_unlock()函数：互斥解锁"></a>pthread_mutex_unlock()函数：互斥解锁</h4><ul><li>原型：<code>int pthread_mutex_unlock(pthread_mutex_t * mutex);</code></li></ul></li><li><h4 id="使用互斥的流程"><a href="#使用互斥的流程" class="headerlink" title="使用互斥的流程"></a>使用互斥的流程</h4><ul><li>定义pthread_mutex_t类型的变量，将其地址作为第一个参数传给pthread_mutex_init()函数；初始化函数只需调用一次</li><li>锁定或尝试锁定该互斥；获得访问权后，执行正常程序代码；并在执行完毕后解锁</li></ul></li><li><h3 id="互斥属性"><a href="#互斥属性" class="headerlink" title="互斥属性"></a>互斥属性</h3><ul><li>pshared属性：进程共享属性</li><li>取值：PTHREAD_PROCESS_SHARED（跨进程共享），PTHREAD_PROCESS_PRIVATE（本进程内部共享）</li><li>type属性：互斥类型</li></ul></li><li><h4 id="互斥type属性"><a href="#互斥type属性" class="headerlink" title="互斥type属性"></a>互斥type属性</h4><ul><li>PTHREAD_MUTEX_NORMAL：普通锁<ul><li>被某个线程锁定后，其他请求加锁的线程将等待</li><li>容易导致死锁</li><li>解锁被其他线程锁定或已解锁的互斥，将导致不可预期的后果</li></ul></li><li>PTHREAD_MUTEX_ERRORCHECK：检错锁<br>  被其他线程锁定的互斥加锁，将返回EDEADLK</li><li>PTHREAD_MUTEX_RECURSIVE：递归锁<br>   允许线程对互斥多次加锁；解锁次数必须与加锁次数匹配</li><li>PTHREAD_MUTEX_DEFAULT：默认锁<ul><li>实现上可能为上述三种之一</li></ul></li></ul></li><li><h4 id="互斥属性函数"><a href="#互斥属性函数" class="headerlink" title="互斥属性函数"></a>互斥属性函数</h4><ul><li>初始化互斥属性对象：<code>int pthread_mutexattr_init(pthread_mutexatt_t * attr);</code></li><li>销毁互斥属性对象：<code>int pthread_mutexattr_destroy(pthread_mutexatt_t * attr);</code></li><li>获取pshared属性：<code>int pthread_mutexattr_getpshared(const pthread_mutex_t * mutex, int * pshared);</code></li><li>设置pshared属性：<code>int pthread_mutexattr_setpshared(pthread_mutex_t * mutex, int pshared);</code></li><li>获取type属性：<code>int pthread_mutexattr_gettype(const pthread_mutex_t * mutex, int * type);</code></li><li>设置type属性：<code>int pthread_mutexattr_settype(pthread_mutex_t * mutex, int type);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  完整程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Job(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  一般要求临界区代码越短越好，执行时间越短越好，使用C++ STL可能并不是好选择</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Job *&gt; job_queue;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> job_queue_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//  此处作业处理工作仅为示例，简单输出线程ID和作业内容信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessJob</span><span class="params">(Job *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; processing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  处理作业时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DequeueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            job = job_queue.front(); <span class="comment">//  获取表头元素</span></span><br><span class="line">            job_queue.pop_front(); <span class="comment">//  删除表头元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ProcessJob(job);</span><br><span class="line">        <span class="keyword">delete</span> job, job = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  作业入队时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">EnqueueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Job *job = <span class="keyword">reinterpret_cast</span>&lt;Job *&gt;(arg);</span><br><span class="line">    pthread_mutex_lock(&amp;job_queue_mutex); <span class="comment">//  锁定互斥</span></span><br><span class="line">    job_queue.push_back(job);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  入队时也输出线程ID和作业内容信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; enqueueing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;job_queue_mutex); <span class="comment">//  解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = <span class="keyword">new</span> Job(i + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, EnqueueJob, job);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, DequeueJob, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol><li><h4 id="死锁：资源被竞争占用，且无法释放"><a href="#死锁：资源被竞争占用，且无法释放" class="headerlink" title="死锁：资源被竞争占用，且无法释放"></a>死锁：资源被竞争占用，且无法释放</h4></li><li><h4 id="处理策略：更改互斥类型"><a href="#处理策略：更改互斥类型" class="headerlink" title="处理策略：更改互斥类型"></a>处理策略：更改互斥类型</h4><ul><li>创建互斥属性pthread_mutexattr_t型的对象</li><li>调用pthread_mutexattr_init()函数初始化互斥属性对象，传递其地址</li><li>调用pthread_mutexattr_setkind_np()函数设置互斥类型，函数第一个参数为指向互斥属性对象的指针，第二个参数为PTHREAD_MUTEX_RECURSIVE_NP（递归互斥）或PTHREAD_MUTEX_ERRORCHECK_NP（检错互斥）</li><li>调用pthread_mutexattr_destroy()函数销毁互斥属性对象</li></ul></li></ol></li><li><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol><li><h4 id="问题：如何确保任务队列中有任务可以做？"><a href="#问题：如何确保任务队列中有任务可以做？" class="headerlink" title="问题：如何确保任务队列中有任务可以做？"></a>问题：如何确保任务队列中有任务可以做？</h4><ul><li>如果队列中没有任务，线程可能退出，后续任务出现时，没有线程可以执行它</li></ul></li><li><h4 id="POSIX标准信号量：头文件“semaphore-h”"><a href="#POSIX标准信号量：头文件“semaphore-h”" class="headerlink" title="POSIX标准信号量：头文件“semaphore.h”"></a>POSIX标准信号量：头文件“semaphore.h”</h4><ul><li>用于多个线程的同步操作</li><li>操作方法比进程信号量简单</li></ul></li><li><h4 id="初始化信号量"><a href="#初始化信号量" class="headerlink" title="初始化信号量"></a>初始化信号量</h4><ul><li>原型：<code>int sem_init(sem_t * sem, int pshared, unsigned int value);</code></li><li>参数：sem为信号量对象，pshared为共享属性，value为信号量初始值</li></ul></li><li><h4 id="等待信号量：P操作"><a href="#等待信号量：P操作" class="headerlink" title="等待信号量：P操作"></a>等待信号量：P操作</h4><ul><li>原型：<code>int sem_wait(sem_t * sem);</code></li><li>原型：<code>int sem_trywait(sem_t * sem);</code></li><li>原型：<code>int sem_timewait(sem_t * sem, const struct timespec * abs_timeout);</code></li><li>说明：sem_wait()在无法操作时阻塞， sem_trywait()则立即返回，sem_timewait()与sem_wait()类似，但有时间限制</li></ul></li><li><h4 id="发布信号量：V操作"><a href="#发布信号量：V操作" class="headerlink" title="发布信号量：V操作"></a>发布信号量：V操作</h4><ul><li>原型：<code>int sem_post(sem_t * sem);</code></li></ul></li><li><h4 id="销毁信号量"><a href="#销毁信号量" class="headerlink" title="销毁信号量"></a>销毁信号量</h4><ul><li>原型：<code>int sem_destroy(sem_t * sem);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  完整程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Job(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Job *&gt; job_queue;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> job_queue_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  控制作业数目的信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> job_queue_count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessJob</span><span class="params">(Job *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; processing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  处理作业时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DequeueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *job = <span class="literal">NULL</span>;</span><br><span class="line">        sem_wait(&amp;job_queue_count); <span class="comment">//  等待作业队列中有新作业</span></span><br><span class="line">        pthread_mutex_lock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            job = job_queue.front(); <span class="comment">//  获取表头元素</span></span><br><span class="line">            job_queue.pop_front(); <span class="comment">//  删除表头元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;job_queue_mutex);</span><br><span class="line">        <span class="keyword">if</span> (!job)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ProcessJob(job);</span><br><span class="line">        <span class="keyword">delete</span> job, job = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  作业入队时需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">EnqueueJob</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Job *job = <span class="keyword">reinterpret_cast</span>&lt;Job *&gt;(arg);</span><br><span class="line">    pthread_mutex_lock(&amp;job_queue_mutex); <span class="comment">//  锁定互斥</span></span><br><span class="line">    job_queue.push_back(job);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  新作业入队，递增信号量</span></span><br><span class="line">    sem_post(&amp;job_queue_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  入队时也输出线程ID和作业内容信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; (<span class="keyword">int</span>)pthread_self();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; enqueueing (&quot;</span> &lt;&lt; job-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; job-&gt;y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;job_queue_mutex); <span class="comment">//  解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span> (!job_queue.empty())</span><br><span class="line">        job_queue.clear();</span><br><span class="line">    sem_init(&amp;job_queue_count, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//  初始化，非进程共享，初始值0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Job *p = <span class="keyword">new</span> Job(i + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, EnqueueJob, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, DequeueJob, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>); <span class="comment">//  等待线程终止，无作业时线程被阻塞</span></span><br><span class="line">    sem_destroy(&amp;job_queue_count);<span class="comment">//  销毁作业信号量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ol><li><h4 id="条件变量的功能与目的"><a href="#条件变量的功能与目的" class="headerlink" title="条件变量的功能与目的"></a>条件变量的功能与目的</h4><ul><li>互斥用于同步线程对共享数据对象的访问</li><li>条件变量用于在线程间同步共享数据对象的值</li></ul></li><li><h4 id="初始化条件变量"><a href="#初始化条件变量" class="headerlink" title="初始化条件变量"></a>初始化条件变量</h4><ul><li>原型：<code>int pthread_cond_init(pthread_cond_t * cond, const pthread_condattr_t * cond_attr);</code></li><li>可使用宏PTHREAD_COND_INITIALIZER代替</li></ul></li><li><h4 id="销毁条件变量"><a href="#销毁条件变量" class="headerlink" title="销毁条件变量"></a>销毁条件变量</h4><ul><li>原型：<code>int pthread_cond_destroy(pthread_cond_t * cond);</code></li></ul></li><li><h4 id="广播条件变量"><a href="#广播条件变量" class="headerlink" title="广播条件变量"></a>广播条件变量</h4><ul><li>原型：<code>int pthread_cond_broadcast(pthread_cond_t * cond);</code></li><li>以广播方式唤醒所有等待目标条件变量的线程</li></ul></li><li><h4 id="唤醒条件变量"><a href="#唤醒条件变量" class="headerlink" title="唤醒条件变量"></a>唤醒条件变量</h4><ul><li>原型：<code>int pthread_cond_signal(pthread_cond_t * cond);</code></li></ul></li><li><h4 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h4><ul><li>原型：<code>int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex);</code></li><li>参数：mutex为互斥，以确保函数操作的原子性</li></ul></li></ol></li></ol><h1 id="四-C-11线程库"><a href="#四-C-11线程库" class="headerlink" title="四. C++11线程库"></a>四. C++11线程库</h1><ol><li><h3 id="支持平台无关的并行程序开发"><a href="#支持平台无关的并行程序开发" class="headerlink" title="支持平台无关的并行程序开发"></a>支持平台无关的并行程序开发</h3></li><li><h3 id="库：atomic、thread、mutex、condition-variable、future"><a href="#库：atomic、thread、mutex、condition-variable、future" class="headerlink" title="库：atomic、thread、mutex、condition_variable、future"></a>库：atomic、thread、mutex、condition_variable、future</h3><ul><li>thread：std::thread类与std::this_thread名空间</li><li>mutex：互斥相关类，包括std::mutex系列类，std::lock_guard类、std::unique_lock类及其他型式和函数</li><li>condition_variable：条件变量类，包括 std::condition_variable类与std::condition_variable_any类</li><li>atomic：std::atomic类与std::atomic_flag类，另外还有一套C风格的原子型式和原子操作函数</li><li>future：包含两个承诺类（std::promise类、std::packaged_task类）、两个期许类（std::future类、std::shared_future类）及相关型式和函数</li></ul></li><li><h3 id="线程类：thread"><a href="#线程类：thread" class="headerlink" title="线程类：thread"></a>线程类：thread</h3><ul><li>支持的线程函数无参数和返回值型式的特别要求，有无参数均可，返回值有无亦可</li><li>与Linux线程机制相比，C++11线程类更易用</li><li>线程局部存储使用thread_local关键字</li><li>可派生自己的thread类，但实现上需特别注意</li><li>线程类应支持移动语义，但不应支持拷贝语义</li></ul></li><li><h3 id="常用线程类成员函数"><a href="#常用线程类成员函数" class="headerlink" title="常用线程类成员函数"></a>常用线程类成员函数</h3><ul><li>判断线程是否可联：bool thread::joinable();</li><li>等待线程结束：void thread::join();</li><li>分离线程：void thread::detach();</li></ul></li><li><h3 id="定义于名空间this-thread的线程管理函数"><a href="#定义于名空间this-thread的线程管理函数" class="headerlink" title="定义于名空间this_thread的线程管理函数"></a>定义于名空间this_thread的线程管理函数</h3><ul><li>获取线程ID：thread::id get_id();</li><li>在处于等待状态时，让调度器选择其他线程执行：void yield();</li><li>阻塞当前线程指定时长：<code>template&lt;typename _Rep, typename _Period&gt; void sleep_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime);</code></li><li>阻塞当前线程至指定时点：<code>template&lt;typename _Clock, typename _Duration&gt; void sleep_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  无参数线程函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(&amp;ThreadFunc)</span></span>; <span class="comment">//  创建线程对象并运行</span></span><br><span class="line">    t.join();<span class="comment">//  等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  带双参数的线程函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//  C++11标准库使用可变参数的模板形式参数列表，线程函数参数个数任意</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(&amp;ThreadFunc, m, n)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  带双参数的函子对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(Functor(), m, n)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用std::bind()函数绑定对象及其普通成员函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Worker(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) : _a(a), _b(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span> </span>&#123;  …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a, _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Worker <span class="title">worker</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::bind(&amp;Worker::ThreadFunc, &amp;worker))</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="互斥类"><a href="#互斥类" class="headerlink" title="互斥类"></a>互斥类</h3><ol><li><h4 id="基本互斥：mutex类"><a href="#基本互斥：mutex类" class="headerlink" title="基本互斥：mutex类"></a>基本互斥：mutex类</h4><ul><li>核心成员函数lock()、try_lock()和unlock()</li><li>上述成员函数无参数，无返回值</li></ul></li><li><h4 id="递归互斥：recursive-mutex类"><a href="#递归互斥：recursive-mutex类" class="headerlink" title="递归互斥：recursive_mutex类"></a>递归互斥：recursive_mutex类</h4><ul><li>允许单个线程对互斥进行多次加锁与解锁处理</li></ul></li><li><h4 id="定时互斥：timed-mutex类"><a href="#定时互斥：timed-mutex类" class="headerlink" title="定时互斥：timed_mutex类"></a>定时互斥：timed_mutex类</h4><ul><li>在某个时段里或者某个时刻前获取互斥</li><li>当线程在临界区操作的时间非常长，可以用定时锁指定时间</li></ul></li><li><h4 id="定时递归互斥：recursive-timed-mutex类"><a href="#定时递归互斥：recursive-timed-mutex类" class="headerlink" title="定时递归互斥：recursive_timed_mutex类"></a>定时递归互斥：recursive_timed_mutex类</h4><ul><li>综合timed_mutex和recursive_mutex</li></ul></li><li><h4 id="共享定时互斥：shared-timed-mutex类（C-14）"><a href="#共享定时互斥：shared-timed-mutex类（C-14）" class="headerlink" title="共享定时互斥：shared_timed_mutex类（C++14）"></a>共享定时互斥：shared_timed_mutex类（C++14）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.lock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; is entering...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; is leaving...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    x.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread *&gt; <span class="title">v</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        v[i] = <span class="keyword">new</span> <span class="built_in">std</span>::thread(ThreadFunc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        v[i]-&gt;join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="互斥的问题：容易导致死锁"><a href="#互斥的问题：容易导致死锁" class="headerlink" title="互斥的问题：容易导致死锁"></a>互斥的问题：容易导致死锁</h4><ul><li>若某个线程在临界区内的操作导致异常，有可能无法解锁，从而导致其他线程被永久阻塞</li><li>若临界区代码有多路分支，其中部分分支提前结束，但没有执行解锁操作，其他线程依然被永久阻塞</li><li>当多个线程同时申请多个资源时，加锁次序不同也可能导致死锁</li></ul></li><li><h4 id="资源获取即初始化（resource-acquisition-is-initialization-RAII）"><a href="#资源获取即初始化（resource-acquisition-is-initialization-RAII）" class="headerlink" title="资源获取即初始化（resource acquisition is initialization, RAII）"></a>资源获取即初始化（resource acquisition is initialization, RAII）</h4><ul><li>使用互斥对象管理类模板自动管理资源</li></ul></li><li><h4 id="基于作用域的锁管理类模板：std-lock-guard"><a href="#基于作用域的锁管理类模板：std-lock-guard" class="headerlink" title="基于作用域的锁管理类模板：std::lock_guard"></a>基于作用域的锁管理类模板：std::lock_guard</h4><ul><li>构造时是否加锁可选，不加锁时假定当前线程已获得锁的所有权，析构时自动解锁，所有权不可转移，对象生存期内不允许手动加锁和解锁</li></ul></li><li><h4 id="独一锁管理类模板：std-unique-lock"><a href="#独一锁管理类模板：std-unique-lock" class="headerlink" title="独一锁管理类模板：std::unique_lock"></a>独一锁管理类模板：std::unique_lock</h4><ul><li>构造时是否加锁可选，对象析构时如果持有锁会自动解锁，所有权可转移，对象生存期内允许手动加锁和解锁</li></ul></li><li><h4 id="共享锁管理类模板：std-shared-lock（C-14）"><a href="#共享锁管理类模板：std-shared-lock（C-14）" class="headerlink" title="共享锁管理类模板：std::shared_lock（C++14）"></a>共享锁管理类模板：std::shared_lock（C++14）</h4><ul><li>用于管理可转移和共享所有权的互斥对象</li></ul></li><li><h4 id="互斥管理策略"><a href="#互斥管理策略" class="headerlink" title="互斥管理策略"></a>互斥管理策略</h4><ul><li>延迟：std::defer_lock，构造互斥管理对象时延迟加锁操作</li><li>尝试：std::try_to_lock，构造互斥管理对象时尝试加锁操作，但不阻塞线程，互斥不可用时立即返回</li><li>接收：std::adopt_lock，假定当前线程已获得互斥所有权，不再加锁</li><li>缺省行为：构造互斥管理对象时没有传递管理策略标签参数，阻塞当前线程至成功获得互斥</li></ul></li><li><h4 id="互斥的解锁时机"><a href="#互斥的解锁时机" class="headerlink" title="互斥的解锁时机"></a>互斥的解锁时机</h4><ul><li>当使用C++11的互斥自动管理策略时，只有析构互斥管理对象时才自动释放互斥，因此要特别注意互斥的持有时间；若线程持有互斥的时间过长，有可能极大降低程序效率</li><li>解决方案：使用复合语句块或专用辅助函数封装临界区操作；动态创建互斥管理对象，并尽早动态释放</li></ul></li><li><h4 id="多个互斥的竞争访问"><a href="#多个互斥的竞争访问" class="headerlink" title="多个互斥的竞争访问"></a>多个互斥的竞争访问</h4><ul><li>多个线程对多个互斥加锁时保持顺序一致性，以避免可能的死锁</li><li>使用std::lock()或std::try_lock()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用互斥管理策略类重新实现线程函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Worker(int no, T a = 0, T b = 0) : _no(no), _a(a), _b(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(T *r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123; <span class="comment">// 使用复合语句块封装临界区操作，块结束时即释放局部对象</span></span><br><span class="line">            <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(x)</span></span>; <span class="comment">//  构造对象的同时加锁</span></span><br><span class="line">            *r = _x + _y;</span><br><span class="line">        &#125; <span class="comment">//  无需手工解锁，locker对象在析构时自动解锁</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread No: &quot;</span> &lt;&lt; _no &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; _a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; _b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; _a + _b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    T _a, _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  转账处理示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> balance)</span> : _<span class="title">balance</span><span class="params">(balance)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetBalance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _balance; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Increase</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123; _balance += amount; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Decrease</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123; _balance -= amount; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mutex &amp;<span class="title">GetMutex</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> _balance;</span><br><span class="line">    <span class="built_in">std</span>::mutex _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  避免死锁，使用std::lock()函数锁定多个互斥，不同的锁定顺序不会导致死锁</span></span><br><span class="line"><span class="comment">//  加锁时有可能引发异常，std::lock()函数会处理该异常</span></span><br><span class="line"><span class="comment">//  将解锁此前已加锁的部分互斥，然后重新引发该异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transfer</span><span class="params">(Account &amp;from, Account &amp;to, <span class="keyword">double</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker1</span><span class="params">(from.GetMutex(), <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker2</span><span class="params">(to.GetMutex(), <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::lock(from.GetMutex(), to.GetMutex());</span><br><span class="line">    from.Decrease(amount);</span><br><span class="line">    to.Increase(amount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a1(100.0), a2(200.0);</span><br><span class="line">    <span class="comment">//  线程参数采用值传递机制，如果要传递引用，调用std::ref()函数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(Transfer, <span class="built_in">std</span>::ref(a1), <span class="built_in">std</span>::ref(a2), <span class="number">10.0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(Transfer, <span class="built_in">std</span>::ref(a2), <span class="built_in">std</span>::ref(a1), <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="条件变量类"><a href="#条件变量类" class="headerlink" title="条件变量类"></a>条件变量类</h3><ol><li><h4 id="std-condition-variable类"><a href="#std-condition-variable类" class="headerlink" title="std::condition_variable类"></a>std::condition_variable类</h4><ul><li>必须与std::unique_lock配合使用</li></ul></li><li><h4 id="std-condition-variable-any类"><a href="#std-condition-variable-any类" class="headerlink" title="std::condition_variable_any类"></a>std::condition_variable_any类</h4><ul><li>更加通用的条件变量，可以与任意型式的互斥锁配合使用，相比前者使用时会有额外的开销</li></ul></li><li><h4 id="多线程通信同步原语"><a href="#多线程通信同步原语" class="headerlink" title="多线程通信同步原语"></a>多线程通信同步原语</h4><ul><li>阻塞一个或多个线程至收到来自其他线程的通知，超时或发生虚假唤醒</li><li>两者具有同样的成员函数，且在等待条件变量前都必须要获得相应的锁</li></ul></li><li><h4 id="成员函数notify-one-：通知一个等待线程"><a href="#成员函数notify-one-：通知一个等待线程" class="headerlink" title="成员函数notify_one()：通知一个等待线程"></a>成员函数notify_one()：通知一个等待线程</h4><ul><li>原型：<code>void motify_one() noexcept;</code></li></ul></li><li><h4 id="成员函数notify-all-：通知全部等待线程"><a href="#成员函数notify-all-：通知全部等待线程" class="headerlink" title="成员函数notify_all()：通知全部等待线程"></a>成员函数notify_all()：通知全部等待线程</h4><ul><li>原型：<code>void motify_one() noexcept;</code></li></ul></li><li><h5 id="成员函数wait-：阻塞当前线程至被唤醒"><a href="#成员函数wait-：阻塞当前线程至被唤醒" class="headerlink" title="成员函数wait()：阻塞当前线程至被唤醒"></a>成员函数wait()：阻塞当前线程至被唤醒</h5><ul><li>原型：<code>template&lt;typename Lock&gt; void wait(Lock &amp; lock);</code></li><li>原型：<code>template&lt;typename Lock, typename Predicate&gt; void wait(Lock &amp; lock, Predicate p);</code></li></ul></li><li><h4 id="成员函数wait-for-：阻塞至被唤醒或超过指定时长"><a href="#成员函数wait-for-：阻塞至被唤醒或超过指定时长" class="headerlink" title="成员函数wait_for()：阻塞至被唤醒或超过指定时长"></a>成员函数wait_for()：阻塞至被唤醒或超过指定时长</h4><ul><li>原型：<code>template&lt;typename Lock, typename Rep, typename _Period&gt; cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rtime);</code></li><li>原型：<code>template&lt;typename Lock, typename Rep, typename Period, typename Predicate&gt; bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rtime, Predicate p);</code></li></ul></li><li><h4 id="成员函数wait-until-：阻塞至被唤醒或到达指定时点"><a href="#成员函数wait-until-：阻塞至被唤醒或到达指定时点" class="headerlink" title="成员函数wait_until()：阻塞至被唤醒或到达指定时点"></a>成员函数wait_until()：阻塞至被唤醒或到达指定时点</h4><ul><li>原型：<code>template&lt;typename Lock, typename Clock, typename Duration&gt; cv_status wait_until(Lock &amp; lock,  const chrono::time_point&lt;Clock, Duration&gt;&amp; atime);</code></li><li>原型：<code>template&lt;typename Lock, typename Clock, typename Duration, typename Predicate&gt; bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; atime, Predicate p);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex x;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsReady</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ready; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready) <span class="comment">//  若标志位非true，阻塞当前线程</span></span><br><span class="line">        cond.wait(locker); <span class="comment">//  解锁并睡眠，被唤醒后重新加锁</span></span><br><span class="line">    <span class="comment">//  以上两行代码等价于cond.wait( locker, &amp;IsReady );</span></span><br><span class="line">    <span class="comment">//  第二个参数为谓词，亦可使用函子实现</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(Run, i);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;8 threads ready...\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(x)</span></span>; <span class="comment">//  互斥加锁</span></span><br><span class="line">        ready = <span class="literal">true</span>;<span class="comment">//  设置全局标志位为true</span></span><br><span class="line">        cond.notify_all();<span class="comment">//  唤醒所有线程</span></span><br><span class="line">    &#125;<span class="comment">//  离开作用域，自动解锁；可将此复合语句块实现为函数</span></span><br><span class="line">    <span class="comment">//  基于区间的循环结构，对属于threads数组的所有元素t，执行循环体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads)</span><br><span class="line">        t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="原子型式"><a href="#原子型式" class="headerlink" title="原子型式"></a>原子型式</h3><ol><li><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>使用atomic模板定义原子对象</li><li>使用预定义标准原子型式：atomic_bool、atomic_char、atomic_int、atomic_uint、atomic_long、atomic_wchar_t等等</li></ul></li><li><h4 id="意义：轻量级，支持单变量上的原子操作"><a href="#意义：轻量级，支持单变量上的原子操作" class="headerlink" title="意义：轻量级，支持单变量上的原子操作"></a>意义：轻量级，支持单变量上的原子操作</h4></li></ol></li></ol><table><thead><tr><th align="center">操作</th><th align="center">atomic_flag</th><th align="center">atomic<bool></th><th align="center">atomic<int_t></th><th align="center">atomic&lt;T*&gt;</th><th align="center">atomic<other_t></th></tr></thead><tbody><tr><td align="center">test_and_set</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">clear</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">is_lock_free</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">load</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">store</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">exchange</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">compare_exchange_weak, compare_exchange_strong</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">fetch_add, +=</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">fetch_sub, -=</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">fetch_or, |=</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">fetch_and, &amp;=</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">fetch_xor, ^=</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">++, –</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddAtomically</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">a.fetch_add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::thread ts1[<span class="number">8</span>], ts2[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts1)</span><br><span class="line">t = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(AddAtomically, <span class="number">1000000</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts2)</span><br><span class="line">t = <span class="built_in">std</span>::move(<span class="built_in">std</span>::thread(Add, <span class="number">1000000</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts1)</span><br><span class="line">t.join();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : ts2)</span><br><span class="line">t.join();</span><br><span class="line"><span class="comment">//  输出结果：a值固定，而n值多次运行结果可能不同</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><h3 id="期许与承诺"><a href="#期许与承诺" class="headerlink" title="期许与承诺"></a>期许与承诺</h3><ol><li><h4 id="线程返回值"><a href="#线程返回值" class="headerlink" title="线程返回值"></a>线程返回值</h4><ul><li>为支持跨平台，thread类无属性字段保存线程函数的返回值</li></ul></li><li><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>使用指针型式的函数参数</li><li>使用期许：std::future类模板</li><li>使用承诺：std::promise类模板</li></ul></li></ol></li><li><h3 id="指针型式参数"><a href="#指针型式参数" class="headerlink" title="指针型式参数"></a>指针型式参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  定义能够存储8个三元组的向量v，元组首元素为指向劳工对象的指针</span></span><br><span class="line"><span class="comment">//  次元素保存该劳工对象计算后的结果数据，尾元素为指向劳工线程对象的指针</span></span><br><span class="line"><span class="comment">//  向量中的每个元素都表示一个描述线程运行的线程对象，</span></span><br><span class="line"><span class="comment">//  该线程对象对应的执行具体任务的劳工对象，及该劳工对象运算后的返回值</span></span><br><span class="line">std::vector&lt;std::tuple&lt;Worker&lt;int&gt; *, int, std::thread *&gt;&gt; v(8);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  构造三元组向量，三元编号顺次为0、1、2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">v[i] = <span class="built_in">std</span>::make_tuple(<span class="keyword">new</span> Worker&lt;<span class="keyword">int</span>&gt;(i, i + <span class="number">1</span>, i + <span class="number">2</span>), <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出处理前结果；使用std::get&lt;n&gt;(v[i])获取向量的第i个元组的第n个元素</span></span><br><span class="line"><span class="comment">//  三元编号顺次为0、1、2，因而1号元保存的将是劳工对象运算后的结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No. &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: result = &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(v[i]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//  创建8个线程分别计算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  将劳工类成员函数绑定为线程函数，对应劳工对象绑定为执行对象</span></span><br><span class="line"><span class="comment">//  将构造线程对象时传递的附加参数作为被绑定的线程函数的第一个参数</span></span><br><span class="line"><span class="comment">//  auto表示由编译器自动推断f的型式</span></span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;Worker&lt;<span class="keyword">int</span>&gt;::ThreadFunc,</span><br><span class="line"> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v[i]), <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  动态构造线程对象，并保存到向量的第i个三元组中</span></span><br><span class="line"><span class="comment">//  传递三元组的1号元地址，即将该地址作为线程函数的参数</span></span><br><span class="line"><span class="comment">//  线程将在执行时将结果写入该地址</span></span><br><span class="line"><span class="comment">//  此性质由绑定函数std::bind()使用占位符std::placeholders::_1指定</span></span><br><span class="line"><span class="comment">//  线程对象为2号元，即三元组的最后一个元素</span></span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i]) = <span class="keyword">new</span> <span class="built_in">std</span>::thread(f, &amp;<span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(v[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  等待线程结束</span></span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i])-&gt;join();</span><br><span class="line"><span class="comment">//  销毁劳工对象</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v[i]), <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v[i]) = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//  销毁线程对象</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i]), <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(v[i]) = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  输出线程计算后的结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No. &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: result = &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(v[i]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="期许"><a href="#期许" class="headerlink" title="期许"></a>期许</h3><ol><li><h4 id="std-future类模板"><a href="#std-future类模板" class="headerlink" title="std::future类模板"></a>std::future类模板</h4><ul><li>目的：获取异步操作结果，延迟引发线程的异步操作异常</li></ul></li><li><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>定义期许模板类的期许对象</li><li>使用std::async()函数的返回值初始化</li><li>调用期许对象的成员函数get()获取线程返回值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用期许对象获取线程返回值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">CalculateFactorial</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::range_error(<span class="string">&quot;The number is too big.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        r *= i;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//  启动异步线程，执行后台计算任务，并返回std::future对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; f = <span class="built_in">std</span>::async(CalculateFactorial, n);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  获取线程返回值，若线程已结束，立即返回，否则等待该线程计算完毕</span></span><br><span class="line">        <span class="comment">//  若线程引发异常，则延迟到std::future::get()或std::future::wait()调用时引发</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = f.get();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::range_error &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><ol><li><h4 id="std-promise类模板"><a href="#std-promise类模板" class="headerlink" title="std::promise类模板"></a>std::promise类模板</h4><ul><li>目的： 承诺对象允许期许对象获取线程对象创建的线程返回值</li></ul></li><li><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>创建承诺std::promise<T>对象</li><li>获取该承诺对象的相关期许std::future<T>对象</li><li>创建线程对象，并传递承诺对象</li><li>线程函数内部通过承诺模板类的成员函数set_value()、set_value_at_thread_exit()、set_exception()或set_exception_at_thread_exit()设置值或异常</li><li>通过期许对象等待并获取异步操作结果<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用承诺对象设置线程返回值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">CalculateFactorial</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::range_error(<span class="string">&quot;The number is too big.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        r *= i;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  CalculateFactorial()函数的包装函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCalculateFactorial</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::promise&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; &amp;&amp;promise, <span class="keyword">short</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; p; <span class="comment">//  创建承诺对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; f = p.get_future(); <span class="comment">//  获取相关期许对象</span></span><br><span class="line">    <span class="comment">//  启动线程，执行CalculateFactorial()函数的包装函数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(DoCalculateFactorial, <span class="built_in">std</span>::move(p), n)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> r = f.get();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::range_error &amp;e)</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cerr</span></span><br><span class="line">            &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  CalculateFactorial()函数的包装函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCalculateFactorial</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::promise&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; &amp;&amp;promise, <span class="keyword">short</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  设置线程返回值，供期许对象获取</span></span><br><span class="line">        promise.set_value(CalculateFactorial(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  捕获全部异常，并在期许获取线程返回值时重新引发</span></span><br><span class="line">        promise.set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程编程</title>
      <link href="2020/02/18/C++/%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>2020/02/18/C++/%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-进程基本概念"><a href="#一-进程基本概念" class="headerlink" title="一. 进程基本概念"></a>一. 进程基本概念</h1><ol><li><h3 id="进程（process）的定义"><a href="#进程（process）的定义" class="headerlink" title="进程（process）的定义"></a>进程（process）的定义</h3><ul><li>进程是描述程序执行过程和资源共享的基本单位</li><li>主要目的：控制和协调程序的执行</li></ul></li><li><h3 id="进程相关函数"><a href="#进程相关函数" class="headerlink" title="进程相关函数"></a>进程相关函数</h3><ul><li>用户与组ID函数：参阅上一讲Linux系统编程</li><li>创建进程：system()、fork()、exec()</li><li>终止进程：kill()</li><li>等待进程终止：wait()、waitpid()</li></ul></li><li><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><ul><li>定义：由一个或多个相关联的进程组成，目的是为了进行作业控制</li><li>进程组的主要特征：信号可以发送给进程组中的所有进程，并使该进程组中的所有进程终止、停止或继续运行</li><li>每个进程都属于某个进程组</li></ul></li><li><h3 id="进程组函数"><a href="#进程组函数" class="headerlink" title="进程组函数"></a>进程组函数</h3><ul><li>获取进程组ID：<code>pid_t getpgid(pid_t pid);</code><ul><li>返回pid进程的进程组ID；若pid为0，则返回当前进程的进程组ID；出错时返回-1，并设errno值</li></ul></li><li>设置进程组ID：<code>int setpgid(pid_t pid, pig_t pgid);</code><ul><li>若pid为0，则使用调用者PID；若pgid为0，则将pid进程的进程PID设为进程组ID；成功时返回0，出错时返回-1，并设errno值</li></ul></li></ul></li><li><h3 id="会话（session）"><a href="#会话（session）" class="headerlink" title="会话（session）"></a>会话（session）</h3><ul><li>会话为一个或多个进程组的集合，包括登录用户的全部活动，并具有一个控制终端</li><li>登录进程为每个用户创建一个会话，用户登录shell进程成为会话首领，其PID设为会话ID</li><li>非会话首领进程通过调用setsid()函数创建新会话，并成为首领</li></ul></li><li><h4 id="进程组函数-1"><a href="#进程组函数-1" class="headerlink" title="进程组函数"></a>进程组函数</h4><ul><li>获取会话ID：<code>pid_t getsid(pid_t pid);</code><ul><li>返回pid进程的会话ID；若pid为0，则返回当前进程的会话ID；成功时返回会话ID，出错时返回-1，并设errno值</li></ul></li><li>设置会话ID：<code>pid_t setsid();</code><ul><li>成功时返回新创建的会话ID，出错时返回-1，并设errno值</li></ul></li></ul></li></ol><h1 id="二-信号"><a href="#二-信号" class="headerlink" title="二. 信号"></a>二. 信号</h1><ol><li><h3 id="信号（signal）：进程通讯机制"><a href="#信号（signal）：进程通讯机制" class="headerlink" title="信号（signal）：进程通讯机制"></a>信号（signal）：进程通讯机制</h3><ul><li>信号是发送给进程的特殊异步消息</li><li>当进程接收到信息时立即处理，此时并不需要完成当前函数调用甚至当前代码行</li><li>Linux系统中有多种信号，各具有不同的意义；系统以数字标识不同的信号，程序一般以名称引用之</li></ul></li><li><h3 id="系统信号"><a href="#系统信号" class="headerlink" title="系统信号"></a>系统信号</h3><ul><li>缺省处理逻辑：终止进程，生成内核转储文件</li><li>使用“kill –l”命令可查看操作系统支持的信号列表，不同的系统可能有所不同</li><li>系统信号表：</li></ul></li></ol><table><thead><tr><th align="center">信号</th><th align="center">值</th><th align="center">缺省动作</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SIGHUP</td><td align="center">1</td><td align="center">终止进程</td><td align="center">终端的挂断或进程死亡</td></tr><tr><td align="center">SIGINT</td><td align="center">2</td><td align="center">终止进程</td><td align="center">来自键盘的中断信号，通常为Ctrl+C</td></tr><tr><td align="center">SIGQUIT</td><td align="center">3</td><td align="center">内核转储</td><td align="center">来自键盘的离开信号</td></tr><tr><td align="center">SIGILL</td><td align="center">4</td><td align="center">内核转储</td><td align="center">非法指令</td></tr><tr><td align="center">SIGTRAP</td><td align="center">5</td><td align="center">内核转储</td><td align="center">断点或其他陷阱指令，用于调试器</td></tr><tr><td align="center">SIGABRT</td><td align="center">6</td><td align="center">内核转储</td><td align="center">来自abort的异常信号</td></tr><tr><td align="center">SIGBUS</td><td align="center">7</td><td align="center">内核转储</td><td align="center">总线错误（内存访问错误）</td></tr><tr><td align="center">SIGFPE</td><td align="center">8</td><td align="center">内核转储</td><td align="center">浮点异常</td></tr><tr><td align="center">SIGKILL</td><td align="center">9</td><td align="center">终止进程</td><td align="center">杀死进程</td></tr><tr><td align="center">SIGUSR1</td><td align="center">10</td><td align="center">终止进程</td><td align="center">用户自定义信号1</td></tr><tr><td align="center">SIGSEGV</td><td align="center">11</td><td align="center">内核转储</td><td align="center">段非法错误（内存访问无效）</td></tr><tr><td align="center">SIGUSR2</td><td align="center">12</td><td align="center">终止进程</td><td align="center">用户自定义信号2</td></tr><tr><td align="center">SIGPIPE</td><td align="center">13</td><td align="center">终止进程</td><td align="center">管道损坏：向一个没有读进程的管道写数据</td></tr><tr><td align="center">SIGALRM</td><td align="center">14</td><td align="center">终止进程</td><td align="center">计时器定时信号</td></tr><tr><td align="center">SIGTERM</td><td align="center">15</td><td align="center">终止进程</td><td align="center">进程终止信号</td></tr><tr><td align="center">SIGSTKFLT</td><td align="center">16</td><td align="center">终止进程</td><td align="center">协处理器堆栈错误（不使用）</td></tr><tr><td align="center">SIGCHLD</td><td align="center">17</td><td align="center">忽略</td><td align="center">子进程停止或终止</td></tr><tr><td align="center">SIGCONT</td><td align="center">18</td><td align="center">忽略</td><td align="center">如果停止，继续执行</td></tr><tr><td align="center">SIGSTOP</td><td align="center">19</td><td align="center">停止进程</td><td align="center">非来自终端的停止信号</td></tr><tr><td align="center">SIGTSTP</td><td align="center">20</td><td align="center">停止进程</td><td align="center">来自终端的停止信号，通常为Ctrl+Z</td></tr><tr><td align="center">SIGTTIN</td><td align="center">21</td><td align="center">停止进程</td><td align="center">后台进程读终端</td></tr><tr><td align="center">SIGTTOU</td><td align="center">22</td><td align="center">停止进程</td><td align="center">后台进程写终端</td></tr><tr><td align="center">SIGURG</td><td align="center">23</td><td align="center">忽略</td><td align="center">有紧急数据到达套接字信号</td></tr><tr><td align="center">SIGXCPU</td><td align="center">24</td><td align="center">内核转储</td><td align="center">超过CPU时限</td></tr><tr><td align="center">SIGXFSZ</td><td align="center">25</td><td align="center">内核转储</td><td align="center">超过文件长度限制</td></tr><tr><td align="center">SIGVTALRM</td><td align="center">26</td><td align="center">终止进程</td><td align="center">虚拟计时器定时信号（进程占用CPU时间）</td></tr><tr><td align="center">SIGPROF</td><td align="center">27</td><td align="center">终止进程</td><td align="center">计时器定时信号（程序占用CPU时间和系统调度时间）</td></tr><tr><td align="center">SIGWINCH</td><td align="center">28</td><td align="center">忽略</td><td align="center">窗口大小改变</td></tr><tr><td align="center">SIGIO</td><td align="center">29</td><td align="center">终止进程</td><td align="center">描述符上可以进行I/O操作</td></tr><tr><td align="center">SIGPWR</td><td align="center">30</td><td align="center">终止进程</td><td align="center">电力故障</td></tr><tr><td align="center">SIGSYS</td><td align="center">31</td><td align="center">内核转储</td><td align="center">非法系统调用</td></tr></tbody></table><ol start="3"><li><h3 id="进程间发送的信号"><a href="#进程间发送的信号" class="headerlink" title="进程间发送的信号"></a>进程间发送的信号</h3><ul><li>SIGTERM、SIGKILL：终止进程信号，前者是请求（接收信号的进程可以忽略之），后者是强制</li><li>SIGUSR1、SIGUSR2：用户自定义信号，可用于向进程发送命令</li></ul></li><li><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><ul><li>进程接收到信号后，根据信号配置进行处理</li><li>缺省配置：在程序没有处理时，确定信号该如何处理</li><li>程序处理信号的方式：按照信号处理例程的函数指针类型定义一个函数，然后调用</li></ul></li><li><h3 id="sigaction-函数：设置信号配置"><a href="#sigaction-函数：设置信号配置" class="headerlink" title="sigaction()函数：设置信号配置"></a>sigaction()函数：设置信号配置</h3><ul><li>原型：<code>int sigaction(int signum, const struct sigaction * act, struct sigaction * oldact);</code></li><li>signum为信号编号，act和oldact分别为指向信号结构体struct sigaction的指针，前者为新配置，后者为需要保存的老配置</li></ul></li><li><h3 id="信号结构体struct-sigaction"><a href="#信号结构体struct-sigaction" class="headerlink" title="信号结构体struct sigaction"></a>信号结构体struct sigaction</h3><ul><li>最重要的成员为sa_handler，其取值为SIG_DFL（使用信号缺省配置）、SIG_IGN（忽略该信号）或指向信号处理例程的函数指针（以信号编号为参数，无返回值）</li></ul></li><li><h3 id="处理信号时的注意事项"><a href="#处理信号时的注意事项" class="headerlink" title="处理信号时的注意事项"></a>处理信号时的注意事项</h3><ul><li>信号是异步操作，当处理信号时，主程序非常脆弱</li><li>信号处理例程应尽可能短小，它甚至有可能会被新信号所中断</li><li>尽量不要在信号处理例程中实施I/O操作，也不要频繁调用系统函数或库函数</li><li>在信号处理例程中进行复杂的赋值操作也是危险的，它可能不是原子操作，因而有可能在执行期间被中断</li><li>如果需要赋值，使用sig_atomic_t类型的全局变量（在Linux中等价于int，亦即允许整数或指针赋值，更大尺寸数据不允许）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;//  处理信号的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">sig_atomic_t</span>  sigusr1_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>  &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnSigUsr1</span><span class="params">(<span class="keyword">int</span> signal_number)</span> </span>&#123;</span><br><span class="line">    ++sigusr1_count;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>  &lt;&lt; <span class="string">&quot;pid: &quot;</span> &lt;&lt; (<span class="keyword">int</span>)getpid() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = &amp;OnSigUsr1;</span><br><span class="line">sigaction(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);  <span class="comment">// sa挂接到SIGUSR1</span></span><br><span class="line">sleep(<span class="number">100</span>);    <span class="comment">//  在终端中输入kill –s SIGUSR1 pid，信号计数器将递增</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SIGUSR1 counts: &quot;</span> &lt;&lt; sigusr1_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="三-进程管理"><a href="#三-进程管理" class="headerlink" title="三. 进程管理"></a>三. 进程管理</h1><ol><li><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ol><li><h4 id="system-函数：用于在程序中执行一条命令"><a href="#system-函数：用于在程序中执行一条命令" class="headerlink" title="system()函数：用于在程序中执行一条命令"></a>system()函数：用于在程序中执行一条命令</h4><ul><li>原型：<code>int system(const char * cmd);</code></li><li>在Bourne shell中，系统会创建一个子进程运行被调命令；返回值为shell的退出状态；如果shell不能运行，返回127；如果发生其他错误，返回-1</li><li>示例：<code>int ret_val = system(&quot;ls -l /&quot;);</code></li></ul></li><li><h4 id="fork-函数：创建当前进程的副本作为子进程"><a href="#fork-函数：创建当前进程的副本作为子进程" class="headerlink" title="fork()函数：创建当前进程的副本作为子进程"></a>fork()函数：创建当前进程的副本作为子进程</h4><ul><li>原型：<code>pid_t fork();</code></li><li>返回值为0（新创建的子进程）和子进程的PID（父进程）</li><li>使用fork()函数创建进程副本：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the main program process ID is &quot;</span> &lt;&lt; (<span class="keyword">int</span>)getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">pid_t</span>  child_pid = fork();</span><br><span class="line"><span class="keyword">if</span>( child_pid != <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is the parent process, with id &quot;</span> &lt;&lt; (<span class="keyword">int</span>)getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the child’s process ID is &quot;</span> &lt;&lt; (<span class="keyword">int</span>)child_pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is the child process, with id &quot;</span> &lt;&lt; (<span class="keyword">int</span>)getpid() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    the main program process ID is 30840</span></span><br><span class="line"><span class="comment">    this is the parent process, with id 30840</span></span><br><span class="line"><span class="comment">    the child’s process ID is 30841</span></span><br><span class="line"><span class="comment">    this is the child process, with id 30841</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="exec-函数簇原型"><a href="#exec-函数簇原型" class="headerlink" title="exec()函数簇原型"></a>exec()函数簇原型</h4><ul><li>int execl(const char * path, const char * arg, …);</li><li>int execlp(const char * file, const char * arg, …);</li><li>int execle(const char * path, const char * arg, …, char * const envp[]);</li><li>int execv(const char * path, char * const argv[]);</li><li>int execvp(const char * file, char * const argv[]);</li><li>int execvpe(const char * file, char * const argv[], char * const envp[]);</li><li>exec()函数说明<ul><li>函数名称中包含字母“p”（execvp、execlp）：接受程序名作为参数，在当前执行路径中按程序名查找；不包含字母“p”的，必须提供程序的完整路径</li><li>函数名称中包含字母“v”（execv、 execvp、execve）：接受以NULL结尾的字符串数组格式的参数列表</li><li>函数名称中包含字母“l”（execl、 execlp、execle） ：接受C格式的可变参数列表</li><li>函数名称中包含字母“e”（execve、execle） ：接受一个附加的环境参数列表，参数格式为NULL结尾的字符串数组，且字符串的格式为“VARIABLE=value”</li></ul></li><li>基本模式：在程序中调用fork()创建一个子进程，然后调用exec()在子进程中执行命令<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn</span><span class="params">(<span class="keyword">char</span> *program, <span class="keyword">char</span> **args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *args[] = &#123;(<span class="keyword">char</span> *)<span class="string">&quot;ls&quot;</span>, (<span class="keyword">char</span> *)<span class="string">&quot;-l&quot;</span>, (<span class="keyword">char</span> *)<span class="string">&quot;/&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">spawn((<span class="keyword">char</span> *)<span class="string">&quot;ls&quot;</span>, args);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done!\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  创建一个子进程运行新程序</span></span><br><span class="line"><span class="comment">//  program为程序名，arg_list为程序的参数列表；返回值为子进程id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn</span><span class="params">(<span class="keyword">char</span> *program, <span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork(); <span class="comment">//  复制进程</span></span><br><span class="line"><span class="keyword">if</span> (child_pid != <span class="number">0</span>)       <span class="comment">//  此为父进程</span></span><br><span class="line">    <span class="keyword">return</span> child_pid;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//  此为子进程</span></span><br><span class="line">&#123;</span><br><span class="line">    execvp(program, args); <span class="comment">//  执行程序，按路径查找</span></span><br><span class="line">    <span class="comment">//  只有发生错误时，该函数才返回</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error occurred when executing execvp.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ol><li><h4 id="进程调度策略：先进先出，时间片轮转，普通调度，批调度，高优先级抢先"><a href="#进程调度策略：先进先出，时间片轮转，普通调度，批调度，高优先级抢先" class="headerlink" title="进程调度策略：先进先出，时间片轮转，普通调度，批调度，高优先级抢先"></a>进程调度策略：先进先出，时间片轮转，普通调度，批调度，高优先级抢先</h4><ul><li>子进程与父进程的调度没有固定顺序；不能假设子进程一定会在父进程之后执行，也不能假设子进程一定会在父进程之前结束</li></ul></li><li><h4 id="进程调度策略函数：头文件“sched-h”"><a href="#进程调度策略函数：头文件“sched-h”" class="headerlink" title="进程调度策略函数：头文件“sched.h”"></a>进程调度策略函数：头文件“sched.h”</h4><ul><li>获取进程调度策略：<code>int sched_getscheduler(pid_t pid);</code></li><li>设置进程调度策略：<code>int sched_setscheduler(pid_t pid, int policy, const struct sched_param * sp);</code></li><li>获取进程调度参数：<code>int sched_getparam(pid_t pid, struct sched_param * sp);</code></li><li>设置进程调度参数：<code>int sched_setparam(pid_t pid, const struct sched_param * sp);</code></li></ul></li><li><h4 id="进程优先级调整：头文件“sys-time-h”和“sys-resource-h”"><a href="#进程优先级调整：头文件“sys-time-h”和“sys-resource-h”" class="headerlink" title="进程优先级调整：头文件“sys/time.h”和“sys/resource.h”"></a>进程优先级调整：头文件“sys/time.h”和“sys/resource.h”</h4><ul><li>改变进程优先级：<code>int nice(int inc);</code>（头文件“unistd.h”）</li><li>获取进程优先级：<code>int getpriority(int which, int who);</code></li><li>设置进程优先级：<code>int setpriority(int which, int who, int prio);</code></li></ul></li><li><h4 id="处理器亲和性-该进程倾向于在第几号cpu上去做-：头文件“sched-h”"><a href="#处理器亲和性-该进程倾向于在第几号cpu上去做-：头文件“sched-h”" class="headerlink" title="处理器亲和性(该进程倾向于在第几号cpu上去做)：头文件“sched.h”"></a>处理器亲和性(该进程倾向于在第几号cpu上去做)：头文件“sched.h”</h4><ul><li>获取进程的处理器亲和性：<code>int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t * mask);</code></li><li>设置进程的处理器亲和性：<code>int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t * mask);</code></li></ul></li></ol></li><li><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ol><li><h4 id="终止进程函数：kill"><a href="#终止进程函数：kill" class="headerlink" title="终止进程函数：kill()"></a>终止进程函数：kill()</h4><ul><li>头文件“sys/types.h”和“signal.h”</li><li>原型：<code>int kill(pid_t pid, int sig);</code></li><li>函数参数：pid为子进程ID，sig应为进程终止信号SIGTERM</li></ul></li><li><h4 id="等待进程结束函数：wait"><a href="#等待进程结束函数：wait" class="headerlink" title="等待进程结束函数：wait()"></a>等待进程结束函数：wait()</h4><ul><li>原型：<code>pid_t wait(int * status);</code>  <code>pid_t waitpid(pid_t pid, int * status, int options);</code></li><li>阻塞主调进程，直到一个子进程结束</li><li>WEXITSTATUS宏：查看子进程的退出码</li><li>WIFEXITED宏：确定子进程的退出状态是正常退出，还是未处理信号导致的意外死亡<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;    //  必须包含此头文件，否则与wait共用体冲突</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn</span><span class="params">( <span class="keyword">char</span> * program, <span class="keyword">char</span> ** arg_list )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> * arg_list[] = &#123; (<span class="keyword">char</span>*)<span class="string">&quot;ls&quot;</span>, (<span class="keyword">char</span>*)<span class="string">&quot;-l&quot;</span>, (<span class="keyword">char</span>*)<span class="string">&quot;/&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">spawn( (<span class="keyword">char</span>*)<span class="string">&quot;ls&quot;</span>, arg_list );</span><br><span class="line"><span class="keyword">int</span> child_status;</span><br><span class="line">wait( &amp;child_status );    <span class="comment">//  等待子进程结束</span></span><br><span class="line"><span class="keyword">if</span>( WIFEXITED( child_status ) )    <span class="comment">//  判断子进程是否正常退出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exited normally with &quot;</span> &lt;&lt; WEXITSTATUS(child_status) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exited abnormally.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done!\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  创建一个子进程运行新程序</span></span><br><span class="line"><span class="comment">//  program为程序名，arg_list为程序的参数列表；返回值为子进程id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn</span><span class="params">( <span class="keyword">char</span> * program, <span class="keyword">char</span> ** args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();<span class="comment">//  复制进程</span></span><br><span class="line"><span class="keyword">if</span>( child_pid != <span class="number">0</span> )<span class="comment">//  此为父进程</span></span><br><span class="line">    <span class="keyword">return</span> child_pid;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//  此为子进程</span></span><br><span class="line">&#123;</span><br><span class="line">    execvp( program, args );<span class="comment">//  执行程序，按路径查找</span></span><br><span class="line">    <span class="comment">//  只有发生错误时，该函数才返回</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error occurred when executing execvp.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ol><li><h4 id="子进程已结束，但父进程未调用wait-函数等待"><a href="#子进程已结束，但父进程未调用wait-函数等待" class="headerlink" title="子进程已结束，但父进程未调用wait()函数等待"></a>子进程已结束，但父进程未调用wait()函数等待</h4><ul><li>子进程已终止，但没有被正确清除，成为僵尸进程</li></ul></li><li><h4 id="清除子进程的手段"><a href="#清除子进程的手段" class="headerlink" title="清除子进程的手段"></a>清除子进程的手段</h4><ul><li>父进程调用wait()函数可确保子进程被清除</li><li>即使子进程在父进程调用wait()函数前已死亡（成为僵尸），其退出状态也可以被抽取出来，然后被清除</li><li>未清除的子进程自动被init进程收养</li></ul></li></ol></li><li><h3 id="子进程异步清除"><a href="#子进程异步清除" class="headerlink" title="子进程异步清除"></a>子进程异步清除</h3><ol><li><h4 id="SIGCHLD信号：子进程终止时，向父进程自动发送，编写此信号处理例程，异步清除子进程"><a href="#SIGCHLD信号：子进程终止时，向父进程自动发送，编写此信号处理例程，异步清除子进程" class="headerlink" title="SIGCHLD信号：子进程终止时，向父进程自动发送，编写此信号处理例程，异步清除子进程"></a>SIGCHLD信号：子进程终止时，向父进程自动发送，编写此信号处理例程，异步清除子进程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">sig_atomic_t</span> child_exit_status;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">(<span class="keyword">int</span> sig_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);              <span class="comment">//  清除子进程,子进程的状态返回到了status中</span></span><br><span class="line">    child_exit_status = status; <span class="comment">//  存储子进程的状态</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  处理SIGCHLD信号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>( &amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa) );</span><br><span class="line">sa.sa_handler = &amp;CleanUp;</span><br><span class="line">sigaction( SIGCHLD, &amp;sa, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//  正常处理代码在此，例如调用fork()创建子进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ol><li><h4 id="创建守护进程的步骤"><a href="#创建守护进程的步骤" class="headerlink" title="创建守护进程的步骤"></a>创建守护进程的步骤</h4><ul><li>创建新进程：新进程将成为未来的守护进程</li><li>守护进程的父进程退出：保证祖父进程确认父进程已结束，且守护进程不是组长进程</li><li>守护进程创建新进程组和新会话：并成为两者的首进程，此时刚创建的新会话还没有关联控制终端</li><li>改变工作目录：守护进程一般随系统启动，工作目录不应继续使用继承的工作目录</li><li>重设文件权限掩码：不需要继承文件权限掩码</li><li>关闭所有文件描述符：不需要继承任何打开的文件描述符</li><li>标准流重定向到/dev/null<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">-1</span> )<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( pid != <span class="number">0</span> )<span class="built_in">exit</span>( EXIT_SUCCESS );</span><br><span class="line"><span class="comment">//  子进程</span></span><br><span class="line"><span class="keyword">if</span>( setsid() == <span class="number">-1</span> )<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="comment">//  设置工作目录</span></span><br><span class="line"><span class="keyword">if</span>( chdir( <span class="string">&quot;/&quot;</span> ) == <span class="number">-1</span> )<span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"><span class="comment">//  重设文件权限掩码</span></span><br><span class="line">umask( <span class="number">0</span> );</span><br><span class="line"><span class="comment">//  关闭文件描述符</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )close( i );</span><br><span class="line"><span class="comment">//  重定向标准流</span></span><br><span class="line">open( <span class="string">&quot;/dev/null&quot;</span>, O_RDWR );<span class="comment">// stdin</span></span><br><span class="line">dup( <span class="number">0</span> );<span class="comment">// stdout</span></span><br><span class="line">dup( <span class="number">0</span> );<span class="comment">// stderr</span></span><br><span class="line"><span class="comment">//  守护进程的实际工作代码在此</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="守护进程创建函数daemon"><a href="#守护进程创建函数daemon" class="headerlink" title="守护进程创建函数daemon()"></a>守护进程创建函数daemon()</h4><ul><li>实现了前述功能，减轻编写守护进程的负担</li><li>原型：<code>int daemon(int nochdir, int noclose);</code></li><li>参数：若nochdir非0，不更改工作目录；若noclose非0，不关闭所有打开的文件描述符；一般均设为0</li><li>返回值：成功时返回0，失败时返回-1，并设置errno值</li></ul></li></ol></li></ol><h1 id="四-进程间通信"><a href="#四-进程间通信" class="headerlink" title="四. 进程间通信"></a>四. 进程间通信</h1><ol><li><h3 id="管道：相关进程间的顺序通信"><a href="#管道：相关进程间的顺序通信" class="headerlink" title="管道：相关进程间的顺序通信"></a>管道：相关进程间的顺序通信</h3><ol><li><h4 id="管道（pipe）的性质与意义"><a href="#管道（pipe）的性质与意义" class="headerlink" title="管道（pipe）的性质与意义"></a>管道（pipe）的性质与意义</h4><ul><li>管道是允许单向通信的自动同步设备（半双工）</li><li>数据在写入端写入，在读取端读取</li><li>管道为串行设备，数据的读取顺序与写入顺序完全相同</li></ul></li><li><h4 id="管道的用途"><a href="#管道的用途" class="headerlink" title="管道的用途"></a>管道的用途</h4><ul><li>只能用于有亲缘关系的进程，例如父进程和子进程之间通信</li></ul></li><li><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>管道的数据容量有限，一般为一个内存页面</li><li>如果写入速度超过读取速度，写入进程将阻塞，直到容量有空闲</li><li>如果读取速度超过写入速度，读取进程将阻塞，直到管道有数据</li></ul></li><li><h4 id="pipe函数：创建管道"><a href="#pipe函数：创建管道" class="headerlink" title="pipe函数：创建管道"></a>pipe函数：创建管道</h4><ul><li>头文件：“unistd.h”和“fcntl.h”</li><li>原型：<code>int pipe(int pipefd[2]); </code></li><li>参数：一个包含两个元素的整数数组，元素类型为文件描述符，0号元为读取文件描述符，1号元为写入文件描述符</li><li>返回值：成功时返回0，不成功时返回-1，并设置errno值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> buf_size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  向stream中写入count次msg</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg, <span class="keyword">int</span> count, FILE *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; count &gt; <span class="number">0</span>; --count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stream, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    fflush(stream);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  从stream中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(FILE *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[buf_size];</span><br><span class="line"><span class="comment">//  一直读取到流的尾部</span></span><br><span class="line"><span class="keyword">while</span> (!feof(stream) &amp;&amp; !ferror(stream) &amp;&amp; fgets(buf, <span class="keyword">sizeof</span>(buf), stream) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Data received: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">pipe(fds);          <span class="comment">//  创建管道</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork(); <span class="comment">//  创建子进程</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;                <span class="comment">//  子进程</span></span><br><span class="line">    close(fds[<span class="number">1</span>]); <span class="comment">//  只读取，关闭管道写入端</span></span><br><span class="line">    <span class="comment">//  将文件描述符转换为FILE *，以方便C/C++标准库函数处理</span></span><br><span class="line">    FILE *stream = fdopen(fds[<span class="number">0</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    Read(stream);  <span class="comment">//  从流中读取数据</span></span><br><span class="line">    close(fds[<span class="number">0</span>]); <span class="comment">//  关闭管道读取端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;                     <span class="comment">//  父进程</span></span><br><span class="line">    <span class="keyword">char</span> buf[buf_size]; <span class="comment">//  数据缓冲区，末尾封装两个‘\0’</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf_size - <span class="number">2</span>; i++)</span><br><span class="line">    buf[i] = <span class="string">&#x27;A&#x27;</span> + i % <span class="number">26</span>;</span><br><span class="line">    buf[buf_size - <span class="number">1</span>] = buf[buf_size - <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    close(fds[<span class="number">0</span>]); <span class="comment">//  只写入，关闭管道读取端</span></span><br><span class="line">    FILE *stream = fdopen(fds[<span class="number">1</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    Write(buf, <span class="number">3</span>, stream);</span><br><span class="line">    close(fds[<span class="number">1</span>]); <span class="comment">//  关闭管道写入端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="等位文件描述符"><a href="#等位文件描述符" class="headerlink" title="等位文件描述符"></a>等位文件描述符</h4><ul><li>共享相同的文件位置和状态标志设置</li></ul></li><li><h4 id="dup-函数：将两个文件描述符等位处理"><a href="#dup-函数：将两个文件描述符等位处理" class="headerlink" title="dup()函数：将两个文件描述符等位处理"></a>dup()函数：将两个文件描述符等位处理</h4><ul><li>原型：<code>int dup(int oldfd);</code> <code>int dup2(int oldfd, int newfd);</code></li><li>参数：创建oldfd的一份拷贝，单参数版本选择数值最小的未用文件描述符作为新的文件描述符；双参数版本使用newfd作为新的文件描述符，拷贝前尝试关闭newfd</li><li>返回值：成功时返回新文件描述符，失败时返回-1，并设errno值</li><li>示例：dup2(fd, STDIN_FILENO)关闭标准输入流，然后作为fd的副本重新打开<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> buf_size = <span class="number">4096</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">pipe(fds); <span class="comment">//  创建管道</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>)<span class="number">0</span>) <span class="comment">//  子进程</span></span><br><span class="line">&#123;</span><br><span class="line">    close(fds[<span class="number">0</span>]);                          <span class="comment">//  关闭管道读取端</span></span><br><span class="line">    dup2(fds[<span class="number">1</span>], STDOUT_FILENO);            <span class="comment">//  管道挂接到标准输出流</span></span><br><span class="line">    <span class="keyword">char</span> *args[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="literal">NULL</span>&#125;; <span class="comment">//  使用“ls”命令替换子进程</span></span><br><span class="line">    execvp(args[<span class="number">0</span>], args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//  父进程</span></span><br><span class="line">&#123;</span><br><span class="line">    close(fds[<span class="number">1</span>]); <span class="comment">//  关闭管道写入端</span></span><br><span class="line">    <span class="keyword">char</span> buf[buf_size];</span><br><span class="line">    FILE *stream = fdopen(fds[<span class="number">0</span>], <span class="string">&quot;r&quot;</span>); <span class="comment">//  以读模式打开管道读取端，返回文件指针</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Data received: \n&quot;</span>);</span><br><span class="line">    <span class="comment">//  在流未结束，未发生读取错误，且能从流中正常读取字符串时，输出读取到的字符串</span></span><br><span class="line">    <span class="keyword">while</span> (!feof(stream) &amp;&amp; !ferror(stream) &amp;&amp; fgets(buf, <span class="keyword">sizeof</span>(buf), stream) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fds[<span class="number">0</span>]);         <span class="comment">//  关闭管道读取端</span></span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//  等待子进程结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="进程信号量：进程间通信的同步控制机制"><a href="#进程信号量：进程间通信的同步控制机制" class="headerlink" title="进程信号量：进程间通信的同步控制机制"></a>进程信号量：进程间通信的同步控制机制</h3><ol><li><h4 id="进程信号量：-System-V信号量"><a href="#进程信号量：-System-V信号量" class="headerlink" title="进程信号量： System V信号量"></a>进程信号量： System V信号量</h4><ul><li>可以使用同步机制确定进程的先后执行关系</li><li>头文件：“sys/types.h”、“sys/ipc.h”和“sys/sem.h”</li></ul></li><li><h4 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h4><ul><li>信号量是一类特殊的计数器，其值为非负整数，用于进程或线程同步</li></ul></li><li><h4 id="信号量的操作"><a href="#信号量的操作" class="headerlink" title="信号量的操作"></a>信号量的操作</h4><ul><li>等待（wait）操作（P）：信号量的值递减1后返回；如果值为0，则阻塞操作，直到信号量值为正（其他进程或线程释放了信号量），然后递减1后返回</li><li>发布（post）操作（V）：信号量的值递增1后返回；如果信号量值原为0，则其中一个等待该信号量的进程或线程取消阻塞</li></ul></li><li><h4 id="Linux信号量实现：两个版本"><a href="#Linux信号量实现：两个版本" class="headerlink" title="Linux信号量实现：两个版本"></a>Linux信号量实现：两个版本</h4><ul><li>进程信号量多用于进程同步，POSIX标准实现多用于线程同步</li></ul></li><li><h4 id="使用进程信号量时的注意事项"><a href="#使用进程信号量时的注意事项" class="headerlink" title="使用进程信号量时的注意事项"></a>使用进程信号量时的注意事项</h4><ul><li>每次创建和管理的进程信号量不是一个，而是一个集合（数组），该集合可能包含多个进程信号量</li><li>使用键值key关联进程信号量集，但进程信号量集本身由进程信号量的标识符semid标识，函数调用时几乎总是使用semid——可以这么理解：semid对内，key对外</li></ul></li><li><h4 id="semget-函数：创建或获取进程信号量集"><a href="#semget-函数：创建或获取进程信号量集" class="headerlink" title="semget()函数：创建或获取进程信号量集"></a>semget()函数：创建或获取进程信号量集</h4><ul><li>原型：<code>int semget(key_t key, int nsems, int semflg);</code></li><li>参数：key为键值，多个进程可以通过此键值访问同一进程信号量；nsems为需要创建的进程信号量集的进程信号量元素个数（不是进程信号量的信号数）， semflg为访问标志</li><li>返回值：成功时返回进程信号量集的标识符，失败时返回-1，并设置errno值</li><li>要获取已分配的进程信号量集，使用原先键值查询，此时进程信号量集的元素个数可设置为0</li><li>键值IPC_PRIVATE用于创建当前进程的私有进程信号量集</li><li>使用IPC_CREAT和IPC_EXCL创建进程信号量集，后者要求创建新的唯一的进程信号量集，若其已存在，则出错</li></ul></li><li><h4 id="控制和管理进程信号量集"><a href="#控制和管理进程信号量集" class="headerlink" title="控制和管理进程信号量集"></a>控制和管理进程信号量集</h4><ul><li>原型：<code>int semctl(int semid, int semnum, int cmd, …);</code></li><li>参数：semid为进程信号量集的标识符，semnum为进程信号量集的元素下标，cmd为指定操作，第四个参数arg可有可无，与cmd有关</li><li>返回值：成功时与cmd有关，失败时返回-1，并设置errno值</li><li>调用semctl()函数的进程的有效用户ID必须与分配进程信号量集的用户权限匹配</li></ul></li><li><h4 id="释放（删除）进程信号量集：IPC-RMID"><a href="#释放（删除）进程信号量集：IPC-RMID" class="headerlink" title="释放（删除）进程信号量集：IPC_RMID"></a>释放（删除）进程信号量集：IPC_RMID</h4><ul><li>最后一个使用进程信号量的进程负责清除进程信号量集</li><li>进程信号量集释放后，内存自动释放</li><li>调用说明：cmd为IPC_RMID，semnum被忽略，arg不需要；如果需要arg，定义union semun类型的变量并作为参数，部分系统可能未定义union semun类型，需按如下格式补充定义：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;<span class="comment">//  供SETVAL使用的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> * <span class="title">buf</span>;</span><span class="comment">//  供IPC_STAT、IPC_SET使用的缓冲区</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> * <span class="built_in">array</span>;<span class="comment">//  供GETALL、SETALL使用的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> * __<span class="title">buf</span>;</span><span class="comment">//  供IPC_INFO使用的缓冲区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="初始化进程信号量集：SETALL"><a href="#初始化进程信号量集：SETALL" class="headerlink" title="初始化进程信号量集：SETALL"></a>初始化进程信号量集：SETALL</h4><ul><li>第一个参数semid为进程信号量集的标识符，第二个参数semnum为0，第三个参数cmd为SETALL，第四个参数arg必须为union semun类型的数据对象</li><li>union semun的array字段：指向无符号短整型数组首元素的指针，该数组保存进程信号量集的所有信号量的信号数</li></ul></li><li><h4 id="其他常用命令参数"><a href="#其他常用命令参数" class="headerlink" title="其他常用命令参数"></a>其他常用命令参数</h4><ul><li>IPC_STAT/IPC_SET（获取或设置进程信号量信息）、GETALL（获取全部信号量的信号数）、 GETVAL/SETVAL （获取或设置单个信号量的信号数）等</li></ul></li><li><h4 id="获取与释放"><a href="#获取与释放" class="headerlink" title="获取与释放"></a>获取与释放</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取与key关联的二元信号量集，必要时会分配之</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AcquireBinarySemaphore</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> sem_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> semget(key, <span class="number">1</span>, sem_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  释放二元信号量集，单一元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReleaseBinarySemaphore</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">ignored</span>;</span></span><br><span class="line"><span class="keyword">return</span> semctl(semid, <span class="number">1</span>, IPC_RMID, ignored);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  初始化二元信号量集，单一元素，信号量初始值为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitializeBinarySemaphore</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> values[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">needed</span> =</span> &#123;.<span class="built_in">array</span> = values&#125;;</span><br><span class="line"><span class="keyword">return</span> semctl(semid, <span class="number">0</span>, SETALL, needed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="等待与发布进程信号量函数semop"><a href="#等待与发布进程信号量函数semop" class="headerlink" title="等待与发布进程信号量函数semop()"></a>等待与发布进程信号量函数semop()</h4><ul><li>原型：<code>int semop(int semid, struct sembuf * sops, size_t nsops);</code></li><li>参数：semid为待操作的进程信号量集的标识符； sops为操作数组，nsops为操作数组的元素个数</li><li>返回值：成功时为进程信号量集的标识符，失败时返回-1，并设置errno值</li></ul></li><li><h4 id="struct-sembuf类型的成员"><a href="#struct-sembuf类型的成员" class="headerlink" title="struct sembuf类型的成员"></a>struct sembuf类型的成员</h4><ul><li>sem_num：需要操作的进程信号量集中的信号量元素下标</li><li>sem_op：指定信号量操作的整数（递增或递减信号量的信号数）<ul><li>如果sem_op为正数，则立即加到信号量上（V操作）</li><li>如果sem_op为负数，则从信号量上减去（P操作）</li><li>如果会使结果为负数，则阻塞进程，直到信号量的信号数不小于sem_op的绝对值</li><li>如果sem_op为0，则阻塞进程，直到信号量的信号数为0</li></ul></li><li>sem_flg：指定IPC_NOWAIT则不阻塞进程，指定SEM_UNDO则在进程退出时取消操作</li></ul></li><li><h4 id="等待与发布"><a href="#等待与发布" class="headerlink" title="等待与发布"></a>等待与发布</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  P原语：等待二元信号量，信号数非正时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WaitBinarySemaphore</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">ops</span>[1];</span></span><br><span class="line">ops[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">ops[<span class="number">0</span>].sem_op = <span class="number">-1</span>;</span><br><span class="line">ops[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line"><span class="keyword">return</span> semop(semid, ops, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  V原语：发布二元信号量，增加信号数后立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostBinarySemaphore</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">ops</span>[1];</span></span><br><span class="line">ops[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">ops[<span class="number">0</span>].sem_op = <span class="number">1</span>;</span><br><span class="line">ops[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line"><span class="keyword">return</span> semop(semid, ops, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="共享内存：允许多个进程读写同一片内存区域"><a href="#共享内存：允许多个进程读写同一片内存区域" class="headerlink" title="共享内存：允许多个进程读写同一片内存区域"></a>共享内存：允许多个进程读写同一片内存区域</h3><ol><li><h4 id="共享内存的意义：快捷方便的本地通信机制"><a href="#共享内存的意义：快捷方便的本地通信机制" class="headerlink" title="共享内存的意义：快捷方便的本地通信机制"></a>共享内存的意义：快捷方便的本地通信机制</h4><ul><li>头文件：“sys/ipc.h”和“sys/shm.h”</li></ul></li><li><h4 id="共享内存编程原则"><a href="#共享内存编程原则" class="headerlink" title="共享内存编程原则"></a>共享内存编程原则</h4><ul><li>系统没有对共享内存操作提供任何缺省同步行为</li><li>如果需要，程序员自主设计同步策略：使用进程信号量</li></ul></li><li><h4 id="共享内存使用过程"><a href="#共享内存使用过程" class="headerlink" title="共享内存使用过程"></a>共享内存使用过程</h4><ul><li>某个进程分配一个内存段，其他需要访问该内存段的进程连接（attach）该内存段</li><li>完成访问后，进程拆卸（detach）该内存段</li><li>某个时刻，一个进程释放该内存段</li></ul></li><li><h4 id="Linux内存模型"><a href="#Linux内存模型" class="headerlink" title="Linux内存模型"></a>Linux内存模型</h4><ul><li>每个进程的虚拟地址空间按页（page）编址，页缺省为4096字节（不同硬件架构和操作系统可能不同，使用getpagesize()函数获取系统值）</li><li>每个进程维持从内存地址到虚拟页面地址的映射</li><li>多个进程可能使用同一虚拟页面，同样的数据在不同进程中的地址并不需要相同</li><li>分配新的共享内存段将创建虚拟内存页面，其他进程连接该共享内存段即可访问</li><li>共享内存段的分配只有由一个进程负责，释放也同样</li></ul></li><li><h4 id="shmget-函数：获取或分配一段共享内存"><a href="#shmget-函数：获取或分配一段共享内存" class="headerlink" title="shmget()函数：获取或分配一段共享内存"></a>shmget()函数：获取或分配一段共享内存</h4><ul><li>原型：int shmget( key_t key, size_t size, int shmflg );</li><li>参数：key为内存段整数键值，size为内存段分配的字节数（圆整至4096字节整数倍），shmflg为创建共享内存段的位标志</li><li>键值参数key<ul><li>其他进程通过键值key访问该内存段，任意设定的键值可能和其他进程的共享内存段键值冲突，使用IPC_PRIVATE以确保无冲突</li></ul></li><li>创建标志：IPC_CREAT（创建）、IPC_EXCL（独占）<ul><li>后者与前者合并使用，如果键值已使用，则创建失败</li><li>如果未设IPC_EXCL，则在键值已经存在时，返回其代表的共享内存段，而不是创建一个新的共享内存段</li></ul></li><li>位标志参数<ul><li>模式标志：以9位数字表示宿主、组用户和其他人的访问控制权</li><li>常数位于头文件“sys/stat.h”</li></ul></li><li>返回值：共享内存段的标识符</li><li>常用模式常数<ul><li>S_IRUSR和S_IWUSR分别表示共享内存段宿主的读写权限</li><li>S_IRGRP和S_IWGRP分别表示共享内存段组用户的读写权限</li><li>S_IROTH和S_IWOTH分别表示共享内存段其他人的读写权限</li></ul></li><li>调用示例：<code>int seg_id = shmget(shm_key, getpagesize(), IPC_CREAT | S_IRUSR | S_IWUSER);</code></li></ul></li><li><h4 id="shmat-函数：连接共享内存"><a href="#shmat-函数：连接共享内存" class="headerlink" title="shmat()函数：连接共享内存"></a>shmat()函数：连接共享内存</h4><ul><li>原型：<code>void * shmat(int shmid, const void * shmaddr, int shmflg);</code></li><li>参数： shmid为共享内存段标识符（shmget()的返回值）， shmaddr为指针，指向共享内存段的映射地址，如果传递NULL，Linux自动选择合适地址， shmflg为连接标志</li><li>返回值：成功时返回所连接的共享内存段的地址</li><li>连接标志<ul><li>SHM_RND：shmaddr指定的映射地址向下圆整到页面尺寸的整数倍；如果未指定，则传递shmaddr时必须手工对齐页面地址</li><li>SHM_RDONLY：共享内存段组只读</li></ul></li></ul></li><li><h4 id="shmdt-函数：拆卸共享内存段"><a href="#shmdt-函数：拆卸共享内存段" class="headerlink" title="shmdt()函数：拆卸共享内存段"></a>shmdt()函数：拆卸共享内存段</h4><ul><li>原型：<code>int shmdt(const void * shmaddr);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">shmbuf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> seg_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> shared_size = <span class="number">0x6400</span>;</span><br><span class="line">    <span class="comment">//  分配共享内存段</span></span><br><span class="line">    <span class="keyword">int</span> seg_id = shmget(IPC_PRIVATE, shared_size, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="comment">//  连接共享内存段</span></span><br><span class="line">    <span class="keyword">char</span> *shared_mem = (<span class="keyword">char</span> *)shmat(seg_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory attached at %p\n&quot;</span>, shared_mem);</span><br><span class="line">    <span class="comment">//  获取段尺寸信息</span></span><br><span class="line">    shmctl(seg_id, IPC_STAT, &amp;shmbuf);</span><br><span class="line">    seg_size = shmbuf.shm_segsz;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Segment size: %d\n&quot;</span>, seg_size);</span><br><span class="line">    <span class="comment">//  向共享内存区段写入字符串</span></span><br><span class="line">    <span class="built_in">sprintf</span>(shared_mem, <span class="string">&quot;Hello, world.&quot;</span>);</span><br><span class="line">    <span class="comment">//  拆卸共享内存区段</span></span><br><span class="line">    shmdt(shared_mem);</span><br><span class="line">    <span class="comment">//  在不同的地址处重新连接共享内存区段</span></span><br><span class="line">    shared_mem = (<span class="keyword">char</span> *)shmat(seg_id, (<span class="keyword">void</span> *)<span class="number">0x5000000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory reattached at %p\n&quot;</span>, shared_mem);</span><br><span class="line">    <span class="comment">//  获取共享内存区段中的信息并打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, shared_mem);</span><br><span class="line">    <span class="comment">//  拆卸共享内存区段</span></span><br><span class="line">    shmdt(shared_mem);</span><br><span class="line">    <span class="comment">//  释放共享内存区段，与semctl类似</span></span><br><span class="line">    shmctl(seg_id, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="映射内存：与共享内存意义相同，但与文件相关联"><a href="#映射内存：与共享内存意义相同，但与文件相关联" class="headerlink" title="映射内存：与共享内存意义相同，但与文件相关联"></a>映射内存：与共享内存意义相同，但与文件相关联</h3><ol><li><h4 id="mmap-函数：头文件“sys-mman-h”"><a href="#mmap-函数：头文件“sys-mman-h”" class="headerlink" title="mmap()函数：头文件“sys/mman.h”"></a>mmap()函数：头文件“sys/mman.h”</h4><ul><li>映射共享文件到内存；文件被分割成页面大小装载；使用内存读写操作访问文件，速度更快；对映射内存的写入自动反映到文件中</li><li>原型：<code>void * mmap(void * addr, size_t length, int prot, int flags, int fd, off_t offset);</code></li><li>函数参数<ul><li>addr：映射目的地的内存地址，NULL表示由Linux自动选择合适的内存地址</li><li>length：映射内存的大小，以字节为单位</li><li>prot：指定映射内存的保护权限，为PROT_READ（允许读取）、 PROT_WRITE（允许写入）、 PROT_EXEC（允许执行）或以上三者的组合</li><li>flags：附加选项标志；为MAP_FIXED（如果指定此标志，则Linux使用用户指定的地址映射文件，地址本身必须页对齐）、 MAP_PRIVATE（内存写入不回写至外部文件，本进程保留写入的文件副本）、 MAP_SHARED（内存写入立即反映到映射文件中）； MAP_PRIVATE与MAP_SHARED不能混用</li><li>fd：待映射文件的文件描述符</li><li>offset：指定映射数据在文件中的偏移量</li></ul></li><li>函数返回值<ul><li>成功调用时返回映射内存的基地址，失败时返回MAP_FAILED</li></ul></li></ul></li><li><h4 id="munmap-函数：释放映射内存"><a href="#munmap-函数：释放映射内存" class="headerlink" title="munmap()函数：释放映射内存"></a>munmap()函数：释放映射内存</h4><ul><li>原型：int * munmap( void * addr, size_t length );</li><li>参数：addr为映射内存的基地址；length为映射内存的大小</li><li>返回值：成功时返回0，失败时返回-1并设errno值</li></ul></li><li><h4 id="msync-函数：映射内存同步"><a href="#msync-函数：映射内存同步" class="headerlink" title="msync()函数：映射内存同步"></a>msync()函数：映射内存同步</h4><ul><li>原型：int msync( void * addr, size_t length, int flags);</li><li>参数：addr为映射内存基地址，length为映射内存大小，flags为同步标志，MS_ASYNC（数据更新被调度，但函数返回前并不一定会被执行）； MS_SYNC（数据更新立即执行，在完成前调用进程被阻塞）； MS_INVALIDATE（通知其他进程数据已无效，并自动提供新数据）； MS_ASYNC与MS_SYNC不能混用</li><li>返回值：成功时返回0，失败时返回-1并设errno值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mapped_size = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mapped_count = mapped_size / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  打开文件作为内存映射的对象，确保文件尺寸足够存储1024个整数</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">    lseek(fd, mapped_size - <span class="number">1</span>, SEEK_SET);</span><br><span class="line">    write(fd, <span class="string">&quot;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">int</span> *base = (<span class="keyword">int</span> *)mmap(<span class="number">0</span>, mapped_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, fd, <span class="number">0</span>);</span><br><span class="line">    close(fd); <span class="comment">//  创建映射内存后，关闭文件的文件描述符</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>)<span class="number">0</span>) <span class="comment">//  子进程写入数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  写入数据0～1023</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, *p = base; i &lt; mapped_count; *p++ = i++)</span><br><span class="line">            ;</span><br><span class="line">        munmap(base, mapped_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; (<span class="keyword">pid_t</span>)<span class="number">0</span>) <span class="comment">// 父进程读取数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>); <span class="comment">//  等待10秒</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, *p = base; i &lt; mapped_count; i++, p++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>) &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        munmap(base, mapped_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="消息队列：在进程间传递二进制块数据"><a href="#消息队列：在进程间传递二进制块数据" class="headerlink" title="消息队列：在进程间传递二进制块数据"></a>消息队列：在进程间传递二进制块数据</h3><ol><li><h4 id="消息队列：在两个进程间传递二进制块数据"><a href="#消息队列：在两个进程间传递二进制块数据" class="headerlink" title="消息队列：在两个进程间传递二进制块数据"></a>消息队列：在两个进程间传递二进制块数据</h4><ul><li>数据块具有类别信息，接收方可根据消息类别有选择地接收</li><li>头文件：“sys/type.h”、“sys/ipc.h”和“sys/msg.h”</li></ul></li><li><h4 id="msgget-函数：创建或获取消息队列"><a href="#msgget-函数：创建或获取消息队列" class="headerlink" title="msgget()函数：创建或获取消息队列"></a>msgget()函数：创建或获取消息队列</h4><ul><li>原型：<code>int msgget(ket_t key, int msgflg);</code></li><li>参数：key为键值，标识全局唯一的消息队列；msgflg为创建标志，与semget()的标志相同</li><li>返回值：成功时返回正整数作为消息队列的标识符，失败时返回-1，并设errno值</li><li>如果用于创建消息队列，相关内核数据结构struct msqid_ds将被创建并初始化</li></ul></li><li><h4 id="msgsnd-函数：将消息添加到消息队列中"><a href="#msgsnd-函数：将消息添加到消息队列中" class="headerlink" title="msgsnd()函数：将消息添加到消息队列中"></a>msgsnd()函数：将消息添加到消息队列中</h4><ul><li>原型：<code>int msgsnd(int msqid, const void * msg_ptr, size_t msg_sz, int msgflg);</code></li><li>参数： msqid为msgget()返回的消息队列标识符；msg_ptr指向准备发送的消息； msg_sz为消息数据长度；msgflg控制消息发送行为，一般仅支持IPC_NOWAIT标志，即以非阻塞的方式发送消息</li><li>返回值：成功时返回0，失败时返回-1，并设errno值</li><li>消息缓冲区结构<ul><li>msg_ptr指向的数据结构如右</li><li>mtype为消息类别，必须为正整数</li><li>mtext为消息数据，msg_sz为其实际长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="msgrcv-函数：从消息队列中获取消息"><a href="#msgrcv-函数：从消息队列中获取消息" class="headerlink" title="msgrcv()函数：从消息队列中获取消息"></a>msgrcv()函数：从消息队列中获取消息</h4><ul><li>原型：int msgrcv( int msqid, void * msg_ptr, size_t msg_sz, long int msgtype, int msgflg );</li><li>参数： msqid为msgget()返回的消息队列标识符；msg_ptr用于存储接收的消息；msg_sz为消息数据长度；msgtype为消息类别；msgflg控制消息发送行为，可以为IPC_NOWAIT、MSG_EXCEPT（msgtype大于0时，读取第一个非msgtype类别的消息）和MSG_NOERROR的位或</li><li>返回值：成功时返回0，失败时返回-1，并设errno值</li><li>消息类别msgtype说明：为0则读取队列第一条消息，大于0则读取队列中第一条类别为msgtype的消息，小于0则读取队列中第一个类别比msgtype绝对值小的消息</li></ul></li><li><h4 id="msgctl-函数：控制消息队列的某些属性"><a href="#msgctl-函数：控制消息队列的某些属性" class="headerlink" title="msgctl()函数：控制消息队列的某些属性"></a>msgctl()函数：控制消息队列的某些属性</h4><ul><li>原型：int msgctl( int msqid, int cmd, struct msqid_ds * buf );</li><li>参数： msqid为msgget()返回的消息队列标识符；cmd指定要执行的命令，支持的命令有IPC_STAT、IPC_SET、IPC_RMID、IPC_INFO、MSG_INFO、MSG_STAT；buf的意义与cmd参数有关</li><li>返回值：成功时返回值取决于cmd参数，失败时返回-1，并设errno值</li></ul></li></ol></li><li><h3 id="套接字：支持无关进程，甚至不同计算机进行通信"><a href="#套接字：支持无关进程，甚至不同计算机进行通信" class="headerlink" title="套接字：支持无关进程，甚至不同计算机进行通信"></a>套接字：支持无关进程，甚至不同计算机进行通信</h3></li></ol><h1 id="五-进程池"><a href="#五-进程池" class="headerlink" title="五. 进程池"></a>五. 进程池</h1><ol><li><h3 id="动机：为什么需要引入进程池？"><a href="#动机：为什么需要引入进程池？" class="headerlink" title="动机：为什么需要引入进程池？"></a>动机：为什么需要引入进程池？</h3><ul><li>进程需要频繁创建子进程，以执行特定任务</li><li>动态创建子进程的过程效率较低，客户响应速度较慢</li><li>动态创建的子进程一般只为单一客户提供服务，当客户较多时，系统中会存在大量子进程，进程切换的开销过高</li><li>动态创建的子进程为当前进程的完整映像，当前进程必须谨慎地管理系统资源，以防止子进程不适当地复制这些资源</li></ul></li><li><h3 id="什么是进程池？"><a href="#什么是进程池？" class="headerlink" title="什么是进程池？"></a>什么是进程池？</h3><ul><li>主进程预先创建一组子进程，并统一管理</li><li>子进程运行同样代码，具有同样属性，个数多与CPU数目一致，很少超过CPU数目的两倍</li></ul></li><li><h3 id="进程池的工作原理是什么？"><a href="#进程池的工作原理是什么？" class="headerlink" title="进程池的工作原理是什么？"></a>进程池的工作原理是什么？</h3><ul><li>主进程充当服务器，子进程充当服务员，按照服务器的需要提供服务</li><li>在任务到达时，主进程选择一个子进程进行服务</li><li>相对于动态创建子进程，选择的代价显然更小——这些子进程未来还可以被复用</li><li>存在多种选择子进程的策略，如随机选择或轮值制度，如共享单一任务队列，还可以使用更加智能化的负载平衡技术</li><li>父子进程之间应该具有传递信息的通道，如管道、共享内存、消息队列等，也可能需要同步机制</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程基础</title>
      <link href="2020/02/17/C++/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>2020/02/17/C++/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-程序执行环境"><a href="#一-程序执行环境" class="headerlink" title="一. 程序执行环境"></a>一. 程序执行环境</h1><ol><li><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><ol><li><h4 id="linux命令行规范"><a href="#linux命令行规范" class="headerlink" title="linux命令行规范"></a>linux命令行规范</h4><ul><li>短参数：以单横开头，后跟单一字符，例如ls -h</li><li>长参数：以双横开头，后跟字符串，例如ls –help</li></ul></li><li><h4 id="程序访问参数列表的方法"><a href="#程序访问参数列表的方法" class="headerlink" title="程序访问参数列表的方法"></a>程序访问参数列表的方法</h4><ul><li><p>主函数的参数argc和argv</p></li><li><p>程序接受命令行的输入参数，并解释之</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The program name is &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;With &quot;</span> &lt;&lt; argc - <span class="number">1</span> &lt;&lt; <span class="string">&quot; args as follows:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No args.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./a.out -h --<span class="built_in">help</span></span></span><br><span class="line">The program name is ./a.out.</span><br><span class="line">With 2 args as follows:</span><br><span class="line">-h</span><br><span class="line">--help</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="选项数组的定义"><a href="#选项数组的定义" class="headerlink" title="选项数组的定义"></a>选项数组的定义</h4><ul><li>结构体类型option：系统已定义，直接使用即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件：&quot;getopt.h&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; <span class="comment">// 选项长名称</span></span><br><span class="line">    <span class="keyword">int</span> has_arg;    <span class="comment">// 该参数是否具有附加参数;0无，1有，2可选</span></span><br><span class="line">    <span class="keyword">int</span>* flag; <span class="comment">// 指向整数，用于保存val值，设为0</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">// 选项短名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="函数getopt-long"><a href="#函数getopt-long" class="headerlink" title="函数getopt_long()"></a>函数getopt_long()</h4><ul><li>函数原型：<code>int getopt_long(int argc,char* const* argv,const char* short_options,const struct option* long_options,int* long_index);</code></li><li>函数返回值为参数短名称，不存在时返回-1</li><li>如果为长选项，第五个参数输出该选项在长选项数组中的索引</li></ul></li><li><h4 id="参数处理方法"><a href="#参数处理方法" class="headerlink" title="参数处理方法"></a>参数处理方法</h4><ul><li>使用循环处理所有参数</li><li>如果遇到错误选项，输出错误消息并终止程序执行</li><li>处理附加参数时，用全局变量optarg传递其地址</li><li>完成所有处理后，全局变量optind为首个非可选参数的索引</li></ul></li><li><h4 id="编写程序，接受如下三个选项并执行正确操作"><a href="#编写程序，接受如下三个选项并执行正确操作" class="headerlink" title="编写程序，接受如下三个选项并执行正确操作"></a>编写程序，接受如下三个选项并执行正确操作</h4><ul><li>-h/–help:显示程序用法并退出</li><li>-o filename/–output filename:指定文件名</li><li>-v/–verbose:输出复杂信息<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* program_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputInfo</span><span class="params">(ostream &amp;os, <span class="keyword">int</span> exit_code)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Usage:&quot;</span> &lt;&lt; program_name &lt;&lt; <span class="string">&quot; options [filename]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;-h --help: Display this usage information.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;-o --output filename: Write output to file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;-v --verbose: Print verbose messages.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(exit_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 全部短选项的合并字符串，&quot;:&quot;表示带有附加参数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> short_opts = <span class="string">&quot;ho:v&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_opts</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;output&quot;</span>,<span class="number">1</span>,<span class="literal">NULL</span>,<span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;verbose&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;v&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数指定的输出文件名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* output_filename = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否显示复杂信息</span></span><br><span class="line">    <span class="keyword">int</span> verbose = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存程序名</span></span><br><span class="line">    program_name = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果为长选项，第五个参数输出该选项在长选项数组中的索引</span></span><br><span class="line">    <span class="keyword">int</span> opt = getopt_long(argc,argv,short_opts,long_opts,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(opt != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">// -h 或 --help</span></span><br><span class="line">                OutputInfo(<span class="built_in">cout</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">// 附加参数由optarg提供</span></span><br><span class="line">                output_filename = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                verbose = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:<span class="comment">// 用户输入了无效参数</span></span><br><span class="line">                OutputInfo(<span class="built_in">cerr</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">// 处理完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">abort</span>();<span class="comment">// 终止程序，任何对象的析构函数都不会被调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        opt= getopt_long(argc,argv,short_opts,long_opts,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ol><li><h4 id="典型Linux环境变量"><a href="#典型Linux环境变量" class="headerlink" title="典型Linux环境变量"></a>典型Linux环境变量</h4><ul><li>USER：你的用户名</li><li>HOME：你的主目录</li><li>PATH：分号分割的Linux查找命令的目录列表</li></ul></li><li><h4 id="shell处理"><a href="#shell处理" class="headerlink" title="shell处理"></a>shell处理</h4><ul><li>shell编程时查看环境变量：echo $USER</li><li>设置新的环境变量：<code>EDITOR=emacs;export EDITOR</code>或<code>export EDITOR=emacs</code></li></ul></li><li><h4 id="环境变量内部定义格式：VARIABLE-value"><a href="#环境变量内部定义格式：VARIABLE-value" class="headerlink" title="环境变量内部定义格式：VARIABLE=value"></a>环境变量内部定义格式：VARIABLE=value</h4></li><li><h4 id="使用getenv-函数返回环境变量的值"><a href="#使用getenv-函数返回环境变量的值" class="headerlink" title="使用getenv()函数返回环境变量的值"></a>使用getenv()函数返回环境变量的值</h4></li><li><h4 id="使用全局变量environ处理环境变量"><a href="#使用全局变量environ处理环境变量" class="headerlink" title="使用全局变量environ处理环境变量"></a>使用全局变量environ处理环境变量</h4> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ** var;</span><br><span class="line">    <span class="keyword">for</span>(var = environ; *var != <span class="literal">NULL</span>; var++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="comment">// 列出了本机所有环境变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="编写客户端程序，在用户未指定服务器名时使用缺省服务器名称"><a href="#编写客户端程序，在用户未指定服务器名时使用缺省服务器名称" class="headerlink" title="编写客户端程序，在用户未指定服务器名时使用缺省服务器名称"></a>编写客户端程序，在用户未指定服务器名时使用缺省服务器名称</h4> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * server_name = getenv(<span class="string">&quot;SERVER_NAME&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!server_name) &#123;</span><br><span class="line">        <span class="comment">// SERVER_NAME环境变量未设置，使用缺省值</span></span><br><span class="line">        server_name = (<span class="keyword">char</span>*)<span class="string">&quot;server.yours.com&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;acessing server&quot;</span> &lt;&lt; server_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="程序退出码"><a href="#程序退出码" class="headerlink" title="程序退出码"></a>程序退出码</h3><ol><li><h4 id="程序：结束时传递给操作系统的整型数据"><a href="#程序：结束时传递给操作系统的整型数据" class="headerlink" title="程序：结束时传递给操作系统的整型数据"></a>程序：结束时传递给操作系统的整型数据</h4><ul><li>实际上是main()函数的返回值</li><li>其它函数也可以调用exit()函数返回特定退出码</li><li>退出码的变量名称经常为exit_code</li><li>应仔细设计程序退出码，确保它们能够区分不同错误</li></ul></li><li><h4 id="操作系统：响应程序退出码，如果必要，执行后续处理"><a href="#操作系统：响应程序退出码，如果必要，执行后续处理" class="headerlink" title="操作系统：响应程序退出码，如果必要，执行后续处理"></a>操作系统：响应程序退出码，如果必要，执行后续处理</h4><ul><li>shell编程时查看上一次退出码的命令：echo $?</li></ul></li></ol></li><li><h3 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h3><ol><li><h4 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><ul><li>C程序使用断言，C++程序使用断言或异常处理机制</li></ul></li><li><h4 id="两个主要问题"><a href="#两个主要问题" class="headerlink" title="两个主要问题"></a>两个主要问题</h4><ul><li>系统调用：访问系统资源的手段</li><li>系统调用失败的原因：资源不足；因权限不足而被阻塞；调用参数无效，如无效内存地址或文件描述符；被外部事件中断；不可预计的外部原因</li><li>资源管理：已分配资源必须在任何情况下都能正确释放</li></ul></li><li><h4 id="Linux使用整数表示系统调用错误"><a href="#Linux使用整数表示系统调用错误" class="headerlink" title="Linux使用整数表示系统调用错误"></a>Linux使用整数表示系统调用错误</h4><ul><li>标准错误码为以”E”开头的全大写宏</li><li>宏errno（使用方法类似全局变量）：表示错误码，位于头文件”errno.h”中</li><li>每次错误都重写该值，处理错误时必须保留其副本</li><li>函数strerror()：返回宏errno对应的错误说明字符串，位于头文件”string.h”中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指定文件的拥有者改为指定的用户或组</span></span><br><span class="line"><span class="comment">// 第一个参数为文件名，第二第三个参数分别为用户和组id，-1表示不改变</span></span><br><span class="line">rval = chown(path,user_id,<span class="number">-1</span>)；</span><br><span class="line"><span class="keyword">if</span>(rval) &#123;</span><br><span class="line">    <span class="comment">// 必须存储errno，因为下一次系统调用会修改该值</span></span><br><span class="line">    <span class="keyword">int</span> error_code = errno;</span><br><span class="line">    <span class="comment">// 操作不成功，chown将返回-1</span></span><br><span class="line">    assert(rval == <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 检查errno，对应进行处理</span></span><br><span class="line">    <span class="keyword">switch</span>(error_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> EPERM:<span class="comment">// 操作被否决</span></span><br><span class="line">        <span class="keyword">case</span> EROFS: <span class="comment">// PATH位于只读文件系统中</span></span><br><span class="line">        <span class="keyword">case</span> ENAMETOOLONG:<span class="comment">// 文件名太长</span></span><br><span class="line">        <span class="keyword">case</span> ENOENT:<span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="keyword">case</span> ENOTDIR:<span class="comment">// path的某个成分不是目录</span></span><br><span class="line">        <span class="keyword">case</span> EACCES:<span class="comment">// path的某个成分不可访问</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;error when trying to change the ownership of &quot;</span> &lt;&lt; path;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; strerror(error_code) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">case</span> EFAULT:<span class="comment">// path包含无效内存地址，有可能为bug</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        <span class="keyword">case</span> ENOMEN:<span class="comment">// 核心内存不足</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; strerror(error_code) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">// 不可预见错误，最可能为程序bug</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><ol><li><h4 id="必须予以明确管理的资源类型"><a href="#必须予以明确管理的资源类型" class="headerlink" title="必须予以明确管理的资源类型"></a>必须予以明确管理的资源类型</h4><ul><li>内存、文件描述符、文件指针、临时文件、同步对象等</li></ul></li><li><h4 id="资源管理流程"><a href="#资源管理流程" class="headerlink" title="资源管理流程"></a>资源管理流程</h4><ul><li>步骤1：分配资源</li><li>步骤2：正常处理流程</li><li>步骤3：如果流程失败，释放资源并退出，否则执行正常处理流程</li><li>步骤4：释放资源</li><li>步骤5：函数返回<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ReadFromFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">    <span class="keyword">if</span>(!buffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = open(filename,O_RDONLY);<span class="comment">// 以只读模式打开文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_read = read(fd,buffer,length);</span><br><span class="line">    <span class="keyword">if</span>(bytes_read != length) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = <span class="literal">NULL</span>;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><ol><li><h4 id="日志：系统或程序运行的记录"><a href="#日志：系统或程序运行的记录" class="headerlink" title="日志：系统或程序运行的记录"></a>日志：系统或程序运行的记录</h4></li><li><h4 id="系统日志进程：syslogd-rsyslogd"><a href="#系统日志进程：syslogd-rsyslogd" class="headerlink" title="系统日志进程：syslogd/rsyslogd"></a>系统日志进程：syslogd/rsyslogd</h4><ul><li>两者均为守护进程，即在后台运行的进程，没有控制终端，也不会接收用户输入，父进程通常为init进程</li><li>日志文件一般为”dev/log”，日志信息一般保存在”var/log”目录下</li><li>rsyslogd既能接收用户进程输出的日志，也能接收内核日志；在接收到日志信息后，会输出到特定的日志文件中；日志信息的分发可配置</li></ul></li><li><h4 id="日志生成函数：syslog"><a href="#日志生成函数：syslog" class="headerlink" title="日志生成函数：syslog()"></a>日志生成函数：syslog()</h4><ul><li>头文件：”syslog.h”</li><li>原型：<code>void syslog(int priority,const char* msg,...);</code></li><li>可变参数列表，用于结构化输出</li><li>priority：日志优先级，设施值（一般默认为LOG_USER）与日志级别的位或</li><li>日志级别：LOG_EMERG(0,系统不可用)、LOG_ALERT(1,报警，需立即采取行动)、LOG_GRIT(2,严重情况)、LOG_ERR(3,错误)、LOG_WARNING(4,警告)、LOG_NOTICE(5,通知)、LOG_INFO(6,信息)、LOG_DEBUG(7,调试)</li></ul></li><li><h4 id="日志打开函数：openlog"><a href="#日志打开函数：openlog" class="headerlink" title="日志打开函数：openlog()"></a>日志打开函数：openlog()</h4><ul><li>原型：<code>void openlog(const char * ident, int logopt, int facility);</code></li><li>改变syslog()函数的默认输出方式，以进一步结构化日志内容</li><li>ident：标志项，指定添加到日志消息的日期和时间后的字符串</li><li>logopt：日志选项，用于配置syslog()函数的行为，取值为LOG_PID（在日志消息中包含程序PID）、LOG_CONS（如果日志不能记录至日志文件，则打印到终端）、LOG_ODELAY（延迟打开日志功能，直到第一次调用syslog()函数）、LOG_NDELAY（不延迟打开日志功能）的位或</li><li>facility：用于修改syslog()函数的默认设施值，一般维持LOG_USER不变</li></ul></li><li><h4 id="日志过滤函数：setlogmask"><a href="#日志过滤函数：setlogmask" class="headerlink" title="日志过滤函数：setlogmask()"></a>日志过滤函数：setlogmask()</h4><ul><li>原型：<code>int setlogmask(int maskpri);</code></li><li>设置日志掩码，大于maskpri的日志级别信息被过滤</li><li>返回值：设置日志掩码前的日志掩码旧值</li></ul></li><li><h4 id="日志关闭函数：closelog"><a href="#日志关闭函数：closelog" class="headerlink" title="日志关闭函数：closelog()"></a>日志关闭函数：closelog()</h4><ul><li>原型：<code>void closelog();</code></li></ul></li></ol></li><li><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><ol><li><h4 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h4><ul><li>每个进程拥有两个用户ID：UID（真实用户ID）和EUID（有效用户ID）</li><li>EUID的目的：方便资源访问，运行程序的用户拥有该程序有效用户的权限</li><li>组与用户类似</li></ul></li><li><h4 id="用户信息处理函数"><a href="#用户信息处理函数" class="headerlink" title="用户信息处理函数"></a>用户信息处理函数</h4><ul><li>获取真实用户ID：uid_t getuid();</li><li>获取有效用户ID：uid_t geteuid();</li><li>获取真实组ID：gid_t getgid();</li><li>获取有效组ID：gid_t getegid();</li><li>设置真实用户ID：int setuid(uid_t uid);</li><li>设置有效用户ID：int seteuid(uid_t uid);</li><li>设置真实组ID：int setgid(gid_t gid);</li><li>设置有效组ID：int setegid(gid_t gid);<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">uid_t</span> uid = getuid(),  euid = geteuid();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;uid: %d; euid: %d\n&quot;</span>, uid, euid );<span class="comment">// 1000 1000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h1 id="二-输入输出"><a href="#二-输入输出" class="headerlink" title="二. 输入输出"></a>二. 输入输出</h1><ol><li><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><ol><li><h4 id="标准输入流：stdin-cin"><a href="#标准输入流：stdin-cin" class="headerlink" title="标准输入流：stdin/cin"></a>标准输入流：stdin/cin</h4></li><li><h4 id="标准输出流：stdout-cout"><a href="#标准输出流：stdout-cout" class="headerlink" title="标准输出流：stdout/cout"></a>标准输出流：stdout/cout</h4><ul><li>数据有缓冲，在缓冲区满、程序正常退出、流被关闭或强制刷新（fflush()函数）时输出</li><li>等到缓冲区满后同时打印多个句号：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">10</span>) &#123;</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="标准错误流：stderr-cerr"><a href="#标准错误流：stderr-cerr" class="headerlink" title="标准错误流：stderr/cerr"></a>标准错误流：stderr/cerr</h4><ul><li>数据无缓冲，直接输出</li><li>每秒打印一个句号：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ol><li><h4 id="文件描述符的意义与目的：在程序中代表文件"><a href="#文件描述符的意义与目的：在程序中代表文件" class="headerlink" title="文件描述符的意义与目的：在程序中代表文件"></a>文件描述符的意义与目的：在程序中代表文件</h4><ul><li>内核为每个进程维护一个文件打开记录表，文件描述符为该文件在表中的索引值</li></ul></li><li><h4 id="文件描述符为非负整数，范围从0至OPEN-MAX"><a href="#文件描述符为非负整数，范围从0至OPEN-MAX" class="headerlink" title="文件描述符为非负整数，范围从0至OPEN_MAX"></a>文件描述符为非负整数，范围从0至OPEN_MAX</h4><ul><li>不同操作系统可能具有不同范围，可以同时打开的文件数目不同</li></ul></li><li><h4 id="文件描述符的缺点"><a href="#文件描述符的缺点" class="headerlink" title="文件描述符的缺点"></a>文件描述符的缺点</h4><ul><li>非UNIX/Linux操作系统可能没有文件描述符概念，跨平台编程时建议使用C/C++标准库函数和文件流类</li></ul></li><li><h4 id="预定义的标准输入输出流的文件描述符"><a href="#预定义的标准输入输出流的文件描述符" class="headerlink" title="预定义的标准输入输出流的文件描述符"></a>预定义的标准输入输出流的文件描述符</h4><ul><li>标准输入流stdin：STDIN_FILENO（0）</li><li>标准输出流stdout：STDOUT_FILENO（1）</li><li>标准错误流stderr：STDERR_FILENO（2）</li></ul></li><li><h4 id="文件描述符的创建"><a href="#文件描述符的创建" class="headerlink" title="文件描述符的创建"></a>文件描述符的创建</h4><ul><li>Linux中凡物皆文件，操作系统使用统一方式管理和维护</li><li>很多函数都可通过打开文件或设备的方式创建文件描述符</li></ul></li></ol></li><li><h3 id="I-O函数"><a href="#I-O函数" class="headerlink" title="I/O函数"></a>I/O函数</h3><ol><li><h4 id="基本与高级I-O函数"><a href="#基本与高级I-O函数" class="headerlink" title="基本与高级I/O函数"></a>基本与高级I/O函数</h4><ul><li>打开关闭函数open()和close()：前者头文件“fcntl.h”，后者头文件“unistd.h”</li><li>读写函数read()和write()：头文件“unistd.h”</li><li>读写函数readv()和writev()：头文件“sys/uio.h”</li><li>文件发送函数sendfile()：头文件“sys/sendfile.h”</li><li>数据移动函数splice()：头文件“fcntl.h”</li><li>数据移动函数tee()：头文件“fcntl.h”</li><li>文件控制函数fcntl()：头文件“fcntl.h”</li></ul></li><li><h4 id="打开文件函数open"><a href="#打开文件函数open" class="headerlink" title="打开文件函数open()"></a>打开文件函数open()</h4><ul><li>原型：<code>int open(const char * filename, int oflag, …);</code></li><li>目的：打开filename指定的文件，返回其文件描述符，oflag为文件打开标志</li><li>若文件支持定位，读取时从当前文件偏移量处开始</li><li>文件打开标志：O_RDONLY（只读）、 O_WRONLY（只写）、 O_RDWR（读写）等</li></ul></li><li><h4 id="关闭文件函数close"><a href="#关闭文件函数close" class="headerlink" title="关闭文件函数close()"></a>关闭文件函数close()</h4><ul><li>原型：<code>int close(int fd);</code></li><li>目的：关闭文件描述符fd所代表的文件</li></ul></li><li><h4 id="读函数read"><a href="#读函数read" class="headerlink" title="读函数read()"></a>读函数read()</h4><ul><li>原型：<code>ssize_t read(int fd, void * buf, size_t count);</code></li><li>目的：将count个字节的数据从文件描述符fd所代表的文件中读入buf所指向的缓冲区</li><li>若文件支持定位，读取时从当前文件偏移量处开始</li><li>返回值：读取的字节数，0表示文件结尾，失败时返回-1并设置errno</li></ul></li><li><h4 id="写函数write"><a href="#写函数write" class="headerlink" title="写函数write()"></a>写函数write()</h4><ul><li>原型：<code>ssize_t write(int fd, const void * buf, size_t count);</code></li><li>目的：将count个字节的数据从buf所指向的缓冲区写入文件描述符fd所代表的文件中</li><li>参数与返回值的意义与read()相同或类似</li></ul></li><li><h4 id="分散读函数readv"><a href="#分散读函数readv" class="headerlink" title="分散读函数readv()"></a>分散读函数readv()</h4><ul><li>原型：<code>ssize_t readv(int fd, const struct iovec * iov, int iovcnt);</code></li><li>目的：将数据从文件描述符所代表的文件中读到分散的内存块中</li><li>参数：fd为文件描述符；iov为写入的内存块结构体数组，每个数组元素只有内存基地址iov_base和内存块长度iov_len两个字段；iovcnt为读取的元素个数</li><li>返回值：读取的内存块数，失败时返回-1并设置errno</li></ul></li><li><h4 id="集中写函数writev"><a href="#集中写函数writev" class="headerlink" title="集中写函数writev()"></a>集中写函数writev()</h4><ul><li>原型：<code>ssize_t writev(int fd, const struct iovec * iov, int iovcnt);</code></li><li>目的：将数据从分散的内存块中写入文件描述符所代表的文件中</li><li>参数与返回值的意义与readv()相同或类似</li></ul></li><li><h4 id="文件发送函数sendfile"><a href="#文件发送函数sendfile" class="headerlink" title="文件发送函数sendfile()"></a>文件发送函数sendfile()</h4><ul><li>原型：<code>ssize_t sendfile(int out_fd, int in_fd, off_t * offset, int count);</code></li><li>目的：在两个文件描述符所代表的文件间直接传递数据，以避免内核缓冲区和用户缓冲区之间的数据拷贝，提升程序效率；为网络文件传输而专门设计的函数</li><li>参数：out_fd为目的文件描述符；in_fd为源文件描述符；offset指定读取时的偏移量，为NULL表示从默认位置开始读取；count为传输的字节数</li><li>返回值：传输的字节数，失败时返回-1并设置errno</li><li>注意事项：in_fd必须为支持类似mmap()函数的文件描述符，即必须代表真实的文件，不能为套接字和管道；out_fd必须为套接字</li></ul></li><li><h4 id="数据移动函数splice"><a href="#数据移动函数splice" class="headerlink" title="数据移动函数splice()"></a>数据移动函数splice()</h4><ul><li>原型：<code>ssize_t splice(int fd_in, loff_t * off_in, int fd_out, loff_t * off_out, ssize_t len, unsigned int flags);</code></li><li>目的：在两个文件描述符所代表的文件间移动数据</li><li>参数：fd_in为源文件描述符；off_in为输入数据偏移量，若fd_in为管道，则off_in必须设置为NULL；fd_out与off_out的意义类似；len为传输的字节数；flags控制数据如何移动，其取值为SPLICE_F_MOVE（新内核无效果）、SPLICE_F_NONBLOCK（非阻塞）、SPLICE_F_MORE（还有后续数据）和SPLICE_F_GIFT（无效果）的位或</li><li>返回值：传输的字节数，0表示无数据移动，失败时返回-1并设置errno</li><li>注意事项：fd_in和fd_out必须至少有一个为管道文件描述符</li></ul></li><li><h4 id="数据移动函数tee"><a href="#数据移动函数tee" class="headerlink" title="数据移动函数tee()"></a>数据移动函数tee()</h4><ul><li>原型：<code>ssize_t tee(int fd_in, int fd_out, ssize_t len, unsigned int flags);</code></li><li>目的：在两个文件描述符所代表的管道间移动数据</li><li>参数：含义与splice()相同</li><li>返回值：传输的字节数，0表示无数据移动，失败时返回-1并设置errno</li><li>注意事项：fd_in和fd_out必须为管道文件描述符</li></ul></li><li><h4 id="文件控制函数fcntl"><a href="#文件控制函数fcntl" class="headerlink" title="文件控制函数fcntl()"></a>文件控制函数fcntl()</h4><ul><li>原型：<code>int fcntl(int fd, int cmd, …);</code></li><li>目的：对文件描述符所代表的文件或设备进行控制操作</li><li>参数： fd为文件描述符；cmd为控制命令</li><li>返回值：失败时返回-1并设置errno</li><li>常用操作（cmd）<ul><li>复制文件描述符：F_DUPFD/F_DUPFD_CLOEXEC，第三个参数型式long，成功时返回新创建的文件描述符</li><li>获取或设置文件描述符的标志：F_GETFD/F_SETFD，第三个参数前者无，后者型式long，成功时前者返回fd的标志，后者0</li><li>获取或设置文件描述符状态标志：F_GETFL/F_SETFL，第三个参数前者无，后者型式long，成功时前者返回fd的状态标志，后者0</li><li>获取或设置SIGIO和SIGURG信号的宿主进程PID或进程组的GID： F_GETOWN/F_SETOWN，第三个参数前者无，后者型式long，成功时前者返回信号的宿主进程的PID或进程组的GID，后者0</li><li>获取或设置信号：F_GETSIG/F_SETSIG，第三个参数前者无，后者型式long，成功时前者返回信号值，0表示SIGIO，后者0</li><li>获取或设置管道容量：F_GETPIPE_SZ/F_SETPIPE_SZ，第三个参数前者无，后者型式long，成功时前者返回管道容量，后者0</li></ul></li></ul></li></ol></li><li><h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><ol><li><h4 id="使用临时文件时的注意事项"><a href="#使用临时文件时的注意事项" class="headerlink" title="使用临时文件时的注意事项"></a>使用临时文件时的注意事项</h4><ul><li>程序多个进程可能同时运行，它们可能应该使用不同的临时文件</li><li>必须小心设置文件属性，未授权用户不应具有临时文件访问权限</li><li>临时文件的生成应该外部不可预测，否则系统容易受到攻击</li></ul></li><li><h4 id="Linux临时文件函数mkstemp"><a href="#Linux临时文件函数mkstemp" class="headerlink" title="Linux临时文件函数mkstemp()"></a>Linux临时文件函数mkstemp()</h4><ul><li>创建名称唯一的临时文件，使用“XXXXXX”作为模板，返回文件描述符</li><li>如果不希望外界看到临时文件，创建临时文件后应调用unlink()函数将其从目录项中删除，但文件本身仍存在</li><li>文件采用引用计数方式访问；本程序未结束，可用文件描述符访问该文件；文件引用计数降为0，系统自动删除临时文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  向临时文件中写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">WriteToTempFile</span><span class="params">( <span class="keyword">char</span> * buffer, <span class="keyword">size_t</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  创建临时文件，“XXXXXX”将在生成时被替换，以保证文件名唯一性</span></span><br><span class="line"><span class="keyword">char</span> temp_filename[] = <span class="string">&quot;/tmp/temp_file.XXXXXX&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> fd = mkstemp( temp_filename );</span><br><span class="line"><span class="comment">//  取消文件链接，不显示该临时文件；关闭文件描述符后，临时文件被删除</span></span><br><span class="line">unlink( temp_filename );</span><br><span class="line"><span class="comment">//  向临时文件中写入数据</span></span><br><span class="line">write( fd, &amp;length, <span class="keyword">sizeof</span>(length) );</span><br><span class="line">write( fd, buffer, length );</span><br><span class="line"><span class="comment">//  返回临时文件的文件描述符</span></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  从临时文件中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">ReadFromTempFile</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">size_t</span> * length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  定位到文件开头</span></span><br><span class="line">lseek( fd, <span class="number">0</span>, SEEK_SET );</span><br><span class="line"><span class="comment">//  读取数据</span></span><br><span class="line">read( fd, length, <span class="keyword">sizeof</span>(*length) );</span><br><span class="line"><span class="keyword">char</span> * buffer = <span class="keyword">new</span> <span class="keyword">char</span>[*length];</span><br><span class="line">read( fd, buffer, *length );</span><br><span class="line"><span class="comment">//  关闭文件描述符，临时文件将被删除</span></span><br><span class="line">close( fd );</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h1 id="三-文件系统"><a href="#三-文件系统" class="headerlink" title="三. 文件系统"></a>三. 文件系统</h1><ol><li><h3 id="实际文件系统：组成与功能描述"><a href="#实际文件系统：组成与功能描述" class="headerlink" title="实际文件系统：组成与功能描述"></a>实际文件系统：组成与功能描述</h3><ul><li>ext、ext2、ext3、ext4</li><li>引导块：在文件系统开头，通常为一个扇区，存放引导程序，用于读入并启动操作系统</li><li>超级块：用于记录文件系统的管理信息，不同的文件系统拥有不同的超级块</li><li>索引结点区：一个文件或目录占据一个索引结点，首索引结点为该文件系统的根结点，可以利用根结点将一个文件系统挂在另一个文件系统的非叶结点上</li><li>数据区：用于存放文件数据或者管理数据</li></ul></li><li><h3 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h3><ul><li>VFS的特点：只存于内存中，充当实际文件系统与操作系统之间的接口，提供实际文件系统的挂载，并管理实际文件系统</li><li>VFS的构造：系统初始化时构造VFS目录树，建立其数据结构；每个实际文件系统使用struct file_system_type结构存储为结点，并形成链表</li><li>VFS的意义与目的： 支持多种不同的文件系统，内核以一致的方式处理这些文件系统，从而对用户透明</li></ul></li><li><h3 id="特殊文件系统-proc"><a href="#特殊文件系统-proc" class="headerlink" title="特殊文件系统/proc"></a>特殊文件系统/proc</h3><ul><li>从/proc文件系统中抽取信息</li><li>Linux内核的窗口，只存于内存中，并不占用磁盘空间</li><li>典型信息<ul><li>进程信息：进程项、进程参数列表、进程环境、进程可执行文件、进程文件描述符、进程内存统计信息等</li><li>硬件信息：CPU信息、设备信息、PCI总线信息、串口信息等</li><li>内核信息：版本信息、主机名与域名信息、内存使用等</li><li>设备、挂载点与文件系统</li></ul></li></ul></li></ol><h1 id="四-设备"><a href="#四-设备" class="headerlink" title="四. 设备"></a>四. 设备</h1><ol><li><h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3><ol><li><h4 id="设备文件的性质"><a href="#设备文件的性质" class="headerlink" title="设备文件的性质"></a>设备文件的性质</h4><ul><li>设备文件不是普通的磁盘文件</li><li>读写设备的数据需要与相应的设备驱动器通信</li></ul></li><li><h3 id="设备文件的类型"><a href="#设备文件的类型" class="headerlink" title="设备文件的类型"></a>设备文件的类型</h3><ul><li>字符设备：读写串行数据字节流，如串口、终端等</li><li>块设备：随机读写固定尺寸数据块，如磁盘设备</li></ul></li><li><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>磁盘挂载到文件系统后，使用文件和目录模式操作</li><li>程序一般不用块设备，内核实现文件系统时使用块设备操作文件</li></ul></li></ol></li><li><h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><ol><li><h4 id="大设备号（major-device-number）"><a href="#大设备号（major-device-number）" class="headerlink" title="大设备号（major device number）"></a>大设备号（major device number）</h4><ul><li>指定设备对应哪个设备驱动器</li><li>对应关系由内核确定</li></ul></li><li><h4 id="小设备号（-minor-device-number-）"><a href="#小设备号（-minor-device-number-）" class="headerlink" title="小设备号（ minor device number ）"></a>小设备号（ minor device number ）</h4><ul><li>区分由设备驱动器控制的单个设备或设备的某个组件</li></ul></li><li><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>3号主设备为IDE控制器，IDE控制器可以连接多个设备（磁盘、磁带、CD-DVD驱动器等）</li><li>主设备的小设备号为0，而从设备的小设备号为64</li><li>主设备单独分区的小设备号从0至63，从设备单独分区的小设备号从64开始</li></ul></li></ol></li><li><h3 id="设备项"><a href="#设备项" class="headerlink" title="设备项"></a>设备项</h3><ol><li><h4 id="设备项：与文件类似"><a href="#设备项：与文件类似" class="headerlink" title="设备项：与文件类似"></a>设备项：与文件类似</h4><ul><li>可以使用mv、rm命令移动或删除</li><li>如果设备支持读写，cp命令可以从（向）设备读取（写入）数据</li></ul></li><li><h4 id="mknod系统调用：创建设备项（文件系统结点）"><a href="#mknod系统调用：创建设备项（文件系统结点）" class="headerlink" title="mknod系统调用：创建设备项（文件系统结点）"></a>mknod系统调用：创建设备项（文件系统结点）</h4><ul><li>原型：int mknod( const char * pathname, mode_t mode, dev_t dev );</li><li>参数：pathname为设备项包含路径的名称；mode为设备的使用权限与结点类型；当文件类型为S_IFCHR或S_IFBLK时，dev表示设备的大小设备号，否则忽略</li><li>设备项仅仅是与设备通信的门户，在文件系统中创建设备项并不意味着设备可用</li><li>只有超级用户才可以创建设备项</li></ul></li></ol></li><li><h3 id="设备目录"><a href="#设备目录" class="headerlink" title="设备目录"></a>设备目录</h3><ol><li><h4 id="操作系统已知的设备目录：-dev"><a href="#操作系统已知的设备目录：-dev" class="headerlink" title="操作系统已知的设备目录：/dev"></a>操作系统已知的设备目录：/dev</h4></li><li><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul><li>硬盘hda为块设备</li><li>硬盘有一个分区hda1</li></ul></li></ol></li><li><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><table><thead><tr><th align="center">设备描述</th><th align="center">设备名称</th><th align="center">大设备号</th><th align="center">小设备号</th></tr></thead><tbody><tr><td align="center">第一软驱</td><td align="center">/dev/fd0</td><td align="center">2</td><td align="center">0</td></tr><tr><td align="center">第二软驱</td><td align="center">/dev/fd1</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">主IDE控制器，主设备</td><td align="center">/dev/hda</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">主IDE控制器，主设备，第一分区</td><td align="center">/dev/hda1</td><td align="center">3</td><td align="center">1</td></tr><tr><td align="center">主IDE控制器，从设备</td><td align="center">/dev/hdb</td><td align="center">3</td><td align="center">64</td></tr><tr><td align="center">主IDE控制器，从设备，第一分区</td><td align="center">/dev/hdb1</td><td align="center">3</td><td align="center">65</td></tr><tr><td align="center">次IDE控制器，主设备</td><td align="center">/dev/hdc</td><td align="center">22</td><td align="center">0</td></tr><tr><td align="center">次IDE控制器，从设备</td><td align="center">/edv/hdd</td><td align="center">22</td><td align="center">64</td></tr><tr><td align="center">第一SCSI设备</td><td align="center">/dev/sda</td><td align="center">8</td><td align="center">0</td></tr><tr><td align="center">第一SCSI设备，第一分区</td><td align="center">/dev/sda1</td><td align="center">8</td><td align="center">1</td></tr><tr><td align="center">第一SCSI CD－ROM驱动器</td><td align="center">/dev/scd0</td><td align="center">11</td><td align="center">0</td></tr><tr><td align="center">第二SCSI CD－ROM驱动器</td><td align="center">/dev/scd1</td><td align="center">11</td><td align="center">1</td></tr><tr><td align="center">并口0</td><td align="center">/dev/lp0或/dev/par0</td><td align="center">6</td><td align="center">0</td></tr><tr><td align="center">并口1</td><td align="center">/dev/lp1或/dev/par1</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="center">第一串口</td><td align="center">/dev/ttyS0</td><td align="center">4</td><td align="center">64</td></tr><tr><td align="center">第二串口</td><td align="center">/dev/ttyS1</td><td align="center">4</td><td align="center">65</td></tr><tr><td align="center">IDE磁带设备</td><td align="center">/dev/ht0</td><td align="center">37</td><td align="center">0</td></tr><tr><td align="center">第一SCSI磁带设备</td><td align="center">/dev/st0</td><td align="center">9</td><td align="center">0</td></tr><tr><td align="center">第二SCSI磁带设备</td><td align="center">/dev/st1</td><td align="center">9</td><td align="center">1</td></tr><tr><td align="center">系统控制台</td><td align="center">/dev/console</td><td align="center">5</td><td align="center">1</td></tr><tr><td align="center">第一虚拟终端设备</td><td align="center">/edv/tty1</td><td align="center">4</td><td align="center">1</td></tr><tr><td align="center">第二虚拟终端设备</td><td align="center">/dev/tty2</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">进程当前终端设备</td><td align="center">/dev/tty</td><td align="center">5</td><td align="center">0</td></tr><tr><td align="center">声卡</td><td align="center">/dev/audio</td><td align="center">14</td><td align="center">5</td></tr></tbody></table></li><li><h3 id="特殊设备"><a href="#特殊设备" class="headerlink" title="特殊设备"></a>特殊设备</h3><ol><li><h4 id="dev-null：哑设备"><a href="#dev-null：哑设备" class="headerlink" title="/dev/null：哑设备"></a>/dev/null：哑设备</h4><ul><li>任何写入哑设备的数据被抛弃</li><li>从哑设备读取不到任何数据，例如cp /dev/null empty-file命令将创建一个长度为0的空文件</li></ul></li><li><h4 id="dev-zero：零设备"><a href="#dev-zero：零设备" class="headerlink" title="/dev/zero：零设备"></a>/dev/zero：零设备</h4><ul><li>行为类似文件，长度无限，但内容全部为0</li></ul></li><li><h4 id="dev-full：满设备"><a href="#dev-full：满设备" class="headerlink" title="/dev/full：满设备"></a>/dev/full：满设备</h4><ul><li>行为类似文件，没有空闲空间存储任何数据</li><li>对满设备的写入总是失败，并将errno设为ENOSPC</li></ul></li><li><h4 id="dev-random和-dev-urandom：随机数设备"><a href="#dev-random和-dev-urandom：随机数设备" class="headerlink" title="/dev/random和/dev/urandom：随机数设备"></a>/dev/random和/dev/urandom：随机数设备</h4><ul><li>C语言的rand()函数生成伪随机数</li><li>随机数设备原理<ul><li>人的行为无法预测，因而是随机的</li><li>Linux内核测量用户的输入活动（如键盘输入和鼠标操作）的时间延迟作为随机数</li></ul></li><li>两者区别<ul><li>/dev/random：在用户没有输入操作时，阻塞随机数读取进程（没有数据可读取）</li><li>/dev/urandom：永不阻塞；在用户没有输入操作时，生成伪随机数代替</li></ul></li></ul></li></ol></li><li><h3 id="设备控制与访问"><a href="#设备控制与访问" class="headerlink" title="设备控制与访问"></a>设备控制与访问</h3><ol><li><h4 id="设备访问"><a href="#设备访问" class="headerlink" title="设备访问"></a>设备访问</h4><ul><li>像文件一样操作设备</li><li>示例：向并口设备发送数据<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/lp0&quot;</span>, O_WRONLY);</span><br><span class="line">write(fd, buffer, buffer_length);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="控制硬件设备的函数：ioctl"><a href="#控制硬件设备的函数：ioctl" class="headerlink" title="控制硬件设备的函数：ioctl()"></a>控制硬件设备的函数：ioctl()</h4><ul><li>第一个参数为文件描述符，指定想要控制的设备；第二个参数为控制命令码，指定想要实施的操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdrom.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDONLY);<span class="comment">//  打开参数所表示的设备</span></span><br><span class="line">    ioctl(fd, CDROMEJECT);<span class="comment">//  弹出CD-ROM</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h1 id="五-库"><a href="#五-库" class="headerlink" title="五. 库"></a>五. 库</h1><ol><li><h3 id="静态库（Archives）"><a href="#静态库（Archives）" class="headerlink" title="静态库（Archives）"></a>静态库（Archives）</h3><ul><li>后缀一般为“*.a”</li><li>使用两个目标文件创建单一静态库的编译与链接命令：ar cr libtest.a test1.o test2.o</li><li>链接器搜索静态库时，链接所有已引用而未处理的符号</li><li>将静态库的链接放置在命令行尾部，确保其引用被正确解析</li></ul></li><li><h3 id="动态库（Shared-Object）"><a href="#动态库（Shared-Object）" class="headerlink" title="动态库（Shared Object）"></a>动态库（Shared Object）</h3><ul><li>共享目标库（类似Windows的DLL），后缀一般为“*.so”</li><li>编译命令：g++ -shared -fPIC -o libtest.so test1.o test2.o</li><li>PIC：位置无关代码（Position-Independent Code）</li><li>编译器首先链接动态库，其次才是静态库</li><li>如果要强制链接静态库，编译使用-static选项</li></ul></li><li><h3 id="C标准库：libc"><a href="#C标准库：libc" class="headerlink" title="C标准库：libc"></a>C标准库：libc</h3><ul><li>数学库单独：libm；需要调用数学函数时，显式链接数学库：<code>g++ -o compute compute.c –lm</code></li></ul></li><li><h3 id="C-标准库：libstdc"><a href="#C-标准库：libstdc" class="headerlink" title="C++标准库：libstdc++"></a>C++标准库：libstdc++</h3><ul><li>编译C++11程序，使用g++-4.8 -std=c++11；对于Code::Blocks等集成开发环境，在编译器设置对话框中选中相应的C++11选项</li></ul></li><li><h3 id="库的相关性"><a href="#库的相关性" class="headerlink" title="库的相关性"></a>库的相关性</h3><ul><li>链接时需要注意交叉引用被正确解析，例如：libtiff库需要libjpeg库（jpeg图像处理）和libz库（压缩处理）</li><li>独立库链接： g++ -static -o tifftest tifftest.c -ltiff -ljpeg –lz</li><li>相关库链接： g++ -o app app.o -la -lb -la (a需要b，b又需要a)</li></ul></li><li><h3 id="动态库装载函数dlopen-：头文件“dlfcn-h”"><a href="#动态库装载函数dlopen-：头文件“dlfcn-h”" class="headerlink" title="动态库装载函数dlopen()：头文件“dlfcn.h”"></a>动态库装载函数dlopen()：头文件“dlfcn.h”</h3><ul><li>原型：<code>void * dlopen(const char * filename, int flag);</code></li><li>参数：filename为动态库名称；flag为装载模式，必须为RTLD_LAZY或RTLD_NOW两者之一，并可与其他装载标识（如RTLD_GLOBAL、RTLD_LOCAL）组合</li><li>返回值：类型为void *，用以表示动态库句柄；调用失败返回NULL</li><li>示例：<code>dlopen(&quot;libtest.so&quot;, RTLD_LAZY);</code></li></ul></li><li><h3 id="函数查找与装载函数dlsym"><a href="#函数查找与装载函数dlsym" class="headerlink" title="函数查找与装载函数dlsym()"></a>函数查找与装载函数dlsym()</h3><ul><li>原型：<code>void * dlsym(void * handle, const char * symbol);</code></li><li>参数：handle为动态库句柄；symbol为函数名称字符串</li><li>返回值：目标函数装载在内存中的基地址</li></ul></li><li><h3 id="动态库卸载函数dlclose"><a href="#动态库卸载函数dlclose" class="headerlink" title="动态库卸载函数dlclose()"></a>动态库卸载函数dlclose()</h3><ul><li>原型：<code>int dlclose(void * handle);</code></li><li>参数：handle为动态库句柄</li><li>返回值：成功时为0，其他为错误</li></ul></li><li><h3 id="动态库错误处理函数dlerror"><a href="#动态库错误处理函数dlerror" class="headerlink" title="动态库错误处理函数dlerror()"></a>动态库错误处理函数dlerror()</h3><ul><li>原型：<code>char * dlerror();</code></li><li>返回值：其他三个函数调用时最后一次产生的错误描述字符串</li></ul></li><li><h3 id="调用动态库中的函数，设函数名为g"><a href="#调用动态库中的函数，设函数名为g" class="headerlink" title="调用动态库中的函数，设函数名为g"></a>调用动态库中的函数，设函数名为g</h3><ul><li>混合C/C++编码时，C函数应封装于extern “C” { … } 块中，确保名解析正确工作（C不支持函数重载）</li><li>链接选项：“-ldl”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * handle = dlopen(<span class="string">&quot;libtest.so&quot;</span>, RTLD_LAZY);</span><br><span class="line"><span class="comment">//  声明函数指针指向动态库中的函数，按被调函数的名称查找</span></span><br><span class="line"><span class="keyword">void</span> (*test)() = dlsym(handle, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">(*test)();    <span class="comment">//  使用函数指针调用动态库中的函数</span></span><br><span class="line">dlclose(handle);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="六-makefile文件"><a href="#六-makefile文件" class="headerlink" title="六. makefile文件"></a>六. makefile文件</h1><ol><li><h3 id="make命令：负责C-C-程序编译与链接"><a href="#make命令：负责C-C-程序编译与链接" class="headerlink" title="make命令：负责C/C++程序编译与链接"></a>make命令：负责C/C++程序编译与链接</h3><ul><li>make根据指定命令进行建构</li><li>建构规则文件：GNUmakefile、makefile、Makefile</li></ul></li><li><h3 id="makefile文件格式"><a href="#makefile文件格式" class="headerlink" title="makefile文件格式"></a>makefile文件格式</h3><ol><li><h4 id="makefile文件基本格式"><a href="#makefile文件基本格式" class="headerlink" title="makefile文件基本格式"></a>makefile文件基本格式</h4><ul><li>target … : prerequisites …</li><li>[Tab键]    commands</li></ul></li><li><h4 id="makefile文件规则"><a href="#makefile文件规则" class="headerlink" title="makefile文件规则"></a>makefile文件规则</h4><ul><li>makefile文件由一系列规则构成</li><li>规则的目的：建构目标的先决条件是什么以及如何建构目标</li><li>如果未指定目标，缺省执行第一个目标</li><li>若prerequisites中有一个以上的文件比target文件要新，执行commands所定义的命令</li></ul></li><li><h4 id="target：目标"><a href="#target：目标" class="headerlink" title="target：目标"></a>target：目标</h4><ul><li>通常为编译期的文件名，以指定要建构的对象，也可以是执行文件，还可以是标签（操作名称，伪目标）</li><li>可以为单一目标，也可以为空格分隔的多个目标</li><li>每个目标都定义了一组处理规则，和其相关规则构成规则链</li></ul></li><li><h4 id="prerequisites：先决条件"><a href="#prerequisites：先决条件" class="headerlink" title="prerequisites：先决条件"></a>prerequisites：先决条件</h4><ul><li>为生成该目标所需的先决文件或目标（前置条件）</li><li>一般为空格分隔的文件名，指定目标是否重建的判断标准，即只要有一个先决文件不存在或有过更新，就重建目标</li><li>若目标先决条件本身需要重建，则匹配该先决条件的目标，执行其对应的命令</li></ul></li><li><h4 id="commands：命令"><a href="#commands：命令" class="headerlink" title="commands：命令"></a>commands：命令</h4><ul><li>由一行或多行shell命令组成，命令前有Tab键</li><li>指示如何建构目标，一般为生成目标文件</li><li>每行命令都在单独的进程中执行，彼此没有继承关系，不能简单传递数据；解决办法：用分号将多条命令书写在单行（此时可用“\”折行），或者为该条规则添加指示“.ONESHELL :”</li></ul></li><li><h4 id="伪目标：操作名称，而不是文件名"><a href="#伪目标：操作名称，而不是文件名" class="headerlink" title="伪目标：操作名称，而不是文件名"></a>伪目标：操作名称，而不是文件名</h4><ul><li>删除编译后的二进制目标文件，例如：  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean :</span><br><span class="line">    rm -f *.o</span><br></pre></td></tr></table></figure></li><li>执行命令时须指定伪目标：$ make clean</li><li>若当前目录下有clean文件，则此规则不会被执行；此时可用“.PHONY : clean”明确指示clean为伪目标；make将跳过文件检查，执行其对应的命令</li><li>执行清除任务的伪目标一般放置在脚本的最后</li></ul></li><li><h4 id="伪目标惯例"><a href="#伪目标惯例" class="headerlink" title="伪目标惯例"></a>伪目标惯例</h4><ul><li>all：所有目标的目标，一般为编译所有的目标，对同时编译多个程序极为有用</li><li>clean：删除由make创建的文件</li><li>install：安装已编译好的程序，主要任务是完成目标执行文件的拷贝</li><li>print：列出改变过的源文件</li><li>tar：打包备份源程序，形成tar文件</li><li>dist：创建压缩文件，一般将tar文件压缩成Z文件或gz文件</li><li>TAGS：更新所有的目标，以备完整地重编译使用</li><li>check和test：一般用来测试makefile的流程</li></ul></li><li><h4 id="示例：假设程序主文件“main-c”，使用library库"><a href="#示例：假设程序主文件“main-c”，使用library库" class="headerlink" title="示例：假设程序主文件“main.c”，使用library库"></a>示例：假设程序主文件“main.c”，使用library库</h4> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  注释行 这里的cc在我本机指向的是gcc ls -l /usr/bin/cc</span></span><br><span class="line">prog : main.o library.o</span><br><span class="line">    cc -o prog main.o library.o</span><br><span class="line">main.o : main.c library.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">library.o : library.c library.h</span><br><span class="line">    cc -c library.c</span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm main.o library.o</span><br></pre></td></tr></table></figure></li></ol></li><li><h3 id="makefile语法"><a href="#makefile语法" class="headerlink" title="makefile语法"></a>makefile语法</h3><ol><li><h4 id="行解析：命令按行解析"><a href="#行解析：命令按行解析" class="headerlink" title="行解析：命令按行解析"></a>行解析：命令按行解析</h4><ul><li>命令行的行首字符为Tab键，其他行的行首字符不得为Tab键，但可以使用多个空格缩进</li></ul></li><li><h4 id="换行：命令太长时，行尾用“-”换行"><a href="#换行：命令太长时，行尾用“-”换行" class="headerlink" title="换行：命令太长时，行尾用“\”换行"></a>换行：命令太长时，行尾用“\”换行</h4></li><li><h4 id="注释：行首字符为“-”的文本行"><a href="#注释：行首字符为“-”的文本行" class="headerlink" title="注释：行首字符为“#”的文本行"></a>注释：行首字符为“#”的文本行</h4></li><li><h4 id="关闭回显：在行首字符后和命令前添加“-”"><a href="#关闭回显：在行首字符后和命令前添加“-”" class="headerlink" title="关闭回显：在行首字符后和命令前添加“@”"></a>关闭回显：在行首字符后和命令前添加“@”</h4><ul><li>未关闭回显时，make会首先回显（打印）命令，然后执行该命令</li><li>通常仅在注释和纯显示的echo命令前使用此功能</li></ul></li><li><h4 id="include-filename：包含其他文件"><a href="#include-filename：包含其他文件" class="headerlink" title="include filename：包含其他文件"></a>include filename：包含其他文件</h4><ul><li>处理模式与C/C++类似</li><li>行首加“-”：忽略文件包含错误</li></ul></li><li><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul><li>“<em>”（任意数目的任意字符），例如“</em>.c”表示所有C源文件</li><li>“？”（任意一个字符），例如“?.c”表示所有单字符文件名的C源文件</li><li>“[abc]”（存在括号内的某个字符），例如“lib[abc].c”表示第四个字符为“a”、“b”或“c”</li><li>“[0-9]”（存在该集合中的某个字符），例如“lib[0-9].c”表示第四个字符为0～9之间的数字（含数字0和9）</li><li>“[^abc]”（存在非括号内的某个字符），例如“lib[^abc].c”表示第四个字符不是“a”、“b”或“c”</li></ul></li><li><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>基本变量定义： var_name = value</li><li>$(变量名称)：引用变量（中间无多余空格）；shell变量用“$$”，例如“@echo $$HOME”</li><li>变量在使用时展开，形式上类似宏替换</li><li>变量的使用场合：目标、先决条件、命令、新的变量</li></ul></li><li><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><ul><li>$(CC)：当前使用的编译器；$(MAKE)：当前使用的make工具</li></ul></li><li><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul><li>$@：当前目标；$&lt;：当前目标的首个先决条件；$?：比目标更新的所有先决条件；$^：所有先决条件；$(@D)和$(@F)：$@的目录名和文件名；$(&lt;D)和$(&lt;F)：$&lt;的目录名和文件名</li></ul></li><li><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  makefile样本</span></span><br><span class="line">objs = main.o library.o</span><br><span class="line"></span><br><span class="line">prog : <span class="variable">$(objs)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o prog <span class="variable">$(objs)</span></span><br><span class="line">    @echo <span class="string">&quot;Constructed…&quot;</span></span><br><span class="line">main.o : main.c library.h</span><br><span class="line">    <span class="variable">$(CC)</span> -c main.c</span><br><span class="line">library.o : library.c library.h</span><br><span class="line">    <span class="variable">$(CC)</span> -c library.c</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm -f prog <span class="variable">$(objs)</span> *～</span><br></pre></td></tr></table></figure></li><li><h4 id="变量定义格式"><a href="#变量定义格式" class="headerlink" title="变量定义格式"></a>变量定义格式</h4><ul><li>var_name = value：在执行时扩展，允许递归，可以使用后续代码中出现的值</li><li>var_name := value：在定义时扩展，不允许递归，使用右侧的现值，不能使用后续代码中出现的值</li><li>var_name ?= value：只有在该变量为空时才设置值，否则维持原值</li><li>var_name += value：将值追加到变量的尾部；若变量未定义，则“+=”自动解释为“=”；若变量已定义，则“+=”继承上次的操作符，并追加新值</li></ul></li><li><h4 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> var_name</span><br><span class="line">    @echo <span class="string">&quot;One&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;Two&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><ul><li>define和endef行首字符不能为Tab键，对齐时可使用空格</li><li>引用：$(var_name)</li><li>多行变量主要用于定义命令包，使用多行变量要小心，展开时有可能导致脚本错误</li></ul></li><li><h4 id="目标变量：类似局部变量，仅对本目标规则链有效"><a href="#目标变量：类似局部变量，仅对本目标规则链有效" class="headerlink" title="目标变量：类似局部变量，仅对本目标规则链有效"></a>目标变量：类似局部变量，仅对本目标规则链有效</h4><ul><li>target … : var_name = value：定义目标变量</li></ul></li><li><h4 id="静态模式：以“-”通配"><a href="#静态模式：以“-”通配" class="headerlink" title="静态模式：以“%”通配"></a>静态模式：以“%”通配</h4><ul><li>目的：用于处理模式相同的多目标，简化脚本代码</li><li>示例：每个目标的文件以“.o”结尾，先决文件为对应的“.c”<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    objs = main.o library.o</span><br><span class="line">        <span class="variable">$(objs)</span> : %.o : %.c</span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">    <span class="comment">#等价于</span></span><br><span class="line">    main.o : main.c</span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> main.c -o main.o</span><br><span class="line">    library.o : library.c</span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> library.c -o library.o</span><br><span class="line">15. <span class="comment">#### 条件判断基本格式</span></span><br><span class="line">    ```makefile</span><br><span class="line">    conditional-directiveconditional-directive</span><br><span class="line">        text-if-true    text-if-true</span><br><span class="line">    <span class="keyword">endif</span>        <span class="keyword">else</span></span><br><span class="line">                                    text-if-false</span><br><span class="line">                                <span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li><li>可用的条件判断<ul><li>判断两个参数是否相等：ifeq (arg1,arg2)、 ifeq ‘arg1’ ‘arg2’、 ifeq “arg1” “arg2”</li><li>判断两个参数是否不等：ifneq（具体格式与ifeq相同）</li><li>判断某个变量是否已定义：ifdef variable_name</li><li>判断某个变量是否未定义：ifndef variable_name</li></ul></li></ul></li><li><h4 id="循环：可以在makefile中使用shell循环"><a href="#循环：可以在makefile中使用shell循环" class="headerlink" title="循环：可以在makefile中使用shell循环"></a>循环：可以在makefile中使用shell循环</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rulefor :</span><br><span class="line">    for filename in `echo <span class="variable">$(objs)</span>`; \</span><br><span class="line">    do \</span><br><span class="line">        rm -f $$filename; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure><ul><li>注意事项<ul><li>循环为shell循环，为保证多行命令在同一个进程下执行，必须合并成单条命令并在行尾添加分行标识</li><li>可以使用反引号执行命令，所获得的结果集合可以作为循环的处理集合</li><li>filename本身是shell变量，需使用“$$”引用</li></ul></li></ul></li><li><h4 id="函数：像变量一样使用“-”标识"><a href="#函数：像变量一样使用“-”标识" class="headerlink" title="函数：像变量一样使用“$()”标识"></a>函数：像变量一样使用“$()”标识</h4><ul><li>$(function arg1,arg2,…)：函数调用，函数名为function，后跟逗号分隔的参数列表，函数参数前后不能有多余的空格</li><li>$(subst from,to,text) ：make的字符串替换函数，将text中的from字符串替换为to，返回替换后的字符串<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">comma := ,</span><br><span class="line"><span class="comment">#  定义空值</span></span><br><span class="line">empty :=</span><br><span class="line"><span class="comment">#  定义空格</span></span><br><span class="line">space := <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo := a b c</span><br><span class="line"><span class="comment">#  将“a b c”替换为“a,b,c”</span></span><br><span class="line">bar := <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NULL与nullptr</title>
      <link href="2020/02/12/C++/NULL%E4%B8%8Enullptr/"/>
      <url>2020/02/12/C++/NULL%E4%B8%8Enullptr/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-C语言中的NULL"><a href="#1-C语言中的NULL" class="headerlink" title="1. C语言中的NULL"></a>1. C语言中的NULL</h1><p><strong>C语言的NULL是定义在”stddef.h”中的宏，不同的编译器有不同的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0) <span class="comment">// 即把0值强转为指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;          <span class="comment">// 发生了隐式类型转换,这在C++中是行不通的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0L         <span class="comment">// 长整型0值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0          <span class="comment">// 整型0值</span></span></span><br></pre></td></tr></table></figure><h1 id="2-C-语言中的NULL"><a href="#2-C-语言中的NULL" class="headerlink" title="2. C++语言中的NULL"></a>2. C++语言中的NULL</h1><p>*<em>C++语言的NULL就是0值，因为C++不能把void</em>类型的指针隐式转换成其他类型的指针，而在C++11之后，NULL就是nullptr**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="comment">// C++11起</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL nullptr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="3-C-中的nullptr"><a href="#3-C-中的nullptr" class="headerlink" title="3. C++中的nullptr"></a>3. C++中的nullptr</h1><p><strong>关键词nullptr代表指针字面量，它是 std::nullptr_t 类型的纯右值，存在从 nullptr 到任何指针类型及任何成员指针类型的隐式转换</strong></p><p><strong>std::nullptr_t是空指针字面量nullptr的类型</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>class与typename</title>
      <link href="2020/02/12/C++/class%E4%B8%8Etypename/"/>
      <url>2020/02/12/C++/class%E4%B8%8Etypename/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-在模板用法中，typename与class是等价的"><a href="#1-在模板用法中，typename与class是等价的" class="headerlink" title="1. 在模板用法中，typename与class是等价的"></a>1. 在模板用法中，typename与class是等价的</h3><h3 id="2-在typedef中，typename用于告诉编译器后面的不是变量而是类型"><a href="#2-在typedef中，typename用于告诉编译器后面的不是变量而是类型" class="headerlink" title="2. 在typedef中，typename用于告诉编译器后面的不是变量而是类型"></a>2. 在typedef中，typename用于告诉编译器后面的不是变量而是类型</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型编程</title>
      <link href="2020/02/12/C++/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
      <url>2020/02/12/C++/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-函数模板"><a href="#一-函数模板" class="headerlink" title="一. 函数模板"></a>一. 函数模板</h1><ol><li><h3 id="函数模板的目的"><a href="#函数模板的目的" class="headerlink" title="函数模板的目的"></a>函数模板的目的</h3></li></ol><ul><li>设计通用的函数，以适应广泛的数据型式</li></ul><ol start="2"><li><h3 id="函数模板的定义格式"><a href="#函数模板的定义格式" class="headerlink" title="函数模板的定义格式"></a>函数模板的定义格式</h3></li></ol><ul><li>template&lt;模板型式参数列表&gt; 返回值型式 函数名称(参数列表);</li><li>原型：<code>template&lt;class T&gt; void Swap(T &amp;a, T &amp;b);</code></li><li>实现：<code>template&lt;class T&gt; void Swap(T &amp;a, T &amp;b) &#123;...&#125;</code></li></ul><ol start="3"><li><h3 id="函数模板的体化与特化"><a href="#函数模板的体化与特化" class="headerlink" title="函数模板的体化与特化"></a>函数模板的体化与特化</h3></li></ol><ul><li><p>针对特定型参数，在声明或第一次调用该函数模板时体化</p></li><li><p>每次体化都形成针对特定型参数的重载函数版本</p></li><li><p>文件最终只保留特定型参数的一份体化后的函体</p></li><li><p>显式体化主要用于库设计，显式特化覆盖体化的同型函体</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">(T t)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式体化：使用显式的长整型模板参数</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> f&lt;<span class="keyword">long</span>&gt;(<span class="keyword">long</span> n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式体化：使用d的型式推导模板参数型式</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式特化：使用显式的整型参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> f&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式特化：使用c的型式推导模板参数型式</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* 交换函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">        T t;</span><br><span class="line">        t = a, a = b, b = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">11</span>, n = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">&#x27;A&#x27;</span>, b = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        <span class="keyword">double</span> c = <span class="number">1.0</span>, d = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确调用，体化Swap(int&amp;, int&amp;)</span></span><br><span class="line">        Swap(m,n);</span><br><span class="line">        <span class="comment">// 正确调用，体化Swap(char&amp;, char&amp;)</span></span><br><span class="line">        Swap&lt;<span class="keyword">char</span>&gt;(m,n);</span><br><span class="line">        <span class="comment">// 正确调用，体化Swap(double&amp;, double&amp;)</span></span><br><span class="line">        Swap&lt;<span class="keyword">double</span>&gt;(c,d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># 二. 函子</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> ### 编写函数，求某个数据集的最小元，元素型式为T</span><br><span class="line">- 实现策略：使用函数指针作为回调函数参数</span><br><span class="line">- 实现策略：使用函子(function object,functor)作为回调函数参数</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ### 函数指针实现</span><br><span class="line">    ```C++</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp; <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T *a, <span class="keyword">int</span> n, <span class="keyword">bool</span> (*comparer)(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(comparer(a[i],a[index])) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><h3 id="函子的目的"><a href="#函子的目的" class="headerlink" title="函子的目的"></a>函子的目的</h3></li></ol><ul><li>功能上：类似函数指针</li><li>实现上：重载函数调用操作符，必要时重载小于比较操作符</li></ul><ol start="4"><li><h3 id="函子的优点"><a href="#函子的优点" class="headerlink" title="函子的优点"></a>函子的优点</h3></li></ol><ul><li>函数指针不能内联，而函子可以，效率更高</li><li>函子可以拥有任意数量的额外数据，可以保存结果和状态，提高代码灵活性</li><li>编译时可对函子进行型式检查</li></ul><ol start="5"><li><h3 id="函子实现"><a href="#函子实现" class="headerlink" title="函子实现"></a>函子实现</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Comparer</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 确保型式T已存在或重载operator&lt;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comparer&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T &amp; <span class="title">Min</span><span class="params">(<span class="keyword">const</span> T *a, <span class="keyword">int</span> n, Comparer comparer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(comparer(a[i],a[index])) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> min = Min(a,<span class="number">5</span>,Comparer&lt;<span class="keyword">int</span>&gt;());<span class="comment">//构造匿名函子作为函数参数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; min &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="三-完美转发"><a href="#三-完美转发" class="headerlink" title="三. 完美转发"></a>三. 完美转发</h1><ol><li><h3 id="完美转发的意义"><a href="#完美转发的意义" class="headerlink" title="完美转发的意义"></a>完美转发的意义</h3></li></ol><ul><li>库的设计者需要设计一个通用函数，将接收到的参数转发给其他函数</li><li>转发过程中，所有参数保持原先语义不变</li></ul><ol start="2"><li><h3 id="完美转发的实现策略"><a href="#完美转发的实现策略" class="headerlink" title="完美转发的实现策略"></a>完美转发的实现策略</h3></li></ol><ul><li>当需要同时提供移动语义与拷贝语义时，要求重载大量构造函数，编程工作量巨大，易出错  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b):_a(a),_b(b) &#123;&#125;</span><br><span class="line">        A(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;&amp;b):_a(a),_b(move(b)) &#123;&#125;</span><br><span class="line">        A(<span class="keyword">int</span> &amp;&amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b):_a(move(a)),_b(b) &#123;&#125;</span><br><span class="line">        A(<span class="keyword">int</span> &amp;&amp;a, <span class="keyword">int</span> &amp;&amp;b):_a(move(a)),_b(move(b)) &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _a, _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(a,b)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(a,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(<span class="number">1</span>,b)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a4</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>右值引用与函数模板相互配合，可以实现完美转发，极大降低代码编写量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        根据实际参数型式生成不同的左值或右值引用的构造函数版本</span></span><br><span class="line"><span class="comment">        T1或T2可以为不同型，此处相同仅为示例</span></span><br><span class="line"><span class="comment">        实参推演时，使用引用折叠机制</span></span><br><span class="line"><span class="comment">        当形式参数为T&amp;&amp;型时，当且仅当实际参数为右值或右值引用时，</span></span><br><span class="line"><span class="comment">        实际参数才为右值引用</span></span><br><span class="line"><span class="comment">        引用折叠机制与const/volatile无关，保持其参数性质不变</span></span><br><span class="line"><span class="comment">        std::forward&lt;T&gt;(t)转发参数的右值引用T&amp;&amp;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    A(T1 &amp;&amp;a, T2 &amp;&amp;b):_a(forward&lt;T1&gt;(a)), _b(forward&lt;T2&gt;(b)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 如果外面传来了rvalue临时变量, 它就转发rvalue并且启用move语义.</span></span><br><span class="line"> <span class="comment">// 如果外面传来了lvalue, 它就转发lvalue并且启用复制. 然后它也还能保留const.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a, _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="四-类模板"><a href="#四-类模板" class="headerlink" title="四. 类模板"></a>四. 类模板</h1><ol><li><h3 id="类模板的目的"><a href="#类模板的目的" class="headerlink" title="类模板的目的"></a>类模板的目的</h3></li></ol><ul><li>设计通用的类型式，以适应广泛的成员数据型式</li></ul><ol start="2"><li><h3 id="类模板的定义格式"><a href="#类模板的定义格式" class="headerlink" title="类模板的定义格式"></a>类模板的定义格式</h3></li></ol><ul><li>template&lt;模板型式参数列表&gt; class 类名称 {…}</li><li>原型：<code>template&lt;typename T&gt; class A;</code></li></ul><ol start="3"><li><h3 id="类模板的成员"><a href="#类模板的成员" class="headerlink" title="类模板的成员"></a>类模板的成员</h3></li></ol><ul><li>像普通类的成员一样定义</li><li>定义在类中或类外均可，后者需要在类名后列些模板参数，以区别非模板类的成员函数</li><li><code>template&lt;typename T&gt; T A&lt;T&gt;::f(u)&#123;...&#125;</code></li></ul><ol start="4"><li><h3 id="类成员函数的模板"><a href="#类成员函数的模板" class="headerlink" title="类成员函数的模板"></a>类成员函数的模板</h3></li></ol><ul><li>成员函数可以使用其他模板  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; T <span class="title">f</span><span class="params">(<span class="keyword">const</span> U &amp;u)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">T A&lt;T&gt;::f(<span class="keyword">const</span> U &amp;u) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><h3 id="类模板的优化"><a href="#类模板的优化" class="headerlink" title="类模板的优化"></a>类模板的优化</h3></li></ol><ul><li>与函数模板不同，类模板体化时必须给定模板实际参数，如<code>A&lt;T&gt; a;</code></li><li>类模板体化时，编译器生成模板类或成员函数的代码；成员函数在调用时体化，虚函数在类构造时体化</li></ul><ol start="6"><li><h3 id="类模板的显式体化"><a href="#类模板的显式体化" class="headerlink" title="类模板的显式体化"></a>类模板的显式体化</h3></li></ol><ul><li><code>template class A&lt;int&gt;;</code></li><li>解决模板库的创建问题，库的使用者可能没有体化的机会，而未体化的模板定义不会出现在目标文件中</li><li>显式体化类模板后，显式体化其构造函数</li><li>其他成员函数可显式体化，也可不显式体化</li></ul><ol start="7"><li><h3 id="类模板的显式特化"><a href="#类模板的显式特化" class="headerlink" title="类模板的显式特化"></a>类模板的显式特化</h3></li></ol><ul><li>使用特定的型或值显式特化类模板，以定制类模板代码，如：<code>template&lt;&gt; class A&lt;char&gt; &#123;...&#125;;</code></li><li>显式特化版本覆盖体化版本</li><li>显示特化并不要求与原始模板相同，特化版本可以具有不同的数据成员或成员函数</li><li>类模板可以部分特化，结果仍是类模板，以支持类模板的部分定制</li></ul><ol start="8"><li><h3 id="类模板的缺省模板参数"><a href="#类模板的缺省模板参数" class="headerlink" title="类模板的缺省模板参数"></a>类模板的缺省模板参数</h3></li></ol><ul><li>与函数模板相同，类模板可以具有缺省模板参数</li></ul><ol start="9"><li><h3 id="泛型编程实现的队列"><a href="#泛型编程实现的队列" class="headerlink" title="泛型编程实现的队列"></a>泛型编程实现的队列</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueIsEmpty</span> &#123;</span>&#125;;<span class="comment">//空队列异常类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">QueueItem</span>;</span><span class="comment">//队列项类声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        QueueItem&lt;T&gt; *_head, *_tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Queue():_head(<span class="literal">nullptr</span>),_tail(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Queue();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp; item)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _head == <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">QueueItem</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;</span>T&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T _item;</span><br><span class="line">    QueueItem&lt;T&gt; *_next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    QueueItem(<span class="keyword">const</span> T &amp; item):_item(item),_next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; Queue&lt;T&gt;::~Queue() &#123;</span><br><span class="line">    <span class="keyword">while</span>(empty()) &#123;</span><br><span class="line">        pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Queue&lt;T&gt;::push(<span class="keyword">const</span> T &amp; item) &#123;</span><br><span class="line">    QueueItem&lt;T&gt; *p = <span class="keyword">new</span> QueueItem&lt;T&gt;(item);</span><br><span class="line">    <span class="keyword">if</span>(empty()) &#123;</span><br><span class="line">        _head = _tail = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _tail -&gt; _next = p;</span><br><span class="line">        _tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T Queue&lt;T&gt;::pop() &#123;</span><br><span class="line">    <span class="keyword">if</span>(empty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> QueueIsEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    QueueItem&lt;T&gt; *p = _head;</span><br><span class="line">    T _retval = p -&gt; _item;</span><br><span class="line">    _head = _head -&gt; _next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> _retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; *p = <span class="keyword">new</span> Queue&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        p -&gt; push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p -&gt; pop() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>), *q = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>);</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>*&gt; *t = <span class="keyword">new</span> Queue&lt;<span class="keyword">int</span>*&gt;;</span><br><span class="line">    t -&gt; push(r);</span><br><span class="line">    t -&gt; push(q);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(t -&gt; pop()) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="五-元编程"><a href="#五-元编程" class="headerlink" title="五. 元编程"></a>五. 元编程</h1><ol><li><h3 id="什么是元编程？"><a href="#什么是元编程？" class="headerlink" title="什么是元编程？"></a>什么是元编程？</h3></li></ol><ul><li>利用模板可以进行编译器计算(数值计算、型式计算和代码计算)的特点进行程序设计</li></ul><ol start="2"><li><h3 id="为什么可以进行元编程？"><a href="#为什么可以进行元编程？" class="headerlink" title="为什么可以进行元编程？"></a>为什么可以进行元编程？</h3></li></ol><ul><li>C++是两层语言：执行编译期计算的代码称为静态代码，执行运行期计算的代码称为动态代码</li><li>模板可用于<strong>函数式编程</strong>：强调抽象计算，充实模块化，使用递归控制流程</li><li>模板是图灵完备的：理论上模板可以执行任何计算任务</li></ul><ol start="3"><li><h3 id="为什么需要元编程？"><a href="#为什么需要元编程？" class="headerlink" title="为什么需要元编程？"></a>为什么需要元编程？</h3></li></ol><ul><li>编译器计算可以使代码更通用，更易用，提升程序执行性能</li></ul><ol start="4"><li><h3 id="元编程的缺点"><a href="#元编程的缺点" class="headerlink" title="元编程的缺点"></a>元编程的缺点</h3></li></ol><ul><li>相对结构化编程，编译效率极低</li><li>代码丑陋不堪，阅读难，调试难，维护难，易导致代码膨胀</li></ul><ol start="5"><li><h3 id="元编程可以做什么？"><a href="#元编程可以做什么？" class="headerlink" title="元编程可以做什么？"></a>元编程可以做什么？</h3></li></ol><ul><li>数值序列计算、素数判定、控制结构、循环展开、型式判定、表达式、编译期多态、特性、策略、标签、元容器、…</li><li>注：对操作系统编程而言，元编程意义不大</li></ul><ol start="6"><li><h3 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i = <span class="number">1</span>&gt; class Fibonacci &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        value = Fibonacci&lt;i<span class="number">-1</span>&gt;::value + Fibonacci&lt;i<span class="number">-2</span>&gt;::value</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span>&lt;</span><span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        value = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        value = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Fibonacci&lt;<span class="number">7</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="六-泛型编程实践：事件机制"><a href="#六-泛型编程实践：事件机制" class="headerlink" title="六. 泛型编程实践：事件机制"></a>六. 泛型编程实践：事件机制</h1><blockquote><p>有一说一，看不太懂…太复杂了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;; <span class="comment">// 空类，用于指代响应对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件响应者类模板，保存特定事件的响应者与响应行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EventAction&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventResponsor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公开数据成员，以方便使用者</span></span><br><span class="line">Empty *actor;</span><br><span class="line">EventAction *action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">EventResponsor(Empty *actor, EventAction *action) : actor(actor), action(action) &#123;&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> EventResponsor &amp;lhs, <span class="keyword">const</span> EventResponsor &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.actor == rhs.actor &amp;&amp; *lhs.action == *rhs.action;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件类模板，用于管理特定事件的所有响应者</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EventAction&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;EventResponsor&lt;EventAction&gt;&gt; EventResponsors;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;EventResponsor&lt;EventAction&gt;&gt;::iterator EventIterator; <span class="comment">// 这里的typename是类型名指示符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">EventResponsors _ers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Event()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (EventIterator it = <span class="keyword">this</span>-&gt;_ers.begin(); it != <span class="keyword">this</span>-&gt;_ers.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> it-&gt;action;</span><br><span class="line">it-&gt;action = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EventResponsors &amp;<span class="title">GetResponsors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事件绑定，将实际响应者和响应行为挂接到响应者对象上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Responsor, <span class="keyword">typename</span> Action&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bind</span><span class="params">(Responsor *actor, Action action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Action *act = <span class="keyword">new</span> Action(action);</span><br><span class="line"><span class="function">EventResponsor&lt;EventAction&gt; <span class="title">er</span><span class="params">((Empty *)actor, (EventAction *)act)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> unbound = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (EventIterator it = <span class="keyword">this</span>-&gt;_ers.begin(); it != <span class="keyword">this</span>-&gt;_ers.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it == er)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 发现重复的事件响应者，说明已绑定</span></span><br><span class="line">unbound = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (unbound)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ers.push_back(er);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> er.action;</span><br><span class="line">er.action = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解除事件绑定，删除事件响应者对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Responsor, <span class="keyword">typename</span> Action&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unbind</span><span class="params">(Responsor *actor, Action action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Action *act = <span class="keyword">new</span> Action(action);</span><br><span class="line"><span class="function">EventResponsor&lt;EventAction&gt; <span class="title">er</span><span class="params">((Empty *)actor, (EventAction *)act)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (EventIterator it = <span class="keyword">this</span>-&gt;_ers.begin(); it != <span class="keyword">this</span>-&gt;_ers.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it == er)</span><br><span class="line">&#123; <span class="comment">// 找到待删除的事件响应者对象</span></span><br><span class="line"><span class="keyword">delete</span> it-&gt;action;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ers.erase(it);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> er.action;</span><br><span class="line">er.action = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义事件委托模型、指向类成员函数的指针</span></span><br><span class="line"><span class="keyword">typedef</span> Empty EventDelegator;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(EventDelegator::*ValueChanged)</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">void</span> *tag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  触发者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trigger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Trigger() : _value(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">void</span> *tag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  值变化事件，公开属性，方便在类外设定</span></span><br><span class="line">Event&lt;ValueChanged&gt; value_changed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设定值，遍历特定事件的响应对象列表，逐一触发值变更事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trigger::SetValue</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">void</span> *tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_value == value)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_value = value;</span><br><span class="line">Event&lt;ValueChanged&gt;::EventResponsors ers;</span><br><span class="line">ers = <span class="keyword">this</span>-&gt;value_changed.GetResponsors();</span><br><span class="line"><span class="keyword">if</span> (!ers.empty())</span><br><span class="line">&#123;</span><br><span class="line">Event&lt;ValueChanged&gt;::EventIterator it;</span><br><span class="line"><span class="keyword">for</span> (it = ers.begin(); it != ers.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">((it-&gt;actor)-&gt;*(*(it-&gt;action)))(value, tag); <span class="comment">//  响应事件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  行动者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  侦听事件，绑定本对象的事件响应函数到侦听的事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Listen</span><span class="params">(Trigger *trigger)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trigger-&gt;value_changed.Bind(<span class="keyword">this</span>, &amp;Actor::OnValueChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  停止侦听，从侦听的事件中取消绑定本对象的事件响应活动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unlisten</span><span class="params">(Trigger *trigger)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trigger-&gt;value_changed.Unbind(<span class="keyword">this</span>, &amp;Actor::OnValueChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  值变更事件的响应函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnValueChanged</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">void</span> *tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(tag) &lt;&lt; value &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">&quot;Now the value is &quot;</span>;</span><br><span class="line">Trigger t;</span><br><span class="line">Actor a1, a2;</span><br><span class="line"></span><br><span class="line">a1.Listen(&amp;t);</span><br><span class="line">a2.Listen(&amp;t);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Listening...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">t.SetValue(<span class="number">10</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(s)));</span><br><span class="line"></span><br><span class="line">a2.Unlisten(&amp;t);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Listening again...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">t.SetValue(<span class="number">20</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(s)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准模板库</title>
      <link href="2020/02/12/C++/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
      <url>2020/02/12/C++/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-模板"><a href="#一-模板" class="headerlink" title="一. 模板"></a>一. 模板</h1><ol><li><h3 id="模板工作原理"><a href="#模板工作原理" class="headerlink" title="模板工作原理"></a>模板工作原理</h3></li></ol><ul><li>使用template<typename T>定义函数模板或类模板</li><li>体化：使用特定的模板实际参数，生成真正的模板函数和模板类</li><li>编译模板函数和模板类，生成最终程序代码</li></ul><ol start="2"><li><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3></li></ol><ul><li>一般放在头文件中：编译器需要看到模板源代码</li></ul><ol start="3"><li><h3 id="模板特点"><a href="#模板特点" class="headerlink" title="模板特点"></a>模板特点</h3></li></ol><ul><li>抽象性：模板代码高度抽象，是函数和类的模范</li><li>安全性：型式检查能够发现大多数型式失配问题</li><li>通用性：函数和类模板定义一次，按需生成函数和类的实体</li><li>易用性：接口相对直观且高度一致</li><li>效率：减少冗余代码，提升编程效率，通过编译优化，提升程序执行效率</li></ul><ol start="4"><li><h3 id="模板用途"><a href="#模板用途" class="headerlink" title="模板用途"></a>模板用途</h3></li></ol><ul><li>函数模板：构造函数集，实现不依赖特定数据结构的抽象算法</li><li>类模板：构造类集，实现抽象数据结构</li><li>元编程：构造在编译器执行的运算，提升程序执行效率</li></ul><h1 id="二-标准模板库"><a href="#二-标准模板库" class="headerlink" title="二. 标准模板库"></a>二. 标准模板库</h1><ol><li><h3 id="标准模板库的内容"><a href="#标准模板库的内容" class="headerlink" title="标准模板库的内容"></a>标准模板库的内容</h3></li></ol><ul><li>标准模板类：复数，序偶</li><li>迭代器</li><li>标准容器：向量，表，栈，队列，集合，映射等</li><li>标准算法：查找，排序等</li></ul><h1 id="三-复数"><a href="#三-复数" class="headerlink" title="三. 复数"></a>三. 复数</h1><ol><li><h3 id="一般说明"><a href="#一般说明" class="headerlink" title="一般说明"></a>一般说明</h3></li></ol><ul><li>头文件：”complex”</li><li>模板名：complex&lt;&gt;</li><li>基型式：float,double,long double</li><li>首选double，float精度太低，long double已废弃</li></ul><ol start="2"><li><h3 id="实部与虚部"><a href="#实部与虚部" class="headerlink" title="实部与虚部"></a>实部与虚部</h3></li></ol><ul><li>成员函数real()与imag()</li></ul><ol start="3"><li><h3 id="复数操作"><a href="#复数操作" class="headerlink" title="复数操作"></a>复数操作</h3></li></ol><ul><li>复数全部操作均可以按照数学格式进行</li><li>cout,cin均已重载：格式为(real,imag)</li></ul><h1 id="四-序偶"><a href="#四-序偶" class="headerlink" title="四. 序偶"></a>四. 序偶</h1><ol><li><h3 id="一般说明-1"><a href="#一般说明-1" class="headerlink" title="一般说明"></a>一般说明</h3></li></ol><ul><li>头文件：”utility”</li><li>模板名：pair&lt;&gt;</li><li>用于表示总是成对出现的两个对象</li><li>示例一：<code>pair&lt;int,double&gt; a(1,1.0);</code></li><li>示例而：<code>pair&lt;string,string&gt; name(&quot;Zhang&quot;,&quot;San);</code></li></ul><ol start="2"><li><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3></li></ol><ul><li>公开的数据成员：first，second</li><li>示例：<code>cout &lt;&lt; name.first &lt;&lt; &quot;,&quot; &lt;&lt; name.second;</code></li><li>序偶比较：先比较first大小，相同时比较second大小</li><li>make_pair：构造序偶的辅助函数</li><li>示例：<code>pair&lt;int,double&gt; a; a = make_pair(1,1.0);</code></li></ul><h1 id="五-向量"><a href="#五-向量" class="headerlink" title="五. 向量"></a>五. 向量</h1><ol><li><h3 id="向量的目的"><a href="#向量的目的" class="headerlink" title="向量的目的"></a>向量的目的</h3></li></ol><ul><li>替代数组，可以像数组一样使用向量</li></ul><ol start="2"><li><h3 id="向量的使用"><a href="#向量的使用" class="headerlink" title="向量的使用"></a>向量的使用</h3></li></ol><ul><li>定义格式：<code>vector&lt;int&gt; v(8); //包含8个整数元素</code></li><li>operator[]：已重载，使用格式v[i]访问第i个元素</li><li>向量可以整体赋值</li><li>size()：返回向量中元素数目</li><li>capacity()：返回向量当前可存储的最多元素数目</li><li>clear()：删除向量所有元素，但不释放向量本身</li><li>resize(int newsize)：重新设置向量容量</li></ul><h1 id="六-迭代器"><a href="#六-迭代器" class="headerlink" title="六. 迭代器"></a>六. 迭代器</h1><ol><li><h3 id="迭代器的性质"><a href="#迭代器的性质" class="headerlink" title="迭代器的性质"></a>迭代器的性质</h3></li></ol><ul><li>通过迭代器访问容器中的数据对象</li><li>类似指针，数组索引的功能：通过指针加减与数组下标运算获得下一数据对象</li><li>迭代器可以是指针，但并不必须是指针，他可以重载引领运算符，也不必总是使用数据对象地址</li></ul><ol start="2"><li><h3 id="迭代器的典型使用方法"><a href="#迭代器的典型使用方法" class="headerlink" title="迭代器的典型使用方法"></a>迭代器的典型使用方法</h3></li></ol><ul><li>声明迭代器变量</li><li>使用引领操作符范文迭代器指向的当前目标对象</li><li>使用递增操作符获得下一对象的访问权</li><li>若迭代器新值超出容器的元素范围，类似指针值变成NULL，目标对象不可引用</li></ul><ol start="3"><li><h3 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h3></li></ol><ul><li>输入迭代器：提供对象的只读访问</li><li>输出迭代器：提供对象的只写访问</li><li>前向迭代器：提供对象的正向（递增）读写访问</li><li>双向迭代器：提供对象的正向与反向（递增递减）读写访问</li><li>随机访问迭代器：提供对象的随机读写访问</li></ul><ol start="4"><li><h3 id="指针作为迭代器"><a href="#指针作为迭代器" class="headerlink" title="指针作为迭代器"></a>指针作为迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = find(a,a+<span class="number">5</span>,<span class="number">3</span>); <span class="comment">//调用标准模板库的find()函数查找数组元素</span></span><br><span class="line"><span class="keyword">if</span>(p == a+<span class="number">5</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found 3.\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found 3.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="向量迭代器"><a href="#向量迭代器" class="headerlink" title="向量迭代器"></a>向量迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it, head = v.begin(), tail = v.end();</span><br><span class="line">it = find(head,tail,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span>(it != tail) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found 3.\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found 3.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="常迭代器"><a href="#常迭代器" class="headerlink" title="常迭代器"></a>常迭代器</h3></li></ol><ul><li>若不想通过迭代器修改目标对象值，定义迭代器常量</li><li>示例：<code>const vector&lt;int&gt;::iterator it;</code></li><li>非法操作：<code>*it = 10; //不能修改常迭代器指向的对象</code></li></ul><ol start="7"><li><h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><h4 id="使用迭代器访问流"><a href="#使用迭代器访问流" class="headerlink" title="使用迭代器访问流"></a>使用迭代器访问流</h4></li></ol><ul><li><p>将输入输出流作为容器</p><h4 id="使用方式：定义流迭代器对象"><a href="#使用方式：定义流迭代器对象" class="headerlink" title="使用方式：定义流迭代器对象"></a>使用方式：定义流迭代器对象</h4></li><li><p>示例一：<code>ostream_iterator&lt;int&gt; oit(cout,&quot; &quot;);</code></p></li><li><p>示例二(从cin获取数据)：<code>istream_iterator&lt;int&gt; iit(cin);</code></p></li><li><p>示例三(使用空指针创建流结束迭代器)：<code>istream_iterator&lt;int&gt; iit;</code></p></li><li><p>凡事可以出现迭代器的标准算法都可以使用</p><h4 id="输出流迭代器"><a href="#输出流迭代器" class="headerlink" title="输出流迭代器"></a>输出流迭代器</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; v, <span class="keyword">const</span> <span class="keyword">char</span> * s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator head = v.begin(), tail = v.end();</span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">oit</span><span class="params">(<span class="built_in">cout</span>,<span class="string">&quot;;&quot;</span>)</span></span>;</span><br><span class="line">    copy(head,tail,oit);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    display(v,<span class="string">&quot;array generated:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator head = v.begin(), tail = v.end();</span><br><span class="line">    sort(head,tail);</span><br><span class="line">    display(v,<span class="string">&quot;array sorted:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reverse(head,tail);</span><br><span class="line">    display(v,<span class="string">&quot;array reversed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        array generated:</span></span><br><span class="line"><span class="comment">        5;2;3;4;1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        array sorted:</span></span><br><span class="line"><span class="comment">        1;2;3;4;5;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        array reversed:</span></span><br><span class="line"><span class="comment">        5;4;3;2;1;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输入流迭代器"><a href="#输入流迭代器" class="headerlink" title="输入流迭代器"></a>输入流迭代器</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入5个整数,空格分隔，任意字符结束：\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    istream_iterator&lt;int&gt; head(cin),tail;</span><br><span class="line">    copy(head,tail,it);<span class="comment">//将cin复制到vector中</span></span><br><span class="line">    <span class="built_in">cin</span>.clear();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输入5个整数,空格分隔，任意字符结束：</span></span><br><span class="line"><span class="comment">        1 2 3 4 5 @</span></span><br><span class="line"><span class="comment">        vector = 1 2 3 4 5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="七-表：标准模板库中的为双向链表"><a href="#七-表：标准模板库中的为双向链表" class="headerlink" title="七. 表：标准模板库中的为双向链表"></a>七. 表：标准模板库中的为双向链表</h1><ol><li><h3 id="表的使用"><a href="#表的使用" class="headerlink" title="表的使用"></a>表的使用</h3></li></ol><ul><li>定义：<code>list&lt;int&gt; ints(5)</code>;</li><li>插入：<code>ints.insert(ints.begin(),7); //插入到表头</code></li><li>表头插入：<code>ints.push_front(7);</code></li><li>插入：<code>ints.insert(ints.end(),7); //插入到表尾</code></li><li>表尾插入：<code>ints.push_back(7);</code></li><li>取表头：<code>ints.front();</code></li><li>取表尾：<code>ints.back();</code></li><li>删除：<code>delete ints.front();</code> <code>ints.remove(ints.front());</code></li><li>判空：<code>ints.empty();</code></li></ul><ol start="2"><li><h3 id="表与迭代器"><a href="#表与迭代器" class="headerlink" title="表与迭代器"></a>表与迭代器</h3></li></ol><ul><li>迭代器可以和表协同工作，方式与向量相同  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = a.begin(); it != a.end(); it++) &#123;</span><br><span class="line">    *it = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>表排序<ul><li>直接使用表的成员函数：a.sort(); 默认升序</li><li>降序排序一：升序排序后调用reverse();</li><li>降序排序二(传入函子greater_equal<int>())：a.sort(greater_equal<int>());</li><li>对于自定义对象，需要重载operator&lt;以进行比较</li></ul></li></ul><h1 id="八-标准算法"><a href="#八-标准算法" class="headerlink" title="八. 标准算法"></a>八. 标准算法</h1><ul><li>adjacent_find：查找两个相等或满足特定条件的相邻元素</li><li>all_of：当给定区间内全部元素均满足条件时返回true</li><li>any_of：当给定区间内至少一个元素满足条件时返回true</li><li>binary_search：折半查找，原始数据集已序</li><li>copy：复制给定区间内全部元素</li><li>copy_backward：反向复制给定区间内全部元素</li><li>copy_if：复制给定区间内满足特定条件的元素</li><li>copy_n：复制特定位置处开始的指定数目的元素</li><li>count：返回给定区间内匹配特定值的元素个数</li><li>count_if：返回给定区间内匹配特定条件的元素个数</li><li>equal：比较两个区间是否相等，逐元素比较</li><li>equal_range：给定一个已序区间，返回与特定值相等的子区间</li><li>fill：使用特定值填充给定区间内全部元素</li><li>fill_n：使用特定值填充从特定位置处开始的指定数目的元素</li><li>find：查找给定区间内特定元素，返回其首次出现位置</li><li>find_end：查找给定区间内特定序列，返回其末次出现位置</li><li>find_first_of：查找给定区间内多个特定值中任意值，返回其首次出现位置</li><li>find_if：查找给定区间内满足特定条件的元素，返回其首次出现位置</li><li>find_if_not：查找给定区间内不满足特定条件的元素，返回其首次出现位置</li><li>for_each：正向遍历给定区间，实施函子指定的操作，并返回该函子</li><li>generate：将函子生成的值复制给给定区间内全部元素</li><li>generate_n：将函子生成的值复制给从指定位置开始的指定数目的元素，返回最后一次赋值的位置</li><li>includes：测试第一已序区间是否包含第二已序区间全部元素</li><li>inplace_merge：在位归并两个已序区间</li><li>is_heap：返回给定区间内元素是否形成堆</li><li>is_heap_until：返回给定区间直到最后一个元素是否形成堆</li><li>is_partitioned：给定区间是否已划分，当区间内满足条件的元素全部出现在不满足条件的元素之前时，返回true</li><li>is_sorted：给定区间的元素是否已排序</li><li>is_sorted_until： 给定区间的元素是否已排序，返回最后一个已序元素的前向迭代器</li><li>iter_swap：互换两个迭代器引用的值</li><li>lexicographical_compare：逐元素按词典序比较两个序列，第一序列较小时返回true</li><li>lower_bound：下界，返回给定已序区间大于或等于特定值的首个元素位置</li><li>make_checked_array_iterator：创建一个checked_array_iterator</li><li>make_heap：将给定区间内元素转换为堆</li><li>max：比较两个对象，返回较大者</li><li>max_element：查找给定区间内最大元的首次出现位置</li><li>merge：归并两个已序区间</li><li>min：比较两个对象，返回较小者</li><li>min_element：查找给定区间内最小元的首次出现位置</li><li>minmax：比较两个参数，按前小后大的顺序返回数偶</li><li>minmax_element：同时实施min_element和max_element操作</li><li>mismatch：比较两个给定区间元素，返回失配元素的首次出现位置</li><li>move：移动给定区间内元素</li><li>move_backward：逆向移动给定区间内元素</li><li>next_permutation：按词典序返回元素序列的下一排列</li><li>none_of：给定区间内元素如果不满足条件返回true</li><li>nth_element：划分给定区间，返回第n个元素位置，该元素不小于其前全部元素，不大于其后全部元素</li><li>partial_sort：部分排序</li><li>partial_sort_copy：部分排序拷贝</li><li>partition：按特定条件将元素划分为不相交的两个集合</li><li>partition_copy：划分拷贝</li><li>partition_point：在给定区间内查找不满足特定条件的首个元素（划分点），其前元素满足条件，该元素及其后元素不满足该条件</li><li>pop_heap：从堆中删除最大元素</li><li>prev_permutation：按词典序返回元素序列的前一排列</li><li>push_heap：向堆中添加元素</li><li>random_shuffle：随机生成元素序列的新排列</li><li>remove：删除给定区间内某个元素</li><li>remove_copy：仅拷贝给定区间内非特定值的元素</li><li>remove_copy_if：仅拷贝给定区间内不满足特定条件的元素</li><li>remove_if：删除给定区间内满足特定条件的元素</li><li>replace：将具有特定值的元素替换为新值</li><li>replace_copy：拷贝时替换</li><li>replace_copy_if：拷贝时替换满足特定条件的元素</li><li>replace_if：满足特定条件时替换</li><li>reverse：逆序</li><li>reverse_copy：拷贝时逆序</li><li>rotate：旋转，互换两个相邻区间的元素</li><li>rotate_copy：拷贝时旋转</li><li>search：查找</li><li>search_n：查找具有特定值的特定个数元素构成的子序列</li><li>set_difference：集合差运算</li><li>set_intersection：集合交运算</li><li>set_symmetric_difference：集合对称差运算</li><li>set_union：集合并运算</li><li>sort：排序</li><li>sort_heap：将堆转换为已序区间</li><li>stable_partition：稳定划分</li><li>stable_sort：稳定排序</li><li>swap：元素交换</li><li>swap_ranges：区间内全部元素交换</li><li>transform：变换</li><li>unique：删除重复元素</li><li>unique_copy：拷贝时删除重复元素</li><li>upper_bound：上界，返回给定已序区间大于特定值的首个元素位置</li></ul><h1 id="九-标准函子"><a href="#九-标准函子" class="headerlink" title="九. 标准函子"></a>九. 标准函子</h1><ul><li>#include <functional></li></ul><ol><li><h3 id="算数函子"><a href="#算数函子" class="headerlink" title="算数函子"></a>算数函子</h3></li></ol><ul><li>plus&lt;T&gt;、minus&lt;T&gt;、multiplies&lt;T&gt;、divides&lt;T&gt;、modulus&lt;T&gt;、negate&lt;T&gt;</li></ul><ol start="2"><li><h3 id="关系函子"><a href="#关系函子" class="headerlink" title="关系函子"></a>关系函子</h3></li></ol><ul><li>equal_to&lt;T&gt;、not_equal_to&lt;T&gt;、greater&lt;T&gt;、greater_equal&lt;T&gt;、less&lt;T&gt;、less_equal&lt;T&gt;</li></ul><p><strong>greater<T>()匿名对象可以被用作sort的回调，改为降序</strong></p><ol start="3"><li><h3 id="逻辑函子"><a href="#逻辑函子" class="headerlink" title="逻辑函子"></a>逻辑函子</h3></li></ol><ul><li>logical_and&lt;T&gt;、logical_or&lt;T&gt;、logical_not&lt;T&gt;</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>型式兼容性问题</title>
      <link href="2020/02/11/C++/%E5%9E%8B%E5%BC%8F%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>2020/02/11/C++/%E5%9E%8B%E5%BC%8F%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-C-C-的型式转换"><a href="#一-C-C-的型式转换" class="headerlink" title="一. C/C++的型式转换"></a>一. C/C++的型式转换</h1><ol><li><h3 id="C型式转换：-T-x"><a href="#C型式转换：-T-x" class="headerlink" title="C型式转换：(T)x"></a>C型式转换：(T)x</h3></li></ol><ul><li>不安全</li><li>内建型式(int,double)对象转换安全性基本保证</li><li>类对象转换可能导致无法控制的后果</li></ul><ol start="2"><li><h3 id="C-型式转换：T-x"><a href="#C-型式转换：T-x" class="headerlink" title="C++型式转换：T(x)"></a>C++型式转换：T(x)</h3></li></ol><ul><li>可能需要单参数构造函数和重载的型式转换操作符</li><li>不安全</li><li>如果未实现，转换就不存在</li></ul><ol start="3"><li><h3 id="类库架构及问题"><a href="#类库架构及问题" class="headerlink" title="类库架构及问题"></a>类库架构及问题</h3></li></ol><ul><li>类的继承和多态频繁要求能够通过基类的指针或引用访问派生类的对象</li><li>需要沿着类的继承层次，频繁的进行对象的型式转换</li><li>C/C++已有型式转换均为静态转换，不能适应指针或引用的多态性</li><li>型式转换必须适应全部型式，并能自如操作，然而型式无穷尽，程序员无法编写完备的型式转换代码</li></ul><h1 id="二-保证型式兼容性的机制"><a href="#二-保证型式兼容性的机制" class="headerlink" title="二. 保证型式兼容性的机制"></a>二. 保证型式兼容性的机制</h1><ul><li>确保型式转换操作合法有效，并在失败时通知用户</li><li>需要维持对象的运行期型式信息(RTTI)</li><li>转换结果确认：通过转换操作的返回值确认结果，或者在失败时触发特定信号；后者需要使用异常处理机制</li><li>实现策略：模板与型式参数化</li></ul><h1 id="三-运行期型式信息"><a href="#三-运行期型式信息" class="headerlink" title="三. 运行期型式信息"></a>三. 运行期型式信息</h1><ol><li><h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3></li></ol><ul><li>运行期标识对象的形式信息</li><li>优势：允许使用指向基类的指针或引用自如的操纵派生类对象</li><li>typeid：获取表达式的型式</li><li>type_info：型式信息类，用于程序运行时保存数据对象的形式信息</li><li>头文件：”typeinfo”  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//typeid返回的是type_info类型的引用，不能直接使用该类只能通过typeid操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><h3 id="对象转换模板"><a href="#对象转换模板" class="headerlink" title="对象转换模板"></a>对象转换模板</h3></li></ol><ul><li>dynamic_cast:动态转型</li><li>static_cast:静态转型</li><li>reinterpret_cast:重解释转型</li><li>const_cast:常量转型</li></ul><h1 id="四-dynamic-cast"><a href="#四-dynamic-cast" class="headerlink" title="四. dynamic_cast"></a>四. dynamic_cast</h1><ol><li><h3 id="动态转型的三种方式"><a href="#动态转型的三种方式" class="headerlink" title="动态转型的三种方式"></a>动态转型的三种方式</h3></li></ol><ul><li>向上转型：沿着类继承层次向基类转型</li><li>向下转型：沿着类继承层次向派生类转型</li><li>交叉转型：沿着类多重继承层次横向转型</li></ul><ol start="2"><li><h3 id="指针的动态转型"><a href="#指针的动态转型" class="headerlink" title="指针的动态转型"></a>指针的动态转型</h3></li></ol><ul><li>正确执行时，结果为指向目标类对象的指针</li><li>错误执行时，结果为0/NULL(C++11:nullptr)</li></ul><ol start="3"><li><h3 id="引用的动态转型"><a href="#引用的动态转型" class="headerlink" title="引用的动态转型"></a>引用的动态转型</h3></li></ol><ul><li>正确执行时，结果为目标类对象的引用</li><li>错误执行时，引发bad_cast异常，该异常类定义在”type_info”头文件中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">promote</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//晋升</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">expel</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//开除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ace</span>:</span> <span class="keyword">public</span> Employee &#123;<span class="comment">//大牛</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">promote</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">expel</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rookie</span>:</span> <span class="keyword">public</span> Employee &#123;<span class="comment">//菜鸟</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">promote</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">expel</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(Employee * e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(Employee &amp; e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Company::doing</span><span class="params">(Employee * e)</span> </span>&#123;</span><br><span class="line">Ace *p = <span class="keyword">dynamic_cast</span>&lt;Ace*&gt;(e);</span><br><span class="line"><span class="keyword">if</span>(p) &#123;<span class="comment">//如果e是大牛就晋升</span></span><br><span class="line">p -&gt; promote();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//否则开除</span></span><br><span class="line">p -&gt; expel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Company::doing</span><span class="params">(Employee &amp; e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Ace &amp;p = <span class="keyword">dynamic_cast</span>&lt;Ace&amp;&gt;(e);</span><br><span class="line">p.promote();<span class="comment">//如果没抛出异常说明是大牛</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::bad_cast) &#123;<span class="comment">//std::bad_cast定义在&quot;type_info&quot;头文件中</span></span><br><span class="line">e.expel();<span class="comment">//抛出异常，是菜鸟</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Company company = Company();</span><br><span class="line">Ace* ace = <span class="keyword">new</span> Ace();</span><br><span class="line">Rookie* rookie = <span class="keyword">new</span> Rookie();</span><br><span class="line"></span><br><span class="line">company.doing(ace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="五-static-cast"><a href="#五-static-cast" class="headerlink" title="五. static_cast"></a>五. static_cast</h1><ol><li><h3 id="静态转型的用途"><a href="#静态转型的用途" class="headerlink" title="静态转型的用途"></a>静态转型的用途</h3></li></ol><ul><li>与dynamic_cast不同，static_cast不仅可用于指针和引用，还可用于任何其他型式</li><li>一般用于非类型式的普通数据对象转型</li><li>可以在类继承层次上进行向上或向下转型</li></ul><ol start="2"><li><h3 id="静态转型的问题"><a href="#静态转型的问题" class="headerlink" title="静态转型的问题"></a>静态转型的问题</h3></li></ol><ul><li>在编译器进行，不进行运行期型式检查，不安全</li><li>若转型失败，结果无定义</li></ul><h1 id="六-const-cast"><a href="#六-const-cast" class="headerlink" title="六. const_cast"></a>六. const_cast</h1><ol><li><h3 id="常量转型的目的"><a href="#常量转型的目的" class="headerlink" title="常量转型的目的"></a>常量转型的目的</h3></li></ol><ul><li>用于取消或设置量的const状态</li></ul><ol start="2"><li><h3 id="常量转型的问题"><a href="#常量转型的问题" class="headerlink" title="常量转型的问题"></a>常量转型的问题</h3></li></ol><ul><li>如果原始数据对象不能写入，则取消常量修饰可能会导致未知结果  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A(<span class="keyword">int</span> i):a(i) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//const修饰两个地方都要写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::printA</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//const修饰两个地方都要写</span></span><br><span class="line">    <span class="comment">//常成员函数内部的this指针是常指针，需要临时转换才能对a进行自增操作</span></span><br><span class="line">    <span class="keyword">const_cast</span>&lt;A*&gt;(<span class="keyword">this</span>) -&gt; a++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="七-reinterpret-cast"><a href="#七-reinterpret-cast" class="headerlink" title="七. reinterpret_cast"></a>七. reinterpret_cast</h1><ol><li><h3 id="重解释转型的目的"><a href="#重解释转型的目的" class="headerlink" title="重解释转型的目的"></a>重解释转型的目的</h3></li></ol><ul><li>将任意型式的数据对象转型为目标型式，即重新解释其位序列的意义</li><li>可以用于整型与指针型的互转</li></ul><ol start="2"><li><h3 id="重解释转型的问题"><a href="#重解释转型的问题" class="headerlink" title="重解释转型的问题"></a>重解释转型的问题</h3></li></ol><ul><li>由程序员保证重新解释的数据对象是否具有意义，编译器简单按照目标型式理解该存储区的内容</li><li>注意：在64位操作系统中，指针型可能为64位，而整型可能为32位，重解释转型有可能丢失数据或得到错误结果  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %p\n&quot;</span>,p,p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,n);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        140725602648092 0x7ffd3b8e801c</span></span><br><span class="line"><span class="comment">        140725602648092</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常处理机制</title>
      <link href="2020/02/11/C++/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>2020/02/11/C++/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="C语言的异常处理"><a href="#C语言的异常处理" class="headerlink" title="C语言的异常处理"></a>C语言的异常处理</h2><ol><li>通过返回值来判断是否出现异常<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;   <span class="comment">//但如果这一步也是-1，就无法判断是否出现异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用errno宏（可以简单理解为一个全局整型变量）去记录错误，使用perror可以输出</li></ol><h2 id="一-异常处理机制基础"><a href="#一-异常处理机制基础" class="headerlink" title="一. 异常处理机制基础"></a>一. 异常处理机制基础</h2><ol><li><h3 id="异常的定义"><a href="#异常的定义" class="headerlink" title="异常的定义"></a>异常的定义</h3></li></ol><ul><li>程序中可以检测的运行不正常的情况</li><li>示例：被0除，数组越界，存储空间不足</li><li>C++异常处理使得异常的引发和异常的处理不必在一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理，上层调用者可以在适当的位置设计对不同类型异常的处理</li></ul><ol start="2"><li><h3 id="异常处理的基本流程"><a href="#异常处理的基本流程" class="headerlink" title="异常处理的基本流程"></a>异常处理的基本流程</h3></li></ol><ul><li>某段程序代码在执行操作时发生特殊情况，引发一个特定的异常</li><li>另一段程序代码捕获该异常并处理它</li><li>如果抛出的异常没有处理程序就会中断(运行函数terminate被自动调用，其缺省功能调用abort终止程序)</li><li>抛出的是个数据类型，catch判断数据类型来捕获</li></ul><ol start="3"><li><h3 id="定义一个计算器类"><a href="#定义一个计算器类" class="headerlink" title="定义一个计算器类"></a>定义一个计算器类</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>调用成员函数Calculator::divide()时，除数为零</li></ul></li><li><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>定义异常类</li><li>修改成员函数，在出现异常情况时引发之</li><li>在需要的位置处理该异常</li></ul></li></ul><h2 id="二-异常的引发"><a href="#二-异常的引发" class="headerlink" title="二. 异常的引发"></a>二. 异常的引发</h2><ul><li>try内throw后面的代码不会被执行，无论是否被捕获<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DivisorIsZero</span> &#123;</span> &#125;;<span class="comment">//异常类，除数为零</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calculator::divide</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;<span class="comment">//引发除数为零异常，构造该异常类的一个对象并抛出</span></span><br><span class="line"><span class="keyword">throw</span> DivisorIsZero();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-异常的捕获"><a href="#三-异常的捕获" class="headerlink" title="三. 异常的捕获"></a>三. 异常的捕获</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Calculator cal = Calculator();</span><br><span class="line">cal.a = <span class="number">5</span>;</span><br><span class="line">cal.b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cal.divide();<span class="comment">//可能引发异常的函数调用</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">const</span> DivisorIsZero &amp;) &#123;<span class="comment">//捕获抛出的异常，执行相应处理</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error:divisor is zero.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;666\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Error:divisor is zero.</span></span><br><span class="line"><span class="comment">666</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-异常类与异常对象"><a href="#四-异常类与异常对象" class="headerlink" title="四. 异常类与异常对象"></a>四. 异常类与异常对象</h2><ol><li><h3 id="精心设计异常类，提供必要的异常信息"><a href="#精心设计异常类，提供必要的异常信息" class="headerlink" title="精心设计异常类，提供必要的异常信息"></a>精心设计异常类，提供必要的异常信息</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DivisorIsZero</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> dividend;   <span class="comment">//被除数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DivisorIsZero(<span class="keyword">int</span> i):dividend(i)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetDividend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dividend;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;<span class="comment">//异常类，除数为零</span></span><br></pre></td></tr></table></figure></li><li><h3 id="构造异常对象并抛出"><a href="#构造异常对象并抛出" class="headerlink" title="构造异常对象并抛出"></a>构造异常对象并抛出</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calculator::divide</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;<span class="comment">//引发除数为零异常，构造该异常类的一个对象并抛出</span></span><br><span class="line">        <span class="keyword">throw</span> DivisorIsZero(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="使用异常对象获取详细信息"><a href="#使用异常对象获取详细信息" class="headerlink" title="使用异常对象获取详细信息"></a>使用异常对象获取详细信息</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cal.divide();<span class="comment">//可能引发异常的函数调用</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">const</span> DivisorIsZero &amp; e) &#123;<span class="comment">//捕获抛出的异常，执行相应处理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error:divisor is zero.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//注意这里e是常引用，只能调用常成员函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dividend is &quot;</span> &lt;&lt; e.GetDividend() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="五-异常处理策略"><a href="#五-异常处理策略" class="headerlink" title="五. 异常处理策略"></a>五. 异常处理策略</h2><ol><li><h3 id="异常类可以派生和继承，形成类库架构"><a href="#异常类可以派生和继承，形成类库架构" class="headerlink" title="异常类可以派生和继承，形成类库架构"></a>异常类可以派生和继承，形成类库架构</h3></li></ol><ul><li>定义一个异常基类，里面一个打印虚函数</li><li>catch基类引用，调用打印函数，可以发生多态</li><li>C++所有系统标准异常的基类就是exception</li><li>继承exception编写自己的异常类时，需要注意<ul><li>const char* 可以隐式转换为string</li><li>反过来不行，可以通过string的.c_str()方法，返回一个const char*</li></ul></li></ul><ol start="2"><li><h3 id="可捕获的异常对象的型式"><a href="#可捕获的异常对象的型式" class="headerlink" title="可捕获的异常对象的型式"></a>可捕获的异常对象的型式</h3></li></ol><ul><li>普通型式（包括类）：异常对象需要拷贝</li><li>对某型式对象的引用：没有额外的拷贝动作</li><li>指向某型式对象的指针：要求对象动态构造或在catch子句中可访问</li></ul><ol start="3"><li><h3 id="catch子句"><a href="#catch子句" class="headerlink" title="catch子句"></a>catch子句</h3></li></ol><ul><li>可以有多个catch子句，每个负责捕获一种，一类或全部异常</li><li>捕获一种：catch(int),catch(const char *)</li><li>捕获一类（该类或其派生类异常）：catch(const DivisorIsZero &amp;)</li><li>捕获全部：catch(…)</li><li>所有catch子句按照定义顺序执行，因此派生异常类处理必须定义在基类之前，否则不会被执行</li></ul><ol start="4"><li><h3 id="异常再引发"><a href="#异常再引发" class="headerlink" title="异常再引发"></a>异常再引发</h3></li></ol><ul><li>可以在基本任务完成后重新引发所处理的异常</li><li>主要用于在程序终止前写入日志和实施特殊清除任务  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> AnException();</span><br><span class="line">&#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">throw</span>;  <span class="comment">//这里抛出的就是catch到的异常类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><h3 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h3></li></ol><ul><li>从try开始，到throw抛出异常前，所有栈上的对象都被自动调用析构函数，释放的顺序与构造相反，创建的堆区内存不会回收，造成内存泄漏</li></ul><ol start="6"><li><h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><blockquote><p><a href="https://www.cnblogs.com/zhuyf87/archive/2012/12/23/2829725.html">https://www.cnblogs.com/zhuyf87/archive/2012/12/23/2829725.html</a></p></blockquote><p> <strong>抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。首先检查throw本身是否在try块内部，如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。这个过程称为栈展开（stack unwinding）。</strong></p></li></ol><ul><li><p>为局部对象调用析构函数</p><p>  如上所述，在栈展开的过程中，会释放局部对象所占用的内存并运行类类型局部对象的析构函数。但需要注意的是，如果一个块通过new动态分配内存，并且在释放该资源之前发生异常，该块因异常而退出，那么在栈展开期间不会释放该资源，编译器不会删除该指针，这样就会造成<strong>内存泄露</strong>。</p></li><li><p>析构函数应该从不抛出异常</p><p>  在为某个异常进行栈展开的时候，析构函数如果又抛出自己的未经处理的另一个异常，将会导致调用标准库terminate函数。通常terminate函数将调用abort函数，导致程序的非正常退出。所以析构函数应该从不抛出异常。</p></li><li><p>异常与构造函数</p><p>  如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，要保证能够适当的撤销这些已构造的成员。</p></li><li><p>未捕获的异常将会终止程序</p><p>  不能不处理异常。如果找不到匹配的catch，程序就会调用库函数terminate。</p></li></ul><ol start="7"><li><h3 id="未处理异常"><a href="#未处理异常" class="headerlink" title="未处理异常"></a>未处理异常</h3></li></ol><ul><li>所有未处理异常由预定义的std::terminate()函数处理</li><li>可以使用std::set_terminate()函数设置std::terminate()函数的处理例程  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">term_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        set_terminate(term_func);</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Error!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">int</span>)&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li><h3 id="描述函数是否引发异常"><a href="#描述函数是否引发异常" class="headerlink" title="描述函数是否引发异常"></a>描述函数是否引发异常</h3></li></ol><ul><li><p>否：throw()</p></li><li><p>是，引发任意类型的异常：throw(…)</p></li><li><p>是，只能引发某类异常，抛别的会崩：throw(T)，部分编译器将其作为throw(…)，也可以写throw(T1,T2)</p><p>  <strong>C++11规范</strong></p></li><li><p>否：noexcept，等价于noexcept(true)</p></li><li><p>是：noexcept(false)</p></li><li><p>可能：noexcept(noexcept(expr)),expr为可转换为true或false的常数表达式</p></li><li><p>C++11下，建议使用noexcept代替throw</p></li></ul><h2 id="六-异常描述规范"><a href="#六-异常描述规范" class="headerlink" title="六. 异常描述规范"></a>六. 异常描述规范</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DivisorIsZero</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> dividend;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">DivisorIsZero(<span class="keyword">int</span> i):dividend(i)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDividend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dividend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">()</span> <span class="title">throw</span><span class="params">(DivisorIsZero)</span></span>;<span class="comment">//函数声明和定义都要写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calculator::divide</span><span class="params">()</span> <span class="title">throw</span><span class="params">(DivisorIsZero)</span></span>&#123;<span class="comment">//函数声明和定义都要写</span></span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> DivisorIsZero(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流与文件</title>
      <link href="2020/02/09/C++/%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6/"/>
      <url>2020/02/09/C++/%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-标准流类库"><a href="#1-标准流类库" class="headerlink" title="1. 标准流类库"></a>1. 标准流类库</h2><p><strong>流：数据从源到目的的流动</strong></p><h3 id="1-1-输入输出流类"><a href="#1-1-输入输出流类" class="headerlink" title="1.1 输入输出流类"></a>1.1 输入输出流类</h3><ol><li>输入输出流：iostream</li><li>输入流：istream</li><li>输出流：ostream</li></ol><h3 id="1-2-字符串流类"><a href="#1-2-字符串流类" class="headerlink" title="1.2 字符串流类"></a>1.2 字符串流类</h3><ol><li>输入输出字符串流：strstream</li><li>输入字符串流：istrstream</li><li>输出字符串流：ostrstream</li></ol><h3 id="1-3-文件流类"><a href="#1-3-文件流类" class="headerlink" title="1.3 文件流类"></a>1.3 文件流类</h3><ol><li>输出文件流：ofstream</li><li>输入文件流：ifstream</li><li>输入输出文件流：fstream</li></ol><h3 id="1-4-全局流对象"><a href="#1-4-全局流对象" class="headerlink" title="1.4 全局流对象"></a>1.4 全局流对象</h3><ol><li>std::cout：标准输出流对象，一般对应标准输出设备</li><li>std::cin：标准输入流对象，一般对应标准输入设备</li><li>std::cerr：标准错误流对象，一般对应标准错误输出设备</li><li>std::clog：标准日志流对象，一般对应标准日志输出设备</li></ol><p><strong>std::cout、std::cerr与std::clog为std::ostream类的对象；std::cin为std::istream类的对象</strong></p><h3 id="1-5-插入与提取"><a href="#1-5-插入与提取" class="headerlink" title="1.5 插入与提取"></a>1.5 插入与提取</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li>目的：将数据对象插入到流中</li><li>插入操作符也称输出操作符</li><li>std::cout &lt;&lt; “Hello World!”; 将字符串插入到输出流</li></ul><h4 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h4><ul><li>从流中提取数据对象</li><li>提取操作符也称输入操作符</li><li>int a; std::cin &gt;&gt; a; 从输入流中提取整数</li></ul><p><strong>注意：因为流可能被重定向或束定，有时使用输入输出描述流操作可能会让人迷惑</strong></p><h3 id="1-6-常用输入输出流函数"><a href="#1-6-常用输入输出流函数" class="headerlink" title="1.6 常用输入输出流函数"></a>1.6 常用输入输出流函数</h3><ol><li>判断流是否已结束：<code>cin.eof()</code></li><li>读取单个字符：<code>cin.get( istream::char_type &amp; c )</code></li><li>读取字符串：<code>cin.get( istream::char_type * s, streamsize n, istream::char_type delimiter = &#39;\n&#39; )</code></li><li>读取单行文本：<code>cin.getline( istream::char_type * s, streamsize n, istream::char_type delimiter = &#39;\n&#39; )</code></li><li>输出单个字符：<code>cout.put( ostream::char_type c )</code></li></ol><h2 id="2-流格式"><a href="#2-流格式" class="headerlink" title="2. 流格式"></a>2. 流格式</h2><h3 id="2-1-流格式标志"><a href="#2-1-流格式标志" class="headerlink" title="2.1 流格式标志"></a>2.1 流格式标志</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ios_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> fmtflags;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    left = <span class="number">0x0001</span>,  right = <span class="number">0x0002</span>,  internal = <span class="number">0x0004</span>,</span><br><span class="line">    dec = <span class="number">0x0008</span>,  hex = <span class="number">0x0010</span>,  oct = <span class="number">0x0020</span>,</span><br><span class="line">    fixed = <span class="number">0x0040</span>,  scientific = <span class="number">0x0080</span>,  boolalpha = <span class="number">0x0100</span>,</span><br><span class="line">    showbase = <span class="number">0x0200</span>,  showpoint = <span class="number">0x0400</span>,  showpos = <span class="number">0x0800</span>,</span><br><span class="line">    skipws = <span class="number">0x1000</span>,  unitbuf = <span class="number">0x2000</span>,  uppercase = <span class="number">0x4000</span>,</span><br><span class="line">    adjustfield = left | right | internal,</span><br><span class="line">    basefield = dec | oct | hex,</span><br><span class="line">    floatfield = scientific | fixed</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-位掩码"><a href="#2-2-位掩码" class="headerlink" title="2.2 位掩码"></a>2.2 位掩码</h3><ul><li>使用32位整数的位代表流格式标志：ios_base::fmtflags</li><li>每个标志位可单独设置与清除</li></ul><h3 id="2-3-设置预定义标志位"><a href="#2-3-设置预定义标志位" class="headerlink" title="2.3 设置预定义标志位"></a>2.3 设置预定义标志位</h3><ul><li><code>cout.setf( ios_base::showbase );</code> 输出整数前缀，十六进制前添加“0x”</li></ul><h3 id="2-4-清除预定义标志位"><a href="#2-4-清除预定义标志位" class="headerlink" title="2.4 清除预定义标志位"></a>2.4 清除预定义标志位</h3><ul><li><code>cout.unsetf( ios_base::showbase );</code> 清除上述标志</li></ul><h3 id="2-5-位组：特定标志位集合，位组中的标志位互相排斥"><a href="#2-5-位组：特定标志位集合，位组中的标志位互相排斥" class="headerlink" title="2.5 位组：特定标志位集合，位组中的标志位互相排斥"></a>2.5 位组：特定标志位集合，位组中的标志位互相排斥</h3><ul><li>ios_base::adjustfield、ios_base::basefield与ios_base::floatfield</li><li><code>cout.setf( ios_base::hex, ios_base::basefield );</code> 设置十六进制输出格式，使用单参数版本无效果</li></ul><h3 id="2-6-设置用户自定义参数：单参数版本"><a href="#2-6-设置用户自定义参数：单参数版本" class="headerlink" title="2.6 设置用户自定义参数：单参数版本"></a>2.6 设置用户自定义参数：单参数版本</h3><ul><li>设置时传递用户指定值</li><li><code>std::cout.width( 8 );</code> 将最小输出宽度定为8个字符</li><li><code>std::cout.precision( 8 );</code> 将输出精度定为8位</li><li><code>std::cout.fill( &#39;?&#39; );</code> 使用‘?’填充空白字符位置</li></ul><h3 id="2-7-获取用户自定义参数：无参数版本"><a href="#2-7-获取用户自定义参数：无参数版本" class="headerlink" title="2.7 获取用户自定义参数：无参数版本"></a>2.7 获取用户自定义参数：无参数版本</h3><ul><li>获得当前的输出精度值：<code>std::streamsize precision = std::cout.precision();</code></li></ul><h2 id="3-操纵符"><a href="#3-操纵符" class="headerlink" title="3. 操纵符"></a>3. 操纵符</h2><h3 id="3-1-操纵符的目的：控制流的输入输出格式"><a href="#3-1-操纵符的目的：控制流的输入输出格式" class="headerlink" title="3.1 操纵符的目的：控制流的输入输出格式"></a>3.1 操纵符的目的：控制流的输入输出格式</h3><ul><li>无参数操纵符：函数指针</li><li>单参数操纵符：函子，即带有函数指针功能的操纵符类的对象，实现上为重载了函数调用操作符的操纵符类</li></ul><h3 id="3-2-操纵符示例"><a href="#3-2-操纵符示例" class="headerlink" title="3.2 操纵符示例"></a>3.2 操纵符示例</h3><ul><li>头文件：“iomanip”</li><li><code>std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;</code></li><li><code>int n = 1024;  std::cout &lt;&lt; std::dec &lt;&lt; n &lt;&lt; &#39;\n&#39; &lt;&lt; std::hex &lt;&lt; n &lt;&lt; std::endl;</code></li></ul><h3 id="3-3-预定义操纵符"><a href="#3-3-预定义操纵符" class="headerlink" title="3.3 预定义操纵符"></a>3.3 预定义操纵符</h3><table><thead><tr><th align="center">操纵符</th><th align="center">I/O</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">std::boolalpha</td><td align="center">I/O</td><td align="center">字符格式的bool值</td></tr><tr><td align="center">std::dec</td><td align="center">I/O</td><td align="center">十进制</td></tr><tr><td align="center">std::endl</td><td align="center">O</td><td align="center">插入换行符并刷新流缓冲区</td></tr><tr><td align="center">std::ends</td><td align="center">O</td><td align="center">插入字符串结束符</td></tr><tr><td align="center">std::fixed</td><td align="center">O</td><td align="center">使用定点数格式表示浮点数</td></tr><tr><td align="center">std::flush</td><td align="center">O</td><td align="center">刷新流缓冲区</td></tr><tr><td align="center">std::hex</td><td align="center">I/O</td><td align="center">十六进制</td></tr><tr><td align="center">std::internal</td><td align="center">O</td><td align="center">在内部填充字符</td></tr><tr><td align="center">std::left</td><td align="center">O</td><td align="center">左对齐，右边多余部分使用填充字符填充</td></tr><tr><td align="center">std::noboolalpha</td><td align="center">I/O</td><td align="center">复位std::boolalpha设置</td></tr><tr><td align="center">std::noshowbase</td><td align="center">O</td><td align="center">复位std::showbase设置</td></tr><tr><td align="center">std::noshowpoint</td><td align="center">O</td><td align="center">复位std::showpoint设置</td></tr><tr><td align="center">std::noshowpos</td><td align="center">O</td><td align="center">复位std::showpos设置</td></tr><tr><td align="center">std::noskipws</td><td align="center">I</td><td align="center">复位std::skipws设置</td></tr><tr><td align="center">std::nounitbuf</td><td align="center">O</td><td align="center">复位std::unitbuf设置</td></tr><tr><td align="center">std::nouppercase</td><td align="center">O</td><td align="center">复位std::uppercase设置</td></tr><tr><td align="center">std::oct</td><td align="center">I/O</td><td align="center">八进制</td></tr><tr><td align="center">std::right</td><td align="center">O</td><td align="center">右对齐，左边多余部分使用填充字符填充</td></tr><tr><td align="center">std::resetiosflag(std::ios_base::fmtflags mask)</td><td align="center">I/O</td><td align="center">复位格式标志</td></tr><tr><td align="center">std::scientific</td><td align="center">O</td><td align="center">使用科学计数法表示浮点数</td></tr><tr><td align="center">std::setbase(int base)</td><td align="center">I/O</td><td align="center">设置整数的基（进制），可能为8、10或16</td></tr><tr><td align="center">std::setfill(std::basic_ios::char_type c)</td><td align="center">I/O</td><td align="center">设置填充字符</td></tr><tr><td align="center">std::setiosflag(std::ios_base::fmtflags mask)</td><td align="center">I/O</td><td align="center">设置格式标志</td></tr><tr><td align="center">std::setprecision(int n)</td><td align="center">O</td><td align="center">设置数值精度</td></tr><tr><td align="center">std::setw(int n)</td><td align="center">I/O</td><td align="center">设置最小字段宽度</td></tr><tr><td align="center">std::showbase</td><td align="center">O</td><td align="center">输出整数前缀，十六进制前添加“0x”</td></tr><tr><td align="center">std::showpoint</td><td align="center">O</td><td align="center">浮点数输出时强制显示小数点</td></tr><tr><td align="center">std::showpos</td><td align="center">O</td><td align="center">设置非负整数显示正号标志</td></tr><tr><td align="center">std::skipws</td><td align="center">I</td><td align="center">设置忽略空格标志</td></tr><tr><td align="center">std::unitbuf</td><td align="center">O</td><td align="center">每次格式化操作后都刷新流缓冲区</td></tr><tr><td align="center">std::uppercase</td><td align="center">O</td><td align="center">数值格式化输出时使用大写字母</td></tr><tr><td align="center">std::ws</td><td align="center">I</td><td align="center">忽略空格</td></tr></tbody></table><h2 id="4-文件流"><a href="#4-文件流" class="headerlink" title="4. 文件流"></a>4. 文件流</h2><h3 id="4-1-文件特性"><a href="#4-1-文件特性" class="headerlink" title="4.1 文件特性"></a>4.1 文件特性</h3><ul><li>文件一般保存在外部存储设备上</li><li>文件生命周期可能远远超过创建它的程序本身</li></ul><h3 id="4-2-文件操作：读、写"><a href="#4-2-文件操作：读、写" class="headerlink" title="4.2 文件操作：读、写"></a>4.2 文件操作：读、写</h3><ul><li>一般使用文件指针，该指针代表文件的当前访问位置</li><li>老式的C语言使用文件句柄（handle）或文件描述符（file descriptor）表示某个打开的文件数据对象</li></ul><h3 id="4-3-文件流的使用"><a href="#4-3-文件流的使用" class="headerlink" title="4.3 文件流的使用"></a>4.3 文件流的使用</h3><ul><li>头文件：“fstream”</li><li>按照特定格式重载类的流操作符</li><li>创建文件流对象，输入输出</li></ul><h3 id="4-4-文件打开模式"><a href="#4-4-文件打开模式" class="headerlink" title="4.4 文件打开模式"></a>4.4 文件打开模式</h3><ul><li>std::ios_base::app：每次插入都定位到文件流的尾部</li><li>std::ios_base::binary：使用二进制而不是文本格式打开文件流</li><li>std::ios_base::in：流用于输入目的，允许提取，此为std::ifstream流缺省设置</li><li>std::ios_base::out：流用于输出目的，允许插入，此为std::ofstream流缺省设置</li><li>std::ios_base::trunc：若文件存在，清除文件内容，此为std::ofstream流缺省设置</li><li>std::ios_base::ate：若文件存在，定位到文件尾部文件一般保存在外部存储设备上</li></ul><h2 id="5-流状态"><a href="#5-流状态" class="headerlink" title="5. 流状态"></a>5. 流状态</h2><h3 id="5-1-流状态：表示操作成功或失败的状态信息"><a href="#5-1-流状态：表示操作成功或失败的状态信息" class="headerlink" title="5.1 流状态：表示操作成功或失败的状态信息"></a>5.1 流状态：表示操作成功或失败的状态信息</h3><ul><li>std::ios_base::goodbit：流完好无损</li><li>std::ios_base::badbit：流已出现致命错误，一般无法恢复</li><li>std::ios_base::eofbit：流结束时设置</li><li>std::ios_base::failbit：流操作失败时设置，可能恢复</li></ul><h3 id="5-2-流状态对流操作行为的影响"><a href="#5-2-流状态对流操作行为的影响" class="headerlink" title="5.2 流状态对流操作行为的影响"></a>5.2 流状态对流操作行为的影响</h3><ul><li>一旦流状态存在错误，所有I/O操作都失效</li><li>在出现std::ios_base::failbit与std::ios_base::badbit状态时，输出操作立即停止</li><li>在非std::ios_base::goodbit状态时，输入操作立即停止</li></ul><h3 id="5-3-流状态测试"><a href="#5-3-流状态测试" class="headerlink" title="5.3 流状态测试"></a>5.3 流状态测试</h3><ul><li>bool std::ios_base::good() const：没有出现任何错误时返回真</li><li>bool std::ios_base::eof() const：设置std::ios_base::eofbit状态时返回真</li><li>bool std::ios_base::fail() const：设置std::ios_base::failbit状态时返回真</li><li>bool std::ios_base::bad() const：设置std::ios_base::badbit状态时返回真</li><li>bool std::ios_base::operator !() const：与std::ios_base::fail() 效果相同</li><li>std::ios_base::operator void*() const：std::ios_base::fail() 为真时返回空指针，否则非空</li></ul><h2 id="6-流定位"><a href="#6-流定位" class="headerlink" title="6. 流定位"></a>6. 流定位</h2><h3 id="6-1-流位置指针"><a href="#6-1-流位置指针" class="headerlink" title="6.1 流位置指针"></a>6.1 流位置指针</h3><ul><li>位置指针指向下一次读写操作时的数据对象在流中的位置，该指针会随着输入输出操作而不断变化</li><li>单向流：一个位置指针；双向流：两个位置指针</li></ul><h3 id="6-2-流位置指针的获取"><a href="#6-2-流位置指针的获取" class="headerlink" title="6.2 流位置指针的获取"></a>6.2 流位置指针的获取</h3><ul><li>成员函数tellp()：获取当前的流位置指针（写指针）</li><li>成员函数tellg()：获取当前的流位置指针（读指针）</li></ul><h3 id="6-3-流位置指针的定位"><a href="#6-3-流位置指针的定位" class="headerlink" title="6.3 流位置指针的定位"></a>6.3 流位置指针的定位</h3><ul><li>成员函数seekp()：将文件位置指针定位到某个特定位置，用于插入（输出）目的</li><li>成员函数seekg()：将文件位置指针定位到某个特定位置，用于提取（输入）目的的定位</li></ul><h3 id="6-4-流定位函数seekp-与seekg"><a href="#6-4-流定位函数seekp-与seekg" class="headerlink" title="6.4 流定位函数seekp()与seekg()"></a>6.4 流定位函数seekp()与seekg()</h3><ul><li>单参数版本：可以使用获取的位置指针</li><li>双参数版本：第一个参数为偏移量；第二个参数为定位基准</li></ul><h3 id="6-5-定位基准"><a href="#6-5-定位基准" class="headerlink" title="6.5 定位基准"></a>6.5 定位基准</h3><ul><li>std::ios_base::beg：从流的开始位置开始计算偏移量</li><li>std::ios_base::cur：从当前位置开始计算偏移量</li><li>std::ios_base::end：从流的结束位置开始计算偏移量</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li><h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3></li></ol><ul><li>cin.get(); 一次只能读取一个字符</li><li>cin.get(buf,sizeof(buf)); 读取字符串，换行符会遗留在缓冲区中</li><li>cin.getline(buf,sizeof(buf)); 读取字符串，换行符不会遗留在缓冲区中，也不会读入</li><li>cin.ignore(); 默认忽略1个缓冲区的字符，可以填写忽略个数</li><li>cin.peek(); 查看缓冲区第一个字符，不取走</li><li>cin.putback(c); 将字符放回缓冲区，并且放回原位 </li><li>cin.fail(); 查看缓冲区标志位，0为正常，1为异常，比如int n; cin &gt;&gt; n; 但是缓冲区之只能读到字符，标志位就会异常</li><li>cin.clear(); 重置标志位</li><li>cin.syna(); 清空缓冲区</li></ul><ol start="2"><li><h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3></li></ol><ul><li>cout.put(); 向缓冲区写字符</li><li>cout.write(buf,sizeof(buf)); 从buf中写n个字节到当前输出流</li><li>通过流成员函数格式化输出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">10</span>); <span class="comment">//设置宽度</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">&#x27;*&#x27;</span>); <span class="comment">//填充</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::left);  <span class="comment">//设置左对齐格式</span></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::dec); <span class="comment">//卸载十进制</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::hex);  <span class="comment">//设置十六进制   63</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::showbase); <span class="comment">//显示基数 0x (十六进制)  0 （八进制）</span></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::hex); <span class="comment">//卸载十六进制</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::oct);  <span class="comment">//设置八进制  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li>通过控制符格式化输出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">20</span>)   <span class="comment">//设置宽度</span></span><br><span class="line"> &lt;&lt; setfill(<span class="string">&#x27;~&#x27;</span>) <span class="comment">//填充</span></span><br><span class="line"> &lt;&lt; setiosflags(ios::showbase) <span class="comment">//显示基数</span></span><br><span class="line"> &lt;&lt; setiosflags(ios::left)  <span class="comment">//左对齐</span></span><br><span class="line"> &lt;&lt; hex  <span class="comment">//设置十六进制</span></span><br><span class="line"> &lt;&lt; n</span><br><span class="line"> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3></li></ol><ul><li>#include <fstream></li><li>写文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;./test.txt&quot;</span>,ios::out | ios::trunc)</span></span>;</span><br><span class="line"><span class="comment">//上下二者都可以</span></span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断对象是否打开成功</span></span><br><span class="line"><span class="keyword">if</span> (!ofs.is_open()) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：Tom&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：100&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭对象</span></span><br><span class="line">ofs.close();</span><br></pre></td></tr></table></figure></li><li>读文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(<span class="string">&quot;./test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;  <span class="comment">//也是按行读</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (ifs.getline(buf,<span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方式</span></span><br><span class="line"><span class="built_in">string</span> buf;</span><br><span class="line"><span class="keyword">while</span> (getline(ifs,buf)) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种方式  不推荐</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.get()) != EOF) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作符重载函数原型列表</title>
      <link href="2020/02/09/C++/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%88%97%E8%A1%A8/"/>
      <url>2020/02/09/C++/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-普通四则运算"><a href="#1-普通四则运算" class="headerlink" title="1. 普通四则运算"></a>1. 普通四则运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> + ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> - ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> * ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> / ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> % ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> * ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> <span class="keyword">int</span> &amp; rhs ); <span class="comment">//  标量运算，如果存在</span></span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> * ( <span class="keyword">const</span> <span class="keyword">int</span> &amp; lhs, <span class="keyword">const</span> A &amp; rhs ); <span class="comment">//  标量运算，如果存在</span></span><br></pre></td></tr></table></figure><h2 id="2-关系操作符"><a href="#2-关系操作符" class="headerlink" title="2. 关系操作符"></a>2. 关系操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> == ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs ); </span><br><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> != ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> &lt;= ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> &gt; ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> &gt;= ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br></pre></td></tr></table></figure><h2 id="3-逻辑操作符"><a href="#3-逻辑操作符" class="headerlink" title="3. 逻辑操作符"></a>3. 逻辑操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> || ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">friend</span>  <span class="keyword">bool</span>  <span class="keyword">operator</span> &amp;&amp; ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line"><span class="keyword">bool</span>  A::<span class="keyword">operator</span> ! ();</span><br></pre></td></tr></table></figure><h2 id="4-正负操作符"><a href="#4-正负操作符" class="headerlink" title="4. 正负操作符"></a>4. 正负操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A  A::<span class="keyword">operator</span> + ();    <span class="comment">//  取正</span></span><br><span class="line">A  A::<span class="keyword">operator</span> - ();   <span class="comment">//  取负</span></span><br></pre></td></tr></table></figure><h2 id="5-递增递减操作符"><a href="#5-递增递减操作符" class="headerlink" title="5. 递增递减操作符"></a>5. 递增递减操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &amp;  A::<span class="keyword">operator</span> ++ ();<span class="comment">//  前缀递增</span></span><br><span class="line">A  A::<span class="keyword">operator</span> ++ ( <span class="keyword">int</span> );<span class="comment">//  后缀递增</span></span><br><span class="line">A &amp;  A::<span class="keyword">operator</span> --();<span class="comment">//  前缀递减</span></span><br><span class="line">A  A::<span class="keyword">operator</span> -- ( <span class="keyword">int</span> );<span class="comment">//  后缀递减</span></span><br></pre></td></tr></table></figure><h2 id="6-位操作符"><a href="#6-位操作符" class="headerlink" title="6. 位操作符"></a>6. 位操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> | ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );   <span class="comment">//  位与</span></span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> &amp; ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );    <span class="comment">//  位或</span></span><br><span class="line"><span class="keyword">friend</span>  A  <span class="keyword">operator</span> ^ ( <span class="keyword">const</span> A &amp; lhs, <span class="keyword">const</span> A &amp; rhs );   <span class="comment">//  位异或</span></span><br><span class="line">A  A::<span class="keyword">operator</span> &lt;&lt; ( <span class="keyword">int</span> n );    <span class="comment">//  左移</span></span><br><span class="line">A  A::<span class="keyword">operator</span> &gt;&gt; ( <span class="keyword">int</span> n );    <span class="comment">//  右移</span></span><br><span class="line">A  A::<span class="keyword">operator</span> ~ ();  <span class="comment">// 位反</span></span><br></pre></td></tr></table></figure><h2 id="7-动态存储管理操作符：全局或成员函数均可"><a href="#7-动态存储管理操作符：全局或成员函数均可" class="headerlink" title="7. 动态存储管理操作符：全局或成员函数均可"></a>7. 动态存储管理操作符：全局或成员函数均可</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *  <span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> size )</span>  <span class="title">throw</span><span class="params">( bad_alloc )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *  <span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span> &amp; )</span>  <span class="title">throw</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *  <span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="keyword">void</span> * base )</span>  <span class="title">throw</span><span class="params">( )</span></span>; </span><br><span class="line"><span class="keyword">void</span> *  <span class="keyword">operator</span> <span class="keyword">new</span>[]( <span class="built_in">std</span>::<span class="keyword">size_t</span> size )  <span class="keyword">throw</span>( bad_alloc );</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">( <span class="keyword">void</span> * p )</span></span>;</span><br><span class="line"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[]( <span class="keyword">void</span> * p );</span><br></pre></td></tr></table></figure><h2 id="8-赋值操作符"><a href="#8-赋值操作符" class="headerlink" title="8. 赋值操作符"></a>8. 赋值操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A &amp;  <span class="keyword">operator</span> = ( A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> = ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> = ( A &amp;&amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> += ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> -= ( <span class="keyword">const</span> A &amp; rhs ); </span><br><span class="line">A &amp;  <span class="keyword">operator</span> *= ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> /= ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> %= ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> &amp;= ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> |= ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> ^= ( <span class="keyword">const</span> A &amp; rhs );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> &lt;&lt;= ( <span class="keyword">int</span> n );</span><br><span class="line">A &amp;  <span class="keyword">operator</span> &gt;&gt;= ( <span class="keyword">int</span> n );</span><br></pre></td></tr></table></figure><h2 id="9-下标操作符"><a href="#9-下标操作符" class="headerlink" title="9. 下标操作符"></a>9. 下标操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T &amp;  A::<span class="keyword">operator</span> [] ( <span class="keyword">int</span> i );</span><br><span class="line"><span class="keyword">const</span> T &amp;  A::<span class="keyword">operator</span> [] ( <span class="keyword">int</span> i ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><h2 id="10-函数调用操作符"><a href="#10-函数调用操作符" class="headerlink" title="10. 函数调用操作符"></a>10. 函数调用操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T  <span class="title">A::operator</span> <span class="params">()</span> <span class="params">( … )</span></span>;    <span class="comment">//  参数可选</span></span><br></pre></td></tr></table></figure><h2 id="11-类型转换操作符"><a href="#11-类型转换操作符" class="headerlink" title="11. 类型转换操作符"></a>11. 类型转换操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="keyword">operator</span> <span class="keyword">char</span> * ()  <span class="keyword">const</span>;</span><br><span class="line"><span class="function">A::<span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span>  <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">A::<span class="keyword">operator</span> <span class="title">double</span> <span class="params">()</span>  <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="12-逗号操作符"><a href="#12-逗号操作符" class="headerlink" title="12. 逗号操作符"></a>12. 逗号操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T2  <span class="keyword">operator</span> , ( T1 t1, T2 t2 );    <span class="comment">//  不建议重载</span></span><br></pre></td></tr></table></figure><h2 id="13-指针与选员操作符"><a href="#13-指针与选员操作符" class="headerlink" title="13. 指针与选员操作符"></a>13. 指针与选员操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A *  A::<span class="keyword">operator</span> &amp; ( );    <span class="comment">//  取址操作符</span></span><br><span class="line">A &amp;  A::<span class="keyword">operator</span> * ( );    <span class="comment">//  引领操作符</span></span><br><span class="line"><span class="keyword">const</span> A &amp;  A::<span class="keyword">operator</span> * ( )  <span class="keyword">const</span>;    <span class="comment">//  引领操作符</span></span><br><span class="line">C *  A::<span class="keyword">operator</span> -&gt; ( );    <span class="comment">//  选员操作符</span></span><br><span class="line"><span class="keyword">const</span> C *  A::<span class="keyword">operator</span> -&gt; ( )  <span class="keyword">const</span>;    <span class="comment">//  选员操作符</span></span><br><span class="line">C &amp;  A::<span class="keyword">operator</span> -&gt;* ( … );    <span class="comment">//  选员操作符，指向类成员的指针</span></span><br></pre></td></tr></table></figure><h2 id="14-流操作符"><a href="#14-流操作符" class="headerlink" title="14. 流操作符"></a>14. 流操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  ostream &amp;  <span class="keyword">operator</span> &lt;&lt; ( ostream &amp; os, <span class="keyword">const</span> A &amp; a );</span><br><span class="line"><span class="keyword">friend</span>  istream &amp;  <span class="keyword">operator</span> &gt;&gt; ( istream &amp; is, A &amp; a );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动语义与右值引用</title>
      <link href="2020/02/08/C++/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>2020/02/08/C++/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-赋值构造和拷贝构造"><a href="#1-赋值构造和拷贝构造" class="headerlink" title="1. 赋值构造和拷贝构造"></a>1. 赋值构造和拷贝构造</h2><p><strong>赋值也是构造。</strong></p><p>拷贝、赋值、析构三位一体，一般同时出现</p><ul><li>缺省赋值构造与拷贝构造为浅拷贝</li><li>如果对象没有指针成员，缺省行为即可满足要求，无需实现或重载这三个函数</li><li>如果对象有指针成员，一般需要重载这三个函数</li></ul><h2 id="2-浅拷贝、深拷贝、移动语义"><a href="#2-浅拷贝、深拷贝、移动语义" class="headerlink" title="2. 浅拷贝、深拷贝、移动语义"></a>2. 浅拷贝、深拷贝、移动语义</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p><img src="/photo/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="浅拷贝" title="浅拷贝" loading="lazy"></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p><img src="/photo/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt="深拷贝" title="深拷贝" loading="lazy"></p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p><img src="/photo/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89.png" alt="移动语义" title="移动语义" loading="lazy"></p><h2 id="3-左值、右值"><a href="#3-左值、右值" class="headerlink" title="3. 左值、右值"></a>3. 左值、右值</h2><blockquote><p><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html">参考原文链接</a></p></blockquote><ol><li><strong>什么是表达式？</strong></li></ol><p>表达式是由运算符和运算对象构成的计算式，字面值和变量是最简单的表达式，函数的返回值也被认为是表达式。</p><ol start="2"><li><strong>什么是值类别？</strong></li></ol><p>表达式是可求值的，对表达式求值得到一个结果，这个结果有两个属性：<strong>类型</strong>和<strong>值类别</strong>。</p><p>在C++11以后，表达式按值类别分，必须属于一下三者之一：<strong>左值</strong>，<strong>将亡值</strong>，<strong>纯右值</strong>。其中，左值和将亡值合称<strong>泛左值</strong>，纯右值和将亡值合称<strong>右值</strong>。</p><p>严格来讲，”左值”是表达式的一种属性，但我们通常用”左值”指代左值表达式，即求值结果的值类别为左值的表达式。对于将亡值与纯右值亦然。</p><ol start="3"><li><strong>左值、将亡值、纯右值的区别</strong></li></ol><ul><li><p><strong>左值</strong></p></li><li><p>描述：</p><ul><li>能够用&amp;取地址的表达式是左值表达式。</li></ul></li><li><p>举例：</p><ul><li>函数指针、具名变量(std::cin,std::endl)、返回左值引用的函数调用、前置自增自减运算符连接的表达式(++i,–i)、由赋值运算符或复合赋值运算符连接的表达式(a=b,a+=b)、解引用表达式(就是指针取值*p)、字符串字面值(“hello”)等。</li></ul></li><li><p><strong>纯右值</strong></p></li><li><p>描述：</p><ul><li>满足下列条件之一<ol><li>本身就是字面值如1,2,3,false等。</li><li>求值结果相当于字面值或是一个不具名的临时对象。</li></ol></li></ul></li><li><p>举例：</p><ul><li>除字符串字面值以外的字面值、返回非引用类型的函数调用、后置自增自减运算符连接的表达式(i++,i–)、算术表达式(a+b,a&amp;b,a&lt;&lt;b)、逻辑表达式(a&amp;&amp;b,~a)、比较表达式(a==b,a&gt;b)、取地址表达式(&amp;a)等。</li></ul></li><li><p><strong>将亡值</strong></p></li><li><p>描述:</p><ul><li><p>在C++11以前的右值和C++11中的纯右值是等价的。C++11中的将亡值是随着<strong>右值引用</strong>的引入而新引入的。所谓将亡值表达式就是下列表达式。</p><ol><li>返回右值引用的函数的调用表达式。</li><li>转换为右值引用的转换函数的调用表达式。</li></ol></li><li><p>在C++11中，我们用左值去初始化一个对象或为一个已有对象赋值时，会调用拷贝构造函数或拷贝赋值运算符来拷贝资源，而当我们用一个右值来初始化或赋值时，会调用移动构造函数或移动赋值运算符来移动资源，从而避免拷贝，提高效率。当该右值完成初始化或赋值的任务时，它的资源已经移动给了被初始化者或被赋值者，同时该右值也将会马上被销毁。也就是说，当一个右值准备完成初始化或赋值任务时，它已经”将亡”了。而上面1和2两种表达式的结果都是不具名的右值引用，他们属于右值，故C++11为这类右值命名”将亡值”。</p></li></ul></li><li><p>举例：</p><ul><li>std::move()、tsatic_cast(T&amp;&amp;)(t)。这两个函数常用来将左值强制转换成右值，从而使拷贝变成移动，提高效率。</li></ul></li><li><p>注意：</p><ul><li>将亡值不过是C++11提出的一块晦涩的语法糖，它与纯右值在功能上极其相似，如都不能做操作符的左操作数，都可以使用移动构造函数和移动赋值运算符。当一个纯右值来完成移动构造或移动赋值任务时，其实它也具有”将亡”的特点。<strong>一般我们不必可以区分一个右值到底是纯右值还是将亡值</strong>。</li></ul></li></ul><ol start="4"><li><strong>特别注意</strong></li></ol><ul><li>字符串字面值是左值。</li></ul><p>不是所有的字面值都是纯右值，字符串字面值是唯一例外。</p><p>早期C++将字符串字面值实现为char型数组，实实在在的为每个字符都分配了空间并且允许程序员对其操作，所以类似下面的代码也是可以通过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;(<span class="string">&quot;abc&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;abc&quot;</span>;    <span class="comment">//注意不是char *p = &amp;(&quot;abc&quot;);</span></span><br></pre></td></tr></table></figure><ul><li>具名的右值引用是左值，不具名的右值引用是右值。</li></ul><h2 id="4-左值引用与右值引用"><a href="#4-左值引用与右值引用" class="headerlink" title="4. 左值引用与右值引用"></a>4. 左值引用与右值引用</h2><p><strong>左值引用</strong>：&amp;<br><strong>右值引用</strong>：&amp;&amp;</p><ul><li>深拷贝需要频繁分配和释放内存，效率较低</li><li>移动语义的目的：所有权移交，不需要重新构造和析构</li><li>为与构造函数兼容，移动语义必须为引用，而不能是指针或普通量</li><li>普通引用传递左值，以允许函数内部修改目标数据对象</li><li><strong>为区分左值引用</strong>，实现移动语义时必须传递右值引用</li><li>为保证能够修改目标数据对象，在函数内部必须将右值引用作为左值引用对待</li></ul><blockquote><p><a href="https://zhuanlan.zhihu.com/p/97128024">参考原文链接</a></p></blockquote><ol><li>左值引用</li></ol><p>右值引用是C++11引入的概念，所以在C++11之前的引用被称之为左值引用，左值引用在汇编层面和普通的指针是一样的，定义引用变量必须初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;r = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>但是上述代码是无法编译通过的，因为10并没有在内存中存储，而是储存在寄存器中，可以通过下述方法解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>该代码使用常引用来引用数字常量10，因为此刻内存上产生了临时变量保存了10，故r引用的其实是这个临时变量。但是常引用无法修改数据，C++11引入的右值引用能够很好的解决这个问题。</p><ol start="2"><li>右值引用</li></ol><p>右值引用用来绑定到右值，绑定后本来会被销毁的右值的生存期会延长到绑定到它的右值引用的生存期。在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量，但是唯一的区别是右值引用可以进行读写操作。</p><p>右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构的操作以达到提高效率的目的。<strong>必须说把一个函数返回的临时对象拷贝到主函数的对象中后，临时对象还要析构，但如果用右值引用重载赋值构造函数，这个临时对象就不需要析构了。</strong></p><h2 id="5-移动赋值与移动构造"><a href="#5-移动赋值与移动构造" class="headerlink" title="5. 移动赋值与移动构造"></a>5. 移动赋值与移动构造</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(): _p(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">A(<span class="keyword">int</span> *p): _p(p) &#123;&#125;;</span><br><span class="line">A(A &amp;&amp; that);</span><br><span class="line">A &amp; <span class="keyword">operator</span>=(A &amp;&amp; that);</span><br><span class="line"><span class="keyword">virtual</span> ~A() &#123;</span><br><span class="line"><span class="keyword">if</span>(_p) &#123;</span><br><span class="line"><span class="keyword">delete</span> _p;</span><br><span class="line">_p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> *_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::A(A &amp;&amp; that) &#123;</span><br><span class="line">_p = that._p;</span><br><span class="line">that._p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*this = that;不会调动重载的赋值构造函数</span></span><br><span class="line"><span class="comment">具名右值引用that在函数内部被当做左值，而不是右值</span></span><br><span class="line"><span class="comment">匿名右值引用才会被当做左值，理论上如此</span></span><br><span class="line"><span class="comment">*this = static_cast&lt;A&amp;&amp;&gt;(that); 等价于 *this = std::move(that);</span></span><br><span class="line"><span class="comment">上一行代码可以调用重载的赋值构造函数，但是有可能导致程序崩溃</span></span><br><span class="line"><span class="comment">因this指向的本对象可能刚刚分配内存，_p字段所指向的目标数据对象无定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A &amp; A::<span class="keyword">operator</span>=(A &amp;&amp; that) &#123;</span><br><span class="line"><span class="keyword">if</span>(_p) &#123;</span><br><span class="line"><span class="keyword">delete</span> _p;</span><br><span class="line">&#125;</span><br><span class="line">_p = that._p;</span><br><span class="line">that._p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移动语义重载</strong>：在上面的代码中也可以常左值引用版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A(<span class="keyword">const</span> A &amp; that);</span><br><span class="line">A &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp; that);</span><br></pre></td></tr></table></figure><p><strong>主函数部分</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把左值引用转换为右值引用，否则会调用左值版本</span></span><br><span class="line"><span class="function">A <span class="title">c</span><span class="params">(<span class="keyword">static_cast</span>&lt;A&amp;&amp;&gt;(a))</span></span>;<span class="comment">//调用移动构造版本</span></span><br><span class="line">c = <span class="keyword">static_cast</span>&lt;A&amp;&amp;&gt;(a);<span class="comment">//调用移动赋值版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-右值引用的意义"><a href="#6-右值引用的意义" class="headerlink" title="6. 右值引用的意义"></a>6. 右值引用的意义</h2><p><strong>如果仅需实现上面的移动语义，使用左值引用也是可以完成的。那么右值引用的意义是什么呢？</strong></p><ol><li>右值引用可以使用文字作为函数实际参数。</li><li>避免编写过多的构造与赋值函数。<ul><li>不管是左值引用还是右值引用，若同时提供拷贝语义与移动语义，需要2对(4个)构造和赋值函数。(&lt;拷贝构造,拷贝赋值&gt; &lt;移动构造,移动赋值&gt;)</li><li>若要为每一个指针成员都提供拷贝语义和移动语义的构造赋值函数则更为复杂。</li><li>使用右值引用，通过函数模板可以缩减代码编写量。(这个问题只能通过泛型编程解决)</li></ul></li><li><strong>完美转发</strong>。(转发：完成一个参数从一个函数到另外一个函数的传递；完美转发：接受什么值就传出什么值，而没有右值引用是办不到的，C++11前的转发都是有缺陷的。)</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>explicit</title>
      <link href="2020/02/07/C++/explicit/"/>
      <url>2020/02/07/C++/explicit/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test1(<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;<span class="comment">//普通构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;<span class="comment">//explicit(显式)构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test1 t1=<span class="number">12</span>;<span class="comment">//隐式调用其构造函数,成功</span></span><br><span class="line">    Test2 t2=<span class="number">12</span>;<span class="comment">//编译错误,不能隐式调用其构造函数</span></span><br><span class="line">    <span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;<span class="comment">//显式调用成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态常数据成员</title>
      <link href="2020/02/07/C++/%E9%9D%99%E6%80%81%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/"/>
      <url>2020/02/07/C++/%E9%9D%99%E6%80%81%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="静态常数据成员："><a href="#静态常数据成员：" class="headerlink" title="静态常数据成员："></a>静态常数据成员：</h3><p><strong>值在程序运行期不可变，且只有唯一副本</strong></p><ol><li>定义格式：static const 类型 数据成员名称;</li><li>初始化：只能在类的外部初始化</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A::count = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2020/02/06/dpa/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/02/06/dpa/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式是静态数据成员和静态成员函数的应用，即存在着某一个类的单一的共享对象，在整个程序中只能存在一个，在全局任何一个地方都能够访问到它。</strong></p><p>单例模式有很多种实现策略。</p><h3 id="1-无析构"><a href="#1-无析构" class="headerlink" title="1. 无析构"></a>1. 无析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * _s; <span class="comment">//静态数据成员，指向本类唯一对象的指针</span></span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//验证数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有构造和析构函数，禁止在外部构造和析构本类对象</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp; that);  <span class="comment">//只声明不实现，禁止拷贝和赋值构造</span></span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp; that);</span><br><span class="line">    ~Singleton();   <span class="comment">//只声明不实现，禁止析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态成员函数，对象不存在时构造，否则返回，保证唯一性</span></span><br><span class="line">        <span class="keyword">if</span>(!_s) &#123;</span><br><span class="line">            _s = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="keyword">return</span> _s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton * Singleton::_s = <span class="literal">NULL</span>;   <span class="comment">//定义于源文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法：以Singleon::Get() -&gt; GetData()方式直接访问</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Singleton::Get() -&gt; GetData() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-错误析构"><a href="#2-错误析构" class="headerlink" title="2. 错误析构"></a>2. 错误析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * _s; <span class="comment">//静态数据成员，指向本类唯一对象的指针</span></span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//验证数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有构造和析构函数，禁止在外部构造和析构本类对象</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp; that);  <span class="comment">//只声明不实现，禁止拷贝和赋值构造</span></span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp; that);</span><br><span class="line">    ~Singleton() &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            错误的析构函数，访问控制改为public也不行</span></span><br><span class="line"><span class="comment">            delete操作符本身需要调用析构函数</span></span><br><span class="line"><span class="comment">            且非静态成员函数不能释放静态指针成员，否则可能导致系统崩溃</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(Singleton::_s) &#123;</span><br><span class="line">            <span class="keyword">delete</span> Singleton::_s;</span><br><span class="line">            Singleton::_s = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态成员函数，对象不存在时构造，否则返回，保证唯一性</span></span><br><span class="line">        <span class="keyword">if</span>(!_s) &#123;</span><br><span class="line">            _s = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="keyword">return</span> _s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-正确析构（1）"><a href="#3-正确析构（1）" class="headerlink" title="3. 正确析构（1）"></a>3. 正确析构（1）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * _s; <span class="comment">//静态数据成员，指向本类唯一对象的指针</span></span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//验证数据</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destroyer</span> &#123;</span>   <span class="comment">//该类唯一作用是删除单子</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            缺点：</span></span><br><span class="line"><span class="comment">            1. 只有程序结束时才会执行</span></span><br><span class="line"><span class="comment">            2. 某些编译器在不会执行静态成员的析构，直接把成员所占空间返还给操作系统，也就不会执行单子的析构</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        ~Destroyer() &#123;</span><br><span class="line">            <span class="keyword">if</span>(Singleton::_s) &#123;</span><br><span class="line">                <span class="keyword">delete</span> Singleton::_s;</span><br><span class="line">                Singleton::_s = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> Destroyer _d;    <span class="comment">//程序结束时，系统自动调用静态成员的析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有构造和析构函数，禁止在外部构造和析构本类对象</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp; that);  <span class="comment">//只声明不实现，禁止拷贝和赋值构造</span></span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp; that);</span><br><span class="line">    ~Singleton();   <span class="comment">//只声明不实现，禁止析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态成员函数，对象不存在时构造，否则返回，保证唯一性</span></span><br><span class="line">        <span class="keyword">if</span>(!_s) &#123;</span><br><span class="line">            _s = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="keyword">return</span> _s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-正确析构（2）"><a href="#4-正确析构（2）" class="headerlink" title="4. 正确析构（2）"></a>4. 正确析构（2）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * _s; <span class="comment">//静态数据成员，指向本类唯一对象的指针</span></span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//验证数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有构造和析构函数，禁止在外部构造和析构本类对象</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp; that);  <span class="comment">//只声明不实现，禁止拷贝和赋值构造</span></span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp; that);</span><br><span class="line">    ~Singleton();   <span class="comment">//只声明不实现，禁止析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态成员函数，对象不存在时构造，否则返回，保证唯一性</span></span><br><span class="line">        <span class="keyword">if</span>(!_s) &#123;</span><br><span class="line">            _s = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="keyword">return</span> _s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//free不调用析构函数，release调用时机由程序员决定</span></span><br><span class="line">        <span class="comment">//缺点：程序员可能会忘记调用release</span></span><br><span class="line">        <span class="keyword">if</span>(_s) &#123;</span><br><span class="line">            <span class="built_in">free</span>(_s);</span><br><span class="line">            _s = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-静态数据"><a href="#5-静态数据" class="headerlink" title="5. 静态数据"></a>5. 静态数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//验证数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有构造和析构函数，禁止在外部构造和析构本类对象</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp; that);  <span class="comment">//只声明不实现，禁止拷贝和赋值构造</span></span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp; that);</span><br><span class="line">    ~Singleton();   <span class="comment">//只声明不实现，禁止析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态成员函数中的静态变量，保证唯一性</span></span><br><span class="line">        <span class="keyword">static</span> Singleton _s;</span><br><span class="line">        <span class="keyword">return</span> _s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本实现没有动态内存分配，因而无需销毁单子对象</span></span><br><span class="line"><span class="comment">//使用方法：定义引用或以Singleton::Get().GetData()方式直接访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton &amp; sing = Singleton::Get();</span><br><span class="line">    <span class="keyword">int</span> x = sing.GetData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dpa </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态成员函数</title>
      <link href="2020/02/06/C++/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>2020/02/06/C++/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ol><li>在类而不是对象上调用</li><li>目的：访问类的静态数据成员，若要访问类的非静态数据成员，必须指定对象或者使用指向对象的指针,因为静态成员函数并没有缺省的this指针</li><li>静态成员函数可以访问静态成员变量，不可以访问非静态成员变量，因为不知道这是哪个对象的成员</li><li>非静态成员函数可以访问静态和非静态成员变量</li><li>可以通过对象或类名访问</li><li>静态成员函数也是有访问权限的</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> A &amp; a)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::g</span><span class="params">(<span class="keyword">const</span> A &amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态数据成员</title>
      <link href="2020/02/06/C++/%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/"/>
      <url>2020/02/06/C++/%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="静态数据成员只有一份，由该类所有对象共享"><a href="#静态数据成员只有一份，由该类所有对象共享" class="headerlink" title="静态数据成员只有一份，由该类所有对象共享"></a>静态数据成员只有一份，由该类所有对象共享</h3><ol><li>声明格式：static 类型 静态数据成员名称;</li><li>仅声明，不在对象上分配空间</li><li>定义格式：类型 类名称::静态数据成员名称 = 初始值;</li><li>必须在外部初始化，初始化动作与访问控制无关</li><li>编译阶段分配内存</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A::count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="静态成员也具有访问权限"><a href="#静态成员也具有访问权限" class="headerlink" title="静态成员也具有访问权限"></a>静态成员也具有访问权限</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p.a);<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Person::a);<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p.b);<span class="comment">//nok</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Person::b);<span class="comment">//nok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常数据成员</title>
      <link href="2020/02/06/C++/%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/"/>
      <url>2020/02/06/C++/%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="常数据成员：值在程序运行期间不可变"><a href="#常数据成员：值在程序运行期间不可变" class="headerlink" title="常数据成员：值在程序运行期间不可变"></a>常数据成员：值在程序运行期间不可变</h3><ol><li>定义格式：const 类型 数据成员名称;</li><li>初始化：只能通过构造函数中的初始化列表进行</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line">A::A(<span class="keyword">int</span> a):num(a)&#123;...&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常成员函数</title>
      <link href="2020/02/06/C++/%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>2020/02/06/C++/%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><ol><li>本质是个指针常量，Circle * const p; 函数内不能修改指针指向</li><li>常函数则是把this指针变成了 const Circle * const p;</li><li>mutable修饰的成员即使在常函数中也可以被修改</li></ol><h3 id="常成员函数：不能修改成员对象值的函数"><a href="#常成员函数：不能修改成员对象值的函数" class="headerlink" title="常成员函数：不能修改成员对象值的函数"></a>常成员函数：不能修改成员对象值的函数</h3><ol><li>定义格式：类型 成员函数名称(参数列表) const;</li><li>常成员函数不能调用类中非常成员函数</li><li>静态成员函数不能定义为常成员函数</li><li>如果对象为常量，则只能调用其常成员函数</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetArea</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Circle::GetArea</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;...&#125;  <span class="comment">//这个函数的this指针是const Circle * 类型</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数指针</title>
      <link href="2020/02/04/C++/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
      <url>2020/02/04/C++/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>指针的作用之一是作为执行特定程序代码的手段，即使用指针指向特定代码段，执行未来才能实现的函数。</p><p>C++的sort函数在对结构体排序时需要的cmp函数就是函数指针/回调函数的应用。</p><blockquote><p>这里有点奇怪，在网上看过好多成套的C/C++视频，没有教函数指针的。我们学校的C语言课程也没教甚至书上都没有相关记载，今天才知道…</p></blockquote><h1 id="1-指针函数"><a href="#1-指针函数" class="headerlink" title="1. 指针函数"></a>1. 指针函数</h1><p>指针函数即返回指针的函数，需要注意的是不要返回函数中局部变量指针。</p><h1 id="2-函数指针"><a href="#2-函数指针" class="headerlink" title="2. 函数指针"></a>2. 函数指针</h1><p>函数指针就是指向代码段中函数入口地址的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*SUM)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;   <span class="comment">//函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">//函数指针的定义</span></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">array</span>[<span class="number">5</span>])();  <span class="comment">//函数指针数组</span></span><br><span class="line"></span><br><span class="line">    p = sum;    <span class="comment">//函数指针的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上面两行可以写成 SUM p = sum; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = p(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">//函数指针的调用 int res = (*p)(0, 1);也可以</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res); <span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-回调函数"><a href="#3-回调函数" class="headerlink" title="3. 回调函数"></a>3. 回调函数</h1><p>回调函数就是通过函数指针调用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,callback(a,b,sum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake</title>
      <link href="2020/02/04/C++/cmake/"/>
      <url>2020/02/04/C++/cmake/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-gcc"><a href="#1-gcc" class="headerlink" title="1. gcc"></a>1. gcc</h1><p>我之前编译C/C++都是用gcc编译的，gcc的全拼是GNU Compiler Collection，他可以编译各种语言，但是如果源文件很多的时候用gcc就不方便了。</p><h1 id="2-make"><a href="#2-make" class="headerlink" title="2. make"></a>2. make</h1><p>make可以看作是批处理工具，按照Makefile中的指令进行编译、链接操作，而make的过程就包括了调用gcc(或其他编译器)的过程，但是Makefile文件的编写也是比较麻烦的。</p><h1 id="3-cmake"><a href="#3-cmake" class="headerlink" title="3. cmake"></a>3. cmake</h1><p>cmake让我们通过更简单的方式生成Makefile文件，还具有跨平台生成对应Makefile的功能。</p><p>cmake的执行需要CMakeLists.txt文件，这个文件是与具体平台无关的，需要我们手动编写，接着cmake就可以凭借该文件生成对应平台的Makefile文件。</p><p><a href="https://blog.csdn.net/whahu1989/article/details/82078563">具体使用引用一篇CSDN的博客，写的很好。</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序组织与开发方法</title>
      <link href="2020/02/02/C++/%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87%E4%B8%8E%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/"/>
      <url>2020/02/02/C++/%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87%E4%B8%8E%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-库与接口"><a href="#1-库与接口" class="headerlink" title="1. 库与接口"></a>1. 库与接口</h1><h2 id="1-1-库与程序文件"><a href="#1-1-库与程序文件" class="headerlink" title="1.1 库与程序文件"></a>1.1 库与程序文件</h2><ul><li>程序文件：源文件(*.cpp)、头文件(*.h、*.hpp、*)</li><li>库：源文件与头文件</li></ul><h2 id="1-2-接口"><a href="#1-2-接口" class="headerlink" title="1.2 接口"></a>1.2 接口</h2><p>通过接口使用库：包括指定库的头文件和源文件</p><p>优势：不需要了解库的实现细节，只需了解库的使用方法</p><h2 id="1-3-数学库"><a href="#1-3-数学库" class="headerlink" title="1.3 数学库"></a>1.3 数学库</h2><p>windows下数学库是C标准库的一部分，但在linux下数学库是单列的</p><p>头文件：math.h/cmath</p><p>库文件：libm</p><p>链接方式：g++ -lm main.cpp</p><h2 id="1-4-标准辅助函数库"><a href="#1-4-标准辅助函数库" class="headerlink" title="1.4 标准辅助函数库"></a>1.4 标准辅助函数库</h2><ul><li><p>头文件：stdlib.h/cstdlib</p></li><li><p>常用函数：</p><ul><li>void exit(int status);</li><li>void free(void* p);</li><li>void* malloc(size_t size);</li><li>int rand();</li><li>void srand(unsigned int seed);</li></ul></li></ul><h1 id="2-作用域与生存期"><a href="#2-作用域与生存期" class="headerlink" title="2. 作用域与生存期"></a>2. 作用域与生存期</h1><h2 id="2-1-量的作用域与可见性"><a href="#2-1-量的作用域与可见性" class="headerlink" title="2.1 量的作用域与可见性"></a>2.1 量的作用域与可见性</h2><p>若包含全局数据对象定义的文件被其他文件包含，则其作用域扩展到宿主文件中。</p><p><em>不要在头文件中定义全局数据对象</em></p><h2 id="2-2-量的存储类与生命周期"><a href="#2-2-量的存储类与生命周期" class="headerlink" title="2.2 量的存储类与生命周期"></a>2.2 量的存储类与生命周期</h2><ul><li><p>生存期：量在程序中存在的时间范围。</p><p>  C/C++使用存储类表示生存期。</p></li><li><p>静态(全局)生存期：</p><p>  全局对象具有静态生存期</p><p>  生死仅与程序是否执行有关</p></li><li><p>自动(局部)生存期</p><p>  局部对象具有自动生存期</p><p>  生死仅与程序流程是否位于该块有关</p><p>  每次进入该块时分配内存，退出时释放内存</p></li></ul><h2 id="2-3-static关键字"><a href="#2-3-static关键字" class="headerlink" title="2.3 static关键字"></a>2.3 static关键字</h2><ul><li><p>修饰局部变量：静态局部变量</p><p>  a. 拉长局部变量生存期，不改变作用域</p><p>  b. 静态局部变量必须初始化</p><p>  <em>为什么不用全局变量代替？</em></p><p>  例如计数函数中static cnt局部变量，若用全局变量代替，则失去了与计数函数的作用域的绑定。</p></li><li><p>修饰全局变量：</p><p>  使其作用域仅限本文件，其他文件不可见。</p></li><li><p>修饰函数：</p><p>  使该函数不可被其他文件的函数调用。</p></li></ul><h2 id="2-4-函数的作用域与生存期"><a href="#2-4-函数的作用域与生存期" class="headerlink" title="2.4 函数的作用域与生存期"></a>2.4 函数的作用域与生存期</h2><ul><li><p>所有函数具有文件作用域与静态生存期</p><p>  在程序每次执行时都存在，并且可以在函数原型或函数定义任意位置调用</p></li><li><p>内部函数与外部函数</p><p>  即是否可以被其他文件中的函数调用</p><p>  定义内部函数使用static关键字</p></li></ul><h2 id="2-5-声明与定义"><a href="#2-5-声明与定义" class="headerlink" title="2.5 声明与定义"></a>2.5 声明与定义</h2><ul><li><p>声明不是定义：</p><p>  定义在程序产生一个新实体</p><p>  声明仅在程序中引入一个实体</p></li><li><p>函数的声明与定义：</p><p>  声明是给出函数原型，定义是给出函数实现代码</p></li><li><p>类型的声明与定义：</p><p>  产生新类型就是定义。</p><p>  例如：<code>typedef enum __BOOL &#123;FALSE,TRUE&#125; BOOL;</code>就是BOOL类型的定义，而<code>enum __BOOL;</code>只是声明。</p></li></ul><h2 id="2-6-全局变量作用域的扩展"><a href="#2-6-全局变量作用域的扩展" class="headerlink" title="2.6 全局变量作用域的扩展"></a>2.6 全局变量作用域的扩展</h2><ul><li>全局变量的定义不能出现在头文件中，只有其声明才可以出现在头文件中。</li><li>声明格式：使用extern关键字。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//global.h</span></span><br><span class="line"><span class="keyword">extern</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lib.c</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br></pre></td></tr></table></figure><h1 id="3-典型软件开发流程"><a href="#3-典型软件开发流程" class="headerlink" title="3. 典型软件开发流程"></a>3. 典型软件开发流程</h1><p>a. 需求分析</p><p>软件开发人员需要与用户深入交流，明确问题的输入输出以及其他附加信息，不要轻视任何问题。</p><p>b. 方案设计</p><p>概要设计：设计总体方案，形成高层模块划分。</p><p>详细设计：细化模块，获得各模块输入输出与算法实现。</p><p>c. 编码实现</p><p>d. 系统测试</p><p>e. 经验总结</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库与静态库</title>
      <link href="2020/02/02/C++/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/"/>
      <url>2020/02/02/C++/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li>linux<ul><li>libxxx.a</li><li>前缀lib固定</li><li>扩展名.a固定</li></ul></li><li>windows<ul><li>libxxx.lib</li></ul></li></ul><h3 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h3><ol><li>将源码汇编成二进制文件<ul><li><code>gcc -c A.c B.c C.c</code></li></ul></li><li>使用ar(archive封存)工具，将二进制文件打包<ul><li><code>ar rcs libxxx.a A.o B.o C.o</code></li><li>r：替换</li><li>c：创建</li><li>s：索引</li></ul></li></ol><h3 id="静态库的链接"><a href="#静态库的链接" class="headerlink" title="静态库的链接"></a>静态库的链接</h3><ol><li>指定头文件查找路径<ul><li><code>gcc main.c -I ./include/</code></li></ul></li><li>指定动态库查找路径<ul><li><code>gcc main.c -I ./include/ -L ./lib/</code></li></ul></li><li>指定动态库名字<ul><li><code>gcc main.c -I ./include/ -L ./lib/ -l xxx</code></li><li>这里指定动态库名字不写前缀和扩展名</li></ul></li></ol><h2 id="动态库（共享库）"><a href="#动态库（共享库）" class="headerlink" title="动态库（共享库）"></a>动态库（共享库）</h2><h3 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li>linux<ul><li>libxxx.so</li><li>前缀lib固定</li><li>扩展名.so固定</li><li>是个可执行文件</li></ul></li><li>windows<ul><li>非vs制作<ul><li>libxxx.dll</li></ul></li><li>vs制作<ul><li>libxxx.lib（不是动态库）</li><li>libxxx.dll</li></ul></li></ul></li></ul><h3 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h3><ol><li>将源码汇编成与位置无关的二进制文件<ul><li><code>gcc -c -fPIC A.c B.c C.c</code> (-fpic也可以)</li></ul></li><li>使用gcc得到动态库<ul><li><code>gcc -shared -o libxxx.so A.o B.o C.o</code></li></ul></li><li>前两步可以写在一起<ul><li><code>gcc -shared -fPIC -o libxxx.so A.c B.c C.c</code></li></ul></li></ol><h3 id="动态库的链接"><a href="#动态库的链接" class="headerlink" title="动态库的链接"></a>动态库的链接</h3><ul><li>与静态库的链接方式一致，但这只能保证在链接时没问题<ul><li><code>gcc main.c -I ./include/ -L ./lib/ -l xxx</code></li></ul></li></ul><h3 id="动态库工作原理"><a href="#动态库工作原理" class="headerlink" title="动态库工作原理"></a>动态库工作原理</h3><ul><li>动态库的工作原理是在函数被调用时加载动态库到内存</li><li>可以通过<code>ldd 可执行文件名</code>来检测是否能加载到对应的库文件</li><li>当系统运行可执行文件时，能够知道它所依赖的动态库的名字，但是还需要知道动态库文件的绝对路径，此时就需要系统的动态载入器来获取其绝对路径</li><li>对于<strong>elf格式</strong>的可执行程序，是由<strong>ld-linux.so</strong>来完成的，它先后搜索<strong>elf文件的DT_RPATH段 -&gt; 环境变量LD_LIBRARY_PATH -&gt; /etc/ld.so.cache文件列表 -&gt; /lib/ /usr/lib/目录</strong>，找到动态库文件后将其载入内存<ul><li>DT_RPATH在进程空间中，无法更改</li></ul></li></ul><h3 id="解决动态库加载失败的问题"><a href="#解决动态库加载失败的问题" class="headerlink" title="解决动态库加载失败的问题"></a>解决动态库加载失败的问题</h3><ol><li>将动态库的绝对路径添加到环境变量LD_LIBRARY_PATH中<ul><li>临时设置<br>  <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/xxx/xxx</code></li><li>长久设置<ul><li>用户级别：~/.bashrc<ul><li>添加：<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/xxx/xxx</code></li><li>执行：<code>. ~/.bashrc</code> 这里的”.”等价于source</li></ul></li><li>系统界别：/etc/profile<ul><li>添加：<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/xxx/xxx</code></li><li>执行：<code>. /etc/profile</code></li></ul></li></ul></li></ul></li><li>在/etc/ld.so.cache中添加动态库路径<ul><li>无法直接对该文件进行操作，需要间接完成<ul><li>在文件/etc/ld.so.conf中添加动态库绝对路径</li><li>执行<code>sudo ldconfig</code>更新</li></ul></li></ul></li></ol><h2 id="动态库与静态库的对比"><a href="#动态库与静态库的对比" class="headerlink" title="动态库与静态库的对比"></a>动态库与静态库的对比</h2><h3 id="静态库-1"><a href="#静态库-1" class="headerlink" title="静态库"></a>静态库</h3><ul><li>优点<ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul></li><li>缺点<ul><li>销毁系统资源，浪费内存</li><li>更新、部署、发布麻烦</li></ul></li></ul><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><ul><li>优点<ul><li>可实现进程间资源共享</li><li>程序升级简单</li><li>可以控制何时加载动态库</li></ul></li><li>缺点<ul><li>加载速度比静态库慢</li><li>发布程序需要提供依赖的动态库</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cgo初试</title>
      <link href="2020/01/31/go/cgo/"/>
      <url>2020/01/31/go/cgo/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build go1.12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void SayHello(_GoString_ s)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.SayHello(<span class="string">&quot;Hello World!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export SayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><p style="color:red">    // +build go1.12 版本要写自己的go语言版本！！！</p></center><center><p style="color:red">    go version查看自己的go语言版本。</p></center><center><p style="color:red">    import "C" 和注释部分的C语言之间不能有空行！！！</p></center><center><p style="color:red">    //export SayHello 和下面的函数之间不能有空行！！！</p></center>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter</title>
      <link href="2020/01/31/other/flutter/"/>
      <url>2020/01/31/other/flutter/</url>
      
        <content type="html"><![CDATA[<p>系统环境：deepin15.11，Flutter SDK：v1.10.4</p><a id="more"></a><ol><li>下载<a href="https://github.com/flutter/flutter/releases">Flutter SDK</a>,这里下的是v1.10.4，选择tar.gz格式。</li><li>解压到/usr/local/flutter，flutter文件夹权限改成777。</li><li>把flutter/bin加到环境变量。</li><li>deepin自带的应用商店下载vscode并下载flutter插件。</li><li>应用商店下载android studio，我不用它开发，只是android sdk没法单独安装了。</li><li>执行flutter doctor，他会告诉你<code>Android license status unknown</code>，然后按它提示的执行<code>flutter doctor –android-licenses</code>。</li><li>继续执行flutter doctor，如果得到的是下面的结果那么就成功了。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[✓] Flutter (Channel stable, v1.9.1+hotfix.6, on Linux, locale zh_CN.UTF-8)</span><br><span class="line"></span><br><span class="line">[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.2)</span><br><span class="line">[!] Android Studio (version 3.4)</span><br><span class="line">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[✓] VS Code (version 1.36.0)</span><br><span class="line">[✓] Connected device (1 available)</span><br><span class="line"></span><br><span class="line">! Doctor found issues in 1 category.</span><br></pre></td></tr></table></figure></li><li>因为我们使用vscode开发，所以可以忽略上面第三条的警告。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> environ </tag>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter图片下载</title>
      <link href="2020/01/31/art/flutter%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/"/>
      <url>2020/01/31/art/flutter%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>用flutter写了一个通过b站视频av号获取封面的app，勉强能用，不过网上关于flutter的教程实在太少了，我就想把图片下到相册硬是找不到教程，最后还是自己一路摸索过来的。</p><a id="more"></a><p>github地址：<a href="https://github.com/greensburst/bcover">https://github.com/greensburst/bcover</a></p><p>如果你要是想试试的话需要把代码改一点，因为我的下载路径是写死的，你需要改成你自己手机文件目录的路径。</p><p><img src="https://img-blog.csdnimg.cn/20190817164458906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>flutter run</code>到手机后，把视频av号输进去，不带’av’两个字母，然后点一下那个指纹，没有啥提示，然后你去可以去你的文件管理器对应的目录去找了。</p><p>好了，现在正式写教程。</p><h3>1.引包</h3><p><img src="https://img-blog.csdnimg.cn/20190817164520953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>我这里用到了dio包和permission_handler包。那个path_provider并没有用到，它生成的目录我手机根本就找不到，哇，气死我了。</p><p>dio包主要是用来http请求和下载图片的。permission_handler拿来获取权限。关于他们如何使用你可以访问<a href="https://pub.dev/packages">datrpub</a>查看。或者看我代码也行，很简单的我就用了几行，在那个img.dart里。</p><h3>2.权限</h3>这一步是真的坑啊。<p><img src="https://img-blog.csdnimg.cn/20190817164536692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>网上查加权限只告诉你<code>&lt;uses-permission ...</code>什么什么，压根不告诉你这个该加在哪个文件，哇，我真的服了。至于dart pub的官方文档更是连要加这个东西都没说，哇我真是…</p><p>上面那个是存储权限要做的，你要是需要别的权限百度搜索关键字<code>android.permission</code>一大堆。</p><p>在这个文件里加了权限以后才能去做官方文档里一大堆的骚操作，不过要是你都加上了还不好使，就<code>flutter clean</code>之后再<code>flutter run</code>。哇这个也贼坑。</p><p>具体怎么实现我就不细说了，我想会点进这篇文档的也都不差那些，要是你还没学flutter一定要做好心理准备，这技术太新，网上的教程真是太少了。</p><p>哇，我这一腔怨气，好在最后勉强整出来了。</p>]]></content>
      
      
      <categories>
          
          <category> art </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础使用</title>
      <link href="2020/01/31/other/docker/"/>
      <url>2020/01/31/other/docker/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-Docker安装与启动"><a href="#1-Docker安装与启动" class="headerlink" title="1 Docker安装与启动"></a>1 Docker安装与启动</h3><h4 id="1-1-安装Docker"><a href="#1-1-安装Docker" class="headerlink" title="1.1 安装Docker"></a>1.1 安装Docker</h4><p>​ Docker官方建议在ubuntu中安装，因为docker是基于ubuntu发布的，而且一般docker出现的问题ubuntu是最先更新或者打补丁的，在很多版本的centos中是不支持最新的一些补丁包的。</p><p>​ 文档中环境使用centos7，在centos6中，安装前需要很多其他的环境，而且docker很多补丁不支持更新。</p><ol><li><p>yum包更新到最新</p><p> ​ <code>sudo yum update</code></p></li><li><p>安装需要的软件包</p><p> ​ <code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p></li><li><p>设置yum源为阿里云</p><p> ​</p><pre><code> `sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo`</code></pre></li><li><p>安装docker</p><pre><code> `sudo yum install docker-ce`</code></pre></li><li><p>安装后查看docker版本</p><pre><code> `docker -v`</code></pre></li></ol><h4 id="1-2-设置ustc的镜像"><a href="#1-2-设置ustc的镜像" class="headerlink" title="1.2 设置ustc的镜像"></a>1.2 设置ustc的镜像</h4><p>​ ustc是老牌的linux镜像服务提供者了，ustc的docker镜像加速器速度很快，ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p><p>​ 编辑该文件：</p><p>​ <code>vi /etc/docker/daemon.json</code></p><p>​ 在该文件中输入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Docker的启动与停止"><a href="#1-3-Docker的启动与停止" class="headerlink" title="1.3 Docker的启动与停止"></a>1.3 Docker的启动与停止</h4><p>​ systemctl命令是系统服务管理器指令</p><p>​ 启动docker：</p><p>​ <code>systemctl start docker</code></p><p>​ 停止docker：</p><p>​ <code>systemctl stop docker</code></p><p>​ 重启docker：</p><p>​ <code>systemctl restart docker</code></p><p>​ 查看docker状态：</p><p>​ <code>systemctl status docker</code></p><p>​ 开机启动：</p><p>​ <code>systemctl enable docker</code></p><p>​ 查看docker概要信息：</p><p>​ <code>docker info</code></p><p>​ 查看docker帮助文档：</p><p>​ <code>docker --help</code></p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2 常用命令"></a>2 常用命令</h3><h4 id="2-1-镜像相关命令"><a href="#2-1-镜像相关命令" class="headerlink" title="2.1 镜像相关命令"></a>2.1 镜像相关命令</h4><h5 id="2-1-1-查看镜像"><a href="#2-1-1-查看镜像" class="headerlink" title="2.1.1 查看镜像"></a>2.1.1 查看镜像</h5><p>​ <code>docker images</code></p><p>​ REPOSITORY：镜像名称</p><p>​ TAG：镜像标签</p><p>​ IMAGE ID：镜像id</p><p>​ CREATED：镜像创建的日期</p><p>​ SIZED：镜像大小</p><p>​ 这些镜像都是存储在docker宿主机的/var/lib/docker目录下</p><h5 id="2-1-2-搜索镜像"><a href="#2-1-2-搜索镜像" class="headerlink" title="2.1.2 搜索镜像"></a>2.1.2 搜索镜像</h5><p>​ 如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><p>​ <code>docker search imagename</code></p><p>​ NAME：仓库名称</p><p>​ DESCRIPTION：镜像描述</p><p>​ STARS：打星数</p><p>​ OFFICIAL：是否官方</p><p>​ AUTOMATED：是否由docker hub自动构建</p><h5 id="2-1-2-拉取镜像"><a href="#2-1-2-拉取镜像" class="headerlink" title="2.1.2 拉取镜像"></a>2.1.2 拉取镜像</h5><p>​ 拉取镜像就是从中央仓库中下载镜像到本地</p><p>​ <code>docker pull imagename</code></p><p>​ 例如，下载centos7镜像</p><p>​ <code>docker pull centos:7</code></p><h5 id="2-1-4-删除镜像"><a href="#2-1-4-删除镜像" class="headerlink" title="2.1.4 删除镜像"></a>2.1.4 删除镜像</h5><p>​ 按镜像id删除镜像</p><p>​ <code>docker rmi imageid</code></p><h4 id="2-2-容器相关命令"><a href="#2-2-容器相关命令" class="headerlink" title="2.2 容器相关命令"></a>2.2 容器相关命令</h4><h5 id="2-2-1-查看容器"><a href="#2-2-1-查看容器" class="headerlink" title="2.2.1 查看容器"></a>2.2.1 查看容器</h5><p>​ 查看正在运行的容器</p><p>​ <code>docker ps</code></p><p>​ 查看所有容器</p><p>​ <code>docker ps -a</code></p><p>​ 查看最后一次运行的容器</p><p>​ <code>docker ps -l</code></p><p>​ 查看停止的容器</p><p>​ <code>docker ps -f status=exited</code></p><h5 id="2-2-2-创建与启动容器"><a href="#2-2-2-创建与启动容器" class="headerlink" title="2.2.2 创建与启动容器"></a>2.2.2 创建与启动容器</h5><p>​ 创建容器常用的参数说明：</p><p>​ 创建容器命令：docker run</p><p>​ -i：表示运行容器</p><p>​ -t：表示容器启动后会进入其命令行</p><p>​ &ndash;name：为创建的容器命名</p><p>​ -v：表示目录映射关机（前者宿主机目录，后者容器目录）</p><p>​ -d：创建一个守护式容器在后台运行</p><p>​ -p：表示端口映射（前者宿主机端口，后者容器端口）</p><p>​ （1）交互式方式创建容器</p><p>​ <code>docker run -it --name=容器名称 镜像名称:标签 /bin/bash</code></p><p>​ 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态</p><p>​ 退出当前容器</p><p>​ <code>exit</code></p><p>​ （2）守护式方式创建容器</p><p>​ <code>docker run -id --name=容器名称 镜像名称:标签</code></p><p>​ 登录守护容器方式</p><p>​ <code>docker exec -it 容器名称（或容器id） /bin/bash</code></p><h5 id="2-2-3-停止与启动容器"><a href="#2-2-3-停止与启动容器" class="headerlink" title="2.2.3 停止与启动容器"></a>2.2.3 停止与启动容器</h5><p>​ 停止容器</p><p>​ <code>docker stop 容器名称或容器id</code></p><p>​ 启动容器</p><p>​ <code>docker start 容器名称或容器id</code></p><h5 id="2-2-4-文件拷贝"><a href="#2-2-4-文件拷贝" class="headerlink" title="2.2.4 文件拷贝"></a>2.2.4 文件拷贝</h5><p>​ 如果我们需要将文件拷贝到容器内可以使用cp命令</p><p>​ <code>docker cp 需要拷贝文件或目录 容器名称:容器目录</code></p><p>​ 也可以将文件从容器中拷贝出来</p><p>​ <code>docker cp 容器名称:容器目录 需要拷贝的文件或目录</code></p><h5 id="2-2-5-目录挂载"><a href="#2-2-5-目录挂载" class="headerlink" title="2.2.5 目录挂载"></a>2.2.5 目录挂载</h5><p>​ 我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器</p><p>​ 创建容器 添加-v参数，后变为宿主机目录:容器目录</p><p>​ <code>docker run -id -v  /usr/local/myhtml:/usr/local/mthtml --name=mycentos3 centos:7</code></p><p>​ 如果你共享的是多级目录，可能会出现权限不足的提示</p><p>​ 这是因为centos7中的安全模块selinux把权限禁掉了，我们需要添加参数&ndash;privileged=true来解决挂载的目录没有权限的问题</p><h5 id="2-2-6-查看容器ip地址"><a href="#2-2-6-查看容器ip地址" class="headerlink" title="2.2.6 查看容器ip地址"></a>2.2.6 查看容器ip地址</h5><p>​ 我们可以通过以下命令查看容器运行的各种数据</p><p>​ <code>docker inspect 容器名称或id</code></p><p>​ 也可以直接执行下面的命令直接输出ip地址</p><p>​ <code>docker inspect --format=&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125; 容器名称或id&#39;</code></p><h5 id="2-2-7-删除容器"><a href="#2-2-7-删除容器" class="headerlink" title="2.2.7 删除容器"></a>2.2.7 删除容器</h5><p>​ 删除指定的容器：</p><p>​ <code>docker rm 容器名称或id</code></p><h3 id="3-应用部署"><a href="#3-应用部署" class="headerlink" title="3 应用部署"></a>3 应用部署</h3><h4 id="3-1-MySQL部署"><a href="#3-1-MySQL部署" class="headerlink" title="3.1 MySQL部署"></a>3.1 MySQL部署</h4><p>​ （1）拉取mysql镜像</p><p>​ <code>docker pull centos/mysql-57-centos71</code></p><p>​ （2）创建容器</p><p>​ <code>docker run -id --name=mymysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></p><p>​ -p代表端口映射，格式为宿主机端口:容器运行端口</p><p>​ -e代表添加环境变量，MYSQL_ROOT_PASSWORD是root用户的登录密码</p><p>​ （3）远程登录mysql</p><p>​ 连接宿主机ip，指定端口为33306</p><h4 id="3-2-tomcat部署"><a href="#3-2-tomcat部署" class="headerlink" title="3.2 tomcat部署"></a>3.2 tomcat部署</h4><p>​ （1）拉取镜像</p><p>​ <code>docker pull tomcat:7-jre7</code></p><p>​ （2）创建容器</p><p>​ 创建容器 -p表示地址映射</p><p>​<br>    <code>docker run -id --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</code></p><h4 id="3-3-Nginx部署"><a href="#3-3-Nginx部署" class="headerlink" title="3.3 Nginx部署"></a>3.3 Nginx部署</h4><p>​ （1）拉取镜像</p><p>​ <code>docker pull nginx</code></p><p>​ （2）创建Nginx容器</p><p>​ <code>docker run -id --name=mynginx -p 80:80 nginx</code></p><h4 id="3-4-Redis部署"><a href="#3-4-Redis部署" class="headerlink" title="3.4 Redis部署"></a>3.4 Redis部署</h4><p>​ （1）拉取镜像</p><p>​ <code>docker pull redis</code></p><p>​ （2）创建容器</p><p>​ <code>docker run -id --name=myredis -p 6379:6379 redis</code></p><h3 id="4-迁移与备份"><a href="#4-迁移与备份" class="headerlink" title="4 迁移与备份"></a>4 迁移与备份</h3><h4 id="4-1-容器保存为镜像"><a href="#4-1-容器保存为镜像" class="headerlink" title="4.1 容器保存为镜像"></a>4.1 容器保存为镜像</h4><p>​ 我们可以通过以下命令将容器保存为镜像</p><p>​ <code>docker commit mynginx mynginx_i</code></p><h4 id="4-2-镜像备份"><a href="#4-2-镜像备份" class="headerlink" title="4.2 镜像备份"></a>4.2 镜像备份</h4><p>​ 我们可以通过以下命令将镜像保存为tar文件</p><p>​ <code>docker save -o mynginx.tar mynginx_i</code></p><h4 id="4-3-镜像恢复与迁移"><a href="#4-3-镜像恢复与迁移" class="headerlink" title="4.3 镜像恢复与迁移"></a>4.3 镜像恢复与迁移</h4><p>​ 首先我们先删除掉mynginx_img镜像，然后执行此命令进行恢复</p><p>​ <code>docker load -i mynginx.tar</code></p><p>​ -i输入的文件</p><p>​ 执行后再次查看镜像，可以看到镜像已经恢复</p><h3 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5 Dockerfile"></a>5 Dockerfile</h3><h4 id="5-1-什么是dockerfile"><a href="#5-1-什么是dockerfile" class="headerlink" title="5.1 什么是dockerfile"></a>5.1 什么是dockerfile</h4><p>​ Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像</p><p>​ 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境</p><p>​ 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作</p><p>​ 3、对于运维人员：在部署时，可以实现应用的无缝移植</p><h4 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h4><p>​ FROM image_name:tag 定义了使用哪个基础镜像启动构建流程</p><p>​ MAINTAINER user_name 声明镜像的创建者</p><p>​ ENV key value 设置环境变量（可以写多条）</p><p>​ RUN command 是Dockerfile的核心部分（可以写多条）</p><p>​ ADD source_dir/filedest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</p><p>​ COPY source_dir/filedest_dir/file 和ADD相似，但是如果有压缩文件并不能解压</p><p>​ WORKDIR path_dir 设置工作目录</p><h4 id="5-3-使用脚本创建镜像"><a href="#5-3-使用脚本创建镜像" class="headerlink" title="5.3 使用脚本创建镜像"></a>5.3 使用脚本创建镜像</h4><p>​ 步骤：</p><p>​ （1）创建目录</p><p>​ <code>mkdir -p /usr/local/dockerjdk8</code></p><p>​ （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器中的/usr/local/dockerjdk8目录</p><p>​ （3）创建文件Dockerfile <code>vi Dockerfile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#依赖镜像名称和ID</span><br><span class="line">FROM centos:7</span><br><span class="line">#指定镜像创建者信息</span><br><span class="line">MAINTAINER ITCAST</span><br><span class="line">#切换工作目录</span><br><span class="line">WORKDIR &#x2F;usr</span><br><span class="line">RUN mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line">#ADD是相对路径jar，把java添加到容器中</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br><span class="line"></span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME&#x2F;jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME&#x2F;BIN:$PATH</span><br></pre></td></tr></table></figure><p>​ （4）执行命令构建镜像</p><p>​ <code>docker build -t=&#39;jdk1.8&#39; .</code></p><p>​ 注意后面的空格和点，不要省略</p><p>​ （5）查看镜像是否建立完成</p><p>​ <code>docker images</code></p><h3 id="6-Docker私有仓库"><a href="#6-Docker私有仓库" class="headerlink" title="6 Docker私有仓库"></a>6 Docker私有仓库</h3><h4 id="6-1-私有仓库搭建与配置"><a href="#6-1-私有仓库搭建与配置" class="headerlink" title="6.1 私有仓库搭建与配置"></a>6.1 私有仓库搭建与配置</h4><p>​ （1）拉取私有仓库镜像</p><p>​ <code>docker pull registry</code></p><p>​ （2）启动私有仓库容器</p><p>​ <code>docker run -id --name=registry -p 5000:5000 registry</code></p><p>​ （3）打开浏览器输入地址192.168.-.-:5000/v2/_catalog看到<code>&#123;&amp;quot;repositories&amp;quot;:[]&#125;</code>表示私有仓库搭建成功并且内容为空</p><p>​ （4）修改daemon.json</p><p>​ <code>vi /etc/docker/daemon.json</code></p><p>​ 添加以下内容保存退出</p><p>​ <code>&#123;&amp;quot;insecure-registries&amp;quot;:[192.168.-.-:5000]&#125;</code></p><p>​ 此步用于让docker信任私有仓库地址</p><p>​ （5）重启docker服务</p><p>​ <code>systemctl restart docker</code></p><h4 id="6-2-镜像上传至私有仓库"><a href="#6-2-镜像上传至私有仓库" class="headerlink" title="6.2 镜像上传至私有仓库"></a>6.2 镜像上传至私有仓库</h4><p>​ （1）标记此镜像为私有仓库的镜像</p><p>​ <code>docker tag jdk1.8 192.168.-.-:5000/jdk1.8</code></p><p>​ （2）再次启动私服容器</p><p>​ <code>docker start registry</code></p><p>​ （3）上传标记的镜像</p><p>​ <code>docker push 192.168.-.-:5000/jdk1.8</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> environ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点</title>
      <link href="2020/01/31/C++/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2020/01/31/C++/%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>数组传参</strong></p><ul><li>数组做函数参数时会退化为一级指针</li><li>数组做函数参数应把数组元素个数也传给函数</li><li>形参中的数组编译器把它当做指针处理</li><li>实参中的数组和形参中的数组本质不一样</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;<span class="comment">//4字节，指针的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//12字节</span></span><br><span class="line">   fun(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据类型</strong></p><ul><li>类型的本质：固定内存大小的别名</li><li>类型的作用：编译器预算对象分配的内存空间大小</li><li>数据类型可以通过typedef起别名</li><li>可以用sizeof算出类型大小</li><li>void数据类型为无类型、万能类型</li><li>void *p:万能指针，指针类型都是4个字节（x86）或8个字节（x64）</li><li>对于 int a[10] a:数组首元素地址,一个元素4字节，&amp;a:整个数组首地址，一个数组40字节</li></ul><p><strong>内存四区</strong></p><ul><li>栈区：地址由上往下递减</li><li>堆区：地址由下往上递增</li><li>全局区：初始化区、未初始化区、文字常量区</li><li>代码区</li></ul><p>ps:数组地址永远是递增的</p><p><strong>动态链接库与静态链接库</strong></p><ul><li>静态链接库：.lib(windows) .a(linux) 在程序编译时会被连接到目标代码中。</li><li>动态链接库：.dll(windows) .so(linux) 在程序运行时被载入。</li></ul><p><strong>const</strong></p><ul><li>全局的const存放在静态全局区的文字常量区，不可以被指针间接修改</li><li>函数内的const存放在栈区，可以被指针间接修改，是伪常量</li></ul><p><strong>数据共享</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* b = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// a b指向同一块内存</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="2020/01/31/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2020/01/31/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>内存管理主要掌握生命周期和内存布局，如果变量没有释放就可以用，释放了就不能用了。</p><a id="more"></a><h3>一.作用域和声明周期</h3><ol><li><p><strong>普通的局部变量</strong></p><ol><li>在{}内部定义的变量就是局部变量。</li><li>只有执行到定义变量的这个语句，系统才会给这个变量分配空间。</li><li>当离开{}时自动释放。</li><li>作用域在当前{}内。</li><li>加不加auto关键字都是一样的。</li><li>不初始化则值为随机数。</li></ol></li><li><p><strong>static局部变量</strong></p><ol><li>在{}内部定义的变量就是局部变量。</li><li>在编译阶段分配空间。</li><li>离开{}不会释放，程序结束才释放。</li><li>作用域在当前{}内。</li><li>不初始化则值为零。</li><li>初始化语句只会执行一次，但可以赋值多次。</li><li>只能用常量初始化。</li></ol></li><li><p><strong>普通全局变量</strong></p><ol><li><p>在函数外面定义的为全局变量。</p></li><li><p>如果使用变量前找不到定义，需要声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>全局变量不初始化则值为零。</p></li><li><p>声明只针对普通全局变量。</p></li><li><p>所有文件中，普通全局变量只能定义一次，可以声明多次。</p></li><li><p>全局变量在编译阶段分配空间，程序结束释放。</p></li><li><p>多文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//也可以把声明写到头文件里，头文件中不能放定义，多个文件包含会重复定义</span></span><br><span class="line">    <span class="comment">//#program once表示一个文件包含n次头文件只有一次有效</span></span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>static全局变量</strong></p><ol><li>在函数外面定义的为全局变量。</li><li>static全局变量只在当前文件有效，同名static全局变量可以在多个文件定义。</li><li>全局变量不初始化则值为零。</li><li>全局变量在编译阶段分配空间，程序结束释放。</li></ol></li></ol><h3>二.内存布局</h3><blockquote><p>实际上的内存分段远不止这几个，这里拣重点说。</p></blockquote><ol><li><p><strong>在程序没有执行前，有几个内存分区已经确定，但只有程序运行时才会加载内存，linux中可以使用<code>size *.out</code>查看。</strong></p><ul><li>text（代码区）：只读，放函数。</li><li>data（全局初始化数据区/静态数据区）：初始化的数据，全局变量，static变量，常量（只读）。</li><li>bss（未初始化数据区）：定义但未初始化的数据，全局变量，static变量。</li></ul></li><li><p><strong>当程序运行时，加载内存，首先前面确定的内存分区（text，data，bss）先加载，然后额外加载两个区：</strong></p><ul><li>stack（栈区）：普通局部变量，自动管理内存，先进后出。</li><li>heap（堆区）：手动申请空间，手动释放，整个程序结束，系统也会自动回收，如果没有手动释放，程序也没有结束，这个堆区空间不会自动释放。</li></ul></li><li><p><strong>存储类型总结</strong></p><table><thead><tr><th>类型</th><th>作用域</th><th>生命周期</th><th>存储位置</th></tr></thead><tbody><tr><td>auto变量</td><td>{}内</td><td>当前函数</td><td>stack</td></tr><tr><td>static局部变量</td><td>{}内</td><td>整个程序运行期</td><td>data/bss</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td><td>data/bss</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td><td>data/bss</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td><td>text</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td><td>text</td></tr><tr><td>register变量</td><td>{}内</td><td>当前函数</td><td>运行时存储在cpu寄存器</td></tr><tr><td>常量</td><td>当前文件</td><td>整个程序运行期</td><td>data</td></tr></tbody></table></li><li><p><strong>栈越界</strong></p><p>Linux中可以用<code>ulimit -a</code>查看栈区多大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000000000000</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//很显然栈区存不下，越界导致段错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>内存操作函数</strong></p><ol><li><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;void *memset(void *s,int c,size_t n);/*功能：将s的内存区的前n个字节以参数c填入参数：    s：需要操作内存s的首地址    c：填充的字符，类型虽然是int，但必须是unsigned char，范围0-2555    n：指定需要设置的大小返回值：s的首地址*/int main() &#123;    int a;    //主要就是用来清零    memset(&amp;a,0,sizeof(a));    printf(&quot;a = %d\n&quot;,a);    //&quot;a = 0&quot;    //中间参数虽然是整形，但是以字符处理    //每个字节都存的97，所以只能char单字节的读    memset(&amp;a,97,sizeof(a));    printf(&quot;a = %c\n&quot;,a);    //&quot;a = a&quot;    int b[10];    memset(b,0,sizeof(b));    memset(b,0,10 * sizeof(int));    return 0;&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;c</span><br><span class="line">   #include &lt;stdio.h&gt;</span><br><span class="line">   #include &lt;string.h&gt;</span><br><span class="line">   void *memcpy(void *dest,const void *src,size_t n);</span><br><span class="line">   </span><br><span class="line">   int main() &#123;</span><br><span class="line">   char p[] &#x3D; &quot;hello\0world&quot;;</span><br><span class="line">   char buf[100];</span><br><span class="line">       printf(&quot;sizeof(p) &#x3D; %d\n&quot;,sizeof(p));</span><br><span class="line">       strncpy(buf,p,sizeof(p));</span><br><span class="line">       printf(&quot;buf1 &#x3D; %s\n&quot;,buf);</span><br><span class="line">       printf(&quot;buf2 &#x3D; %s\n&quot;,buf + strlen(&quot;hello&quot;) + 1);</span><br><span class="line">       &#x2F;*</span><br><span class="line">       sizeof(p) &#x3D; 12</span><br><span class="line">   buf1 &#x3D; hello</span><br><span class="line">   buf2 &#x3D;</span><br><span class="line">   *&#x2F;</span><br><span class="line">       </span><br><span class="line">       memset(buf,0,sizeof(buf));</span><br><span class="line">       memcpy(buf,p,sizeof(p));</span><br><span class="line">       printf(&quot;buf1 &#x3D; %s\n&quot;,buf);</span><br><span class="line">       printf(&quot;buf2 &#x3D; %s\n&quot;,buf + strlen(&quot;hello&quot;) + 1);</span><br><span class="line">       &#x2F;*</span><br><span class="line">       buf1 &#x3D; hello</span><br><span class="line">   buf2 &#x3D; world</span><br><span class="line">       *&#x2F;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="c">#include &lt;string.h&gt;int main() &#123;    int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;    /*    使用memcpy()最好别出现内存重叠，如果出现最好使用memmove()    memcpy(&amp;a[2],a,5*sizeof(int));    */    memmove(&amp;a[2],a,5*sizeof(int));    return 0;&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;c</span><br><span class="line">   #include &lt;string.h&gt;</span><br><span class="line">   int main() &#123;</span><br><span class="line">       int a[5] &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">       int b[5] &#x3D; &#123;1,2,3,4,6&#125;;</span><br><span class="line">       int flag &#x3D; memcmp(a,b,5*sizeof(int));</span><br><span class="line">       &#x2F;*</span><br><span class="line">       flag &lt; 0: a &lt; b;</span><br><span class="line">       flag &gt; 0: a &gt; b;</span><br><span class="line">       flag &#x3D; 0: a &#x3D; b;</span><br><span class="line">       *&#x2F;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p><strong>堆区内存分配和释放</strong></p><p>指针指向堆区空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//malloc分配堆区空间，成功返回void*，需要转int*，失败返回NULL</span></span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//手动释放p指向的堆区空间，同一块内存只能释放一次，释放完就不能用了</span></span><br><span class="line">        p = <span class="literal">NULL</span>;<span class="comment">//p的值还是原先的，需要设置为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中不手动释放程序结束也会回收内存，但如果是服务器上的程序是不会结束的，如果只分配不释放就会造成<code>内存泄露：动态分配了内存，不释放</code>,如果windows，andriod长期不关机，就会很卡，重启就好了也是这个原因。</p><p>内存污染：非法操作内存，就是野指针。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C基础</title>
      <link href="2020/01/31/C++/%E5%9F%BA%E7%A1%80/"/>
      <url>2020/01/31/C++/%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p><strong>system</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    system(<span class="string">&quot;ls&quot;</span>);<span class="comment">//这个函数可以执行系统命令</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = system(<span class="string">&quot;./demo&quot;</span>);<span class="comment">//执行上面的程序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret);<span class="comment">//ret就是main函数的返回值，不同平台返回值不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编译步骤</strong></p><ol><li><p>预处理：宏定义展开，头文件展开，条件编译等，同时删除注释，不检查语法，头文件展开就是把.h文件的内容替换到.c文件中。</p><p><code>gcc -E hello.c -o hello.i</code></p></li><li><p>编译：检查语法，将预处理后的文件编译生成汇编文件。</p><p><code>gcc -S hello.i -o hello.s</code></p></li><li><p>汇编：将汇编文件生成目标文件（二进制文件）。</p><p><code>gcc -c hello.s -o hello.o</code></p></li><li><p>链接：C程序是需要依赖各种库的，所以编译之后还需要把库链接到最后的可执行程序中，程序依赖的动态库要么在环境变量中，要么在同一个目录下，lld命令可以查看一个可执行文件需要的动态库。</p><p><code>gcc hello.o -o hello</code> </p></li></ol></li><li><p><strong>声明定义</strong></p><ul><li><code>extern int a;</code> 声明外部文件已经定义过a了，不建立存储空间</li><li><code>int b = 10;</code> 定义，建立存储空间</li></ul></li><li><p><strong>进制</strong></p><p>int a = 123;    //10进制<br>int b = 0123;    //8进制<br>int c = 0x123;    //16进制</p><p>1Kb = 1024bit<br>1KB = 1024Byte</p><p>‘\0’ === 0 === NULL    //字符’\0’等价于数字0等价于NULL<br>字符数组最后一个是’\0’就是字符串</p><p>C语言支持8进制16进制转义字符</p></li><li><p><strong>汇编</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">__asm &#123;</span><br><span class="line">    mov a,<span class="number">3</span><span class="comment">//3的值放在a对应内存的位置</span></span><br><span class="line">    mov b,<span class="number">4</span><span class="comment">//4的值放在b对应内存的位置</span></span><br><span class="line">    mov eax,a<span class="comment">//把a内存的值放在eax寄存器</span></span><br><span class="line">    add eax,b<span class="comment">//eax和b相加，结果放在eax</span></span><br><span class="line">    mov c,eax<span class="comment">//eax的值放在c中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c);<span class="comment">//&quot;7&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>原码补码反码</strong></p><ul><li>原码：最高位为符号位，正数为0，负数为1。</li><li>反码：<ul><li>正数原码和反码一致。</li><li>负数反码：原码符号位不变，其他位取反。</li></ul></li><li>补码：计算机采取补码存储数据<ul><li>正数原码，反码，补码一致。</li><li>负数补码：反码+1。</li></ul></li></ul></li><li><pre><code class="c">fgets(buf,100,stdin);        //读99位到buf包括\nfputs(buf,stdout);            //输出bufstrncpy(dst,src,10);        //拷贝10个字符strncatstrncmpsprintf(buf,&quot;a=%d\n&quot;,10);    //buf = &quot;a=10\n&quot;char buf[] = &quot;10&quot;;sscanf(buf,&quot;%d&quot;,&amp;a);        //从buf读取写到a中strstr()                    //查字串strchr()                    //查字符strtok(buf,&quot;,&quot;);            //切割字串strtok(NULL,&quot;,&quot;);            //第二次切割atoi();atof();atol();        //字串转int，float，long<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">8. **指针**</span><br><span class="line"></span><br><span class="line">   - 野指针：指向无意义的地址，本身无错，但是若要操纵内存就会有问题。</span><br><span class="line"></span><br><span class="line">   - 不可以定义void变量，但可以定义void*万能指针，因为地址大小是固定的，万能指针可以指向任何类型的变量，但是操作内存时需要转换为具体类型。</span><br><span class="line"></span><br><span class="line">   - 数组名是个常量，是不能改变的，他的值为第一个元素的地址。</span><br><span class="line"></span><br><span class="line">   - &#96;&#96;&#96;c</span><br><span class="line">     const int * p &#x3D; &amp;a;</span><br><span class="line">     int const * p &#x3D; &amp;a;&#x2F;&#x2F;这两个等价，*p&#x3D;1可以，p&#x3D;NULL不行</span><br><span class="line">     </span><br><span class="line">     int * const p &#x3D; &amp;a;&#x2F;&#x2F;p&#x3D;NULL可以，*p&#x3D;1不行</span><br></pre></td></tr></table></figure>- ```c  char *p = &quot;hello&quot;;    //在栈，常量，不能改  char p[] = &quot;hello&quot;;    //在堆，数组，可以改</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.复合数据类型</title>
      <link href="2020/01/31/go/4.%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/01/31/go/4.%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>数组和结构体都是聚合类型，他们的值由内存中的一组变量构成。数组元素相同，结构体元素可以不同，他们的长度都是固定的。slice和map都是动态数据结构，他们的长度随着元素的添加动态增长。</p><a id="more"></a><ol><li><p><strong>数组</strong></p><ul><li><p>在数组字面量中，如果省略号…出现在数组长度的位置，那么数组的长度由初始化的数组的元素个数决定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;%T\n&quot;</span>,q)<span class="comment">//&quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>数组的长度是数组类型的一部分，[3]int和[4]int是两种不同的数组类型，数组的长度必须是常量表达式，在编译时就确定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">q = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure></li><li><p>上面是按顺序给出一组值，也可以给出索引和索引对应的值，这样索引可以以任意顺序出现，还可以省略，省略的会被赋为零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Currency <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">USD Currency = <span class="literal">iota</span></span><br><span class="line">    RMb</span><br><span class="line">)</span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;USD:<span class="string">&quot;$&quot;</span>,RMB:<span class="string">&quot;¥&quot;</span>&#125;</span><br><span class="line">fmt.Println(RMB,symbol[RMB]) <span class="comment">//&quot;3 ¥&quot;</span></span><br><span class="line"></span><br><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>:<span class="number">-1</span>&#125;<span class="comment">//第100个-1，其余0</span></span><br></pre></td></tr></table></figure></li><li><p>如果一个数组的元素类型是可比较的，那么这个数组也是可比较的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">c := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a==b,a==c,b==c)<span class="comment">//&quot;true false false&quot;</span></span><br><span class="line">d := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(a==d)<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure></li><li><p>当调用函数时，传入的参数会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本而不是原始的参数。这种方式在传递大数组的时候会很低效。这种情况下，go把数组和其他类型都看成值传递，而在其他语言中，数组是隐式的使用引用传递。</p><p>也可以显示传递一个数组的指针，这样在函数内部对数组的任何修改都会反映到原始数组上面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">/*for i := range ptr &#123;</span></span><br><span class="line"><span class="comment">        ptr[i] = 0</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    *ptr = [<span class="number">32</span>]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>slice</strong></p><ul><li><p>slice表示拥有相同类型元素的可变长度序列，通常写成[]T，数组和slice是紧密关联的，slice可以访问数组的部分或全部的元素，而这个数组成为slice的底层数组。</p></li><li><p>slice有三个属性：指针，长度，容量。指针指向数组的第一个可以从slice访问的元素，长度指slice元素个数，它不能超过容量，容量的大小通常是从slice的起始元素到底层数组最后一个元素间的元素个数。</p></li><li><p>一个底层数组可以对应多个slice，这些slice可以引用数组任何位置，彼此还可重叠。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="keyword">string</span>&#123;<span class="number">1</span>:<span class="string">&quot;January&quot;</span>,...,<span class="number">12</span>:<span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>] <span class="string">&quot;6,7,8&quot;</span></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="string">&quot;6,7,8,9,10&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化slice不指定长度，创建指向数组的slice。和数组不同，slice无法比较，但可以使用bytes.Equal来比较两个字节slice，但对于其他类型slice需要自己写函数比较。slice允许和nil比较，值为nil的slice没有对应的底层数组</p><p><code>s := []int&#123;1,2,3,4,5&#125;</code></p></li><li><p>内置函数make可以创建一个具有指定元素类型，长度，容量的slice，其中容量参数可以省略，这种情况下容量等于长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T,<span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T,<span class="built_in">len</span>,<span class="built_in">cap</span>) <span class="comment">//等同于make([]T,cap)[:len]</span></span><br></pre></td></tr></table></figure><p>其实make是创建了一个无名数组并返回了它的一个slice，这个数组仅可以通过这个slice访问，容量就是数组的长度。</p></li><li><p>append函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">...</span><br><span class="line">fmt.Println(x)<span class="comment">//&quot;[1,2,3,4,5,6]&quot;</span></span><br></pre></td></tr></table></figure><p>当容量不足时，会创建一个新的数组并指向它。</p></li></ul></li><li><p><strong>map</strong></p><ul><li><p>go语言中，map是散列表的引用。内置函数make创建一个map：</p><p><code>ages := make(map[string]int)</code></p></li><li><p>也可以使用map字面量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>:<span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>:<span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">31</span></span><br><span class="line">ages[<span class="string">&quot;charlie&quot;</span>] = <span class="number">34</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用内置函数delete移除一个元素。</p><p><code>delete(ages,&quot;alice&quot;)</code></p></li><li><p>如果map中没有某个键，使用时返回类型零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">&quot;bob&quot;</span>] = ages[<span class="string">&quot;bob&quot;</span>] + <span class="number">1</span></span><br><span class="line">ages[<span class="string">&quot;bob&quot;</span>] += <span class="number">1</span></span><br><span class="line">ages[<span class="string">&quot;bob&quot;</span>]++ <span class="comment">//三者等价</span></span><br></pre></td></tr></table></figure></li><li><p>map元素不是一个变量，无法获取地址，因为map的可增长性导致每一个元素的地址是动态的，这样就可能使获得的地址无效。</p></li><li><p>map中元素迭代是无序的，如果需要按照某种顺序遍历map中的元素，必须显式的给键排序，也就是拿个切片存键，对切片排序，再通过切片遍历键值。</p></li></ul></li><li><p><strong>结构体</strong></p><ul><li><p>聚合类型不可以包含他自己，但是命名结构体中可以定义一个它的指针，这样我们可以创建一些递归数据结构，比如链表和树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">    left,right *tree<span class="comment">//二叉树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结构体类型的值可以通过结构体字面量设置，即通过设置结构体的成员变量来设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;X,Y <span class="keyword">int</span>&#125;</span><br><span class="line">p := Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;X:<span class="number">1</span>,Y:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于结构体都是通过指针的方式使用，因此可以使用一种简单的方式创建初始化一个struct类型的变量并获取他的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pp := &amp;Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line">pp := <span class="built_in">new</span>(Point)</span><br><span class="line">*pp = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果结构体所有变量成员都可以比较，那么这个结构体也可以使用==或者!=比较，其中==按照顺序比较成员变量，可比较的结构体可以作为map的键类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class="comment">//&quot;false&quot;</span></span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line">fmt.Println(p == q)  <span class="comment">//&quot;false&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Go允许定义不带名称的结构体成员，只需要指定类型即可，这种结构体成员称作匿名成员，匿名成员必须是一个命名类型或命名类型的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X,Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w wheel</span><br><span class="line">w.X = <span class="number">8</span><span class="comment">//等价于w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span><span class="comment">//等价于w.Circle.Point.Y = 8，如果是circle，point那么在包外不能这么用</span></span><br><span class="line">w.Radius = <span class="number">5</span><span class="comment">//等价于w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是不能这么干:</span></span><br><span class="line">w = Wheel&#123;<span class="number">8</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">20</span>&#125;<span class="comment">//编译错误，未知成员变量</span></span><br><span class="line">w = Wheel&#123;X:<span class="number">8</span>,Y:<span class="number">8</span>,Radius:<span class="number">5</span>,Spokes:<span class="number">20</span>&#125;<span class="comment">//编译错误，未知成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以这样:</span></span><br><span class="line">w = Wheel&#123;Circle&#123;Point&#123;<span class="number">8</span>,<span class="number">8</span>&#125;,<span class="number">5</span>&#125;,<span class="number">20</span>&#125;</span><br><span class="line"><span class="comment">//或者这样</span></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle:Circle&#123;</span><br><span class="line">        Point:Point&#123;X:<span class="number">8</span>,Y:<span class="number">8</span>&#125;,</span><br><span class="line">        Radius:<span class="number">5</span>,<span class="comment">//逗号必须有</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes:<span class="number">20</span>,<span class="comment">//逗号必须有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>,w)</span><br><span class="line"><span class="comment">//&quot;Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8,Y:8&#125;,Radius:5&#125;,Spokes:20&#125;&quot;</span></span><br><span class="line"><span class="comment">//%#v格式带着X:,Y:这些东西</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gpl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.基本数据类型</title>
      <link href="2020/01/31/go/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/01/31/go/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li>计算机的底层是位（bit），而实际操作是基于大小固定的单元中的数值，称为字（word），可以解释为整数，浮点数，位集（bitset）或内存地址等。</li><li>go四大类数据类型：<ul><li>基础类型<ul><li>数字</li><li>字符串</li><li>布尔型</li></ul></li><li>聚合类型<ul><li>数组</li><li>结构体</li></ul></li><li>引用类型<ul><li>指针</li><li>切片</li><li>map</li><li>函数</li><li>通道</li></ul></li><li>接口类型</li></ul></li></ol><table><thead><tr><th>类别</th><th>表示</th></tr></thead><tbody><tr><td>有符号整数</td><td>int8/int16/int32/int64</td></tr><tr><td>无符号整数</td><td>uint8/uint16/uint32/uint64</td></tr><tr><td>原生整数</td><td>int/uint 与系统位数一致</td></tr><tr><td>rune</td><td>同int32 指明unicode码点</td></tr><tr><td>byte</td><td>同int8 强调原始数据而非量值</td></tr><tr><td>uintptr</td><td>无符号整数，大小不明，存放指针</td></tr><tr><td>float32</td><td>精度大约6位</td></tr><tr><td>float64</td><td>精度大约15位</td></tr><tr><td>complex64</td><td>复数，由float32构成</td></tr><tr><td>complex128</td><td>复数，由float64构成</td></tr><tr><td>bool</td><td>无法隐式转换为数值，反之也不行</td></tr></tbody></table><ol start="3"><li><p>字符串字面量</p><ul><li><code>s[i, j]</code>生成子串</li><li>使用utf8编码，非ascii字符码点需要两个或多个字节</li><li>可以用加号连接字串</li><li>字串间可以比较</li><li>字串可以赋值，不可改变，这意味着两个字串可以共用一个底层</li><li>``原样字串，忽略换行</li></ul></li><li><p>编码</p><ol><li><p>ASCII码：7位表示128个字符</p></li><li><p>Unicode码：包含世界上所有字符，各自有一个叫Unicode码点的标准数字，go中称为文字符号（rune），大约有十二万字符，int16存不下，int32刚好可以，也就是rune。我们可以让每个字符都占32位，即utf32，但是太浪费了，所以采用了utf8编码。</p></li><li><p>UTF-8编码：每个字符用1-4个字节表示，go中允许如下表示。</p><p><code>\xhh</code>    h式十六进制数字，大小写皆可，且必须是两位</p><p><code>\ooo</code>    八进制，必须使用三位数字，且不超过\377</p><p><code>\uhhh</code>    16位码点值</p><p><code>\Uhhhhhhhh</code>    32位码点值</p><p>当[]rune作用于utf8编码的字串时，返回unicode码点序列</p></li></ol></li><li><p>字符串和字节切片</p><ol><li><p><code>strings</code>包：搜索，替换，比较，修整，切分，连接字符串</p></li><li><p><code>bytes</code>包：类似<code>strings</code>用于操作[]byte类型</p></li><li><p><code>strconv</code>包：布尔值，整数，浮点数与字符串间的转换，还有为字符串添加/去除引号的函数</p></li><li><p><code>unicode</code>包：有判别文字符号值特性的函数，如IsDigit，IsLetter，IsUpper，IsLower</p></li><li><p>字符串可以和字节切片相互转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line">s2 := <span class="keyword">string</span>(b)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>字符串和数字的相互转换</p><ol><li><p>整数转字符串</p><ol><li><p><code>fmt.Sprintf</code></p></li><li><p><code>strconv.Itoa</code></p><p>x := 123<br>y := fmt.Sprintf(“%d”,x)<br>fmt.Println(y,strconv.Itoa(x))    //“123 132”</p></li><li><p>按不同进位制格式化数字<br><code>fmt.Println(strconv.FormatInt(int64(x),2))     //&quot;1111011&quot;</code></p><p><code>fmt.Printf</code>里的<code>%b,%d,%o,%x</code>往往比Format方便</p><p><code>s := fmt.Sprintf(&quot;x=%b&quot;,x)   //&quot;x=1111011&quot;</code></p></li></ol></li><li><p>字符串转整数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x,err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)<span class="comment">//x是整形</span></span><br><span class="line">y,err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>,<span class="number">10</span>,<span class="number">64</span>)<span class="comment">//十进制，int64类型</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>常量</p><ol><li><p>常量是一种表达式，在编译阶段就计算出表达式的值，常量本质上都属于基本类型，对于常量操作数，所有数学运算，逻辑运算和比较运算后的结果依然是常量</p></li><li><pre><code class="go">const (    a = 1    b    c = 2    d)            //a=1 b=1 c=2 d=2<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. &#96;&#96;&#96;go</span><br><span class="line">   const (</span><br><span class="line">       _ &#x3D; 1 &lt;&lt; (10 * iota)</span><br><span class="line">       KiB&#x2F;&#x2F;1024</span><br><span class="line">       MiB&#x2F;&#x2F;1048576</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></code></pre></li><li><p>无类型常量精度可以很高，常量声明（包扩短变量声明）都是有类型的，<code>const a = 1024</code>这样没有</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gpl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.程序结构</title>
      <link href="2020/01/31/go/2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>2020/01/31/go/2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p>Go语言中，名称的作用域越大，名称越长且越有意义。</p></li><li><p>包级初始化在main函数开始前执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number0</span><br><span class="line">bool false</span><br><span class="line">string&quot;&quot;</span><br><span class="line">接口&#x2F;引用类型(slice,指针,map,通道,函数)nil</span><br></pre></td></tr></table></figure></li><li><p>短声明:=左面至少有一个新变量，对旧变量进行赋值操作。</p></li><li><p><code>new(T)</code>创建未命名的T类型变量，并返回地址。</p></li><li><pre><code class="go">var global *intfunc f() &#123;                //结束后x还可以访问    var x int            //x逃逸了    x = 1                //x被分配在堆空间    global = &amp;x&#125;func g() &#123;                //结束后y被回收了    y := new(int)        //y被分配在栈空间    *y = 1&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 两个变量交换值&#96;x,y &#x3D; y,x&#96;</span><br><span class="line"></span><br><span class="line">7. 在包级别，变量的声明顺序和作用域无关</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;go</span><br><span class="line">   package main&#x2F;&#x2F;这是可以的，但是:&#x3D;定义不行</span><br><span class="line">   var a &#x3D; b + 1&#x2F;&#x2F;main()里不行</span><br><span class="line">   var b &#x3D; 1</span><br></pre></td></tr></table></figure></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gpl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.入门</title>
      <link href="2020/01/31/go/1.%E5%85%A5%E9%97%A8/"/>
      <url>2020/01/31/go/1.%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p>一个go程序由一package开始，随后由四大块组成：变量（var），函数（func），常量（const），类型（type）。</p></li><li><p>os.Args类似c语言main函数的arg参数，本质是一个字符串切片，go中的[m,n]是左闭右开区间。</p></li><li><p>使用+=追加字符串需要生成中间变量，使用strings.join更加高效。</p></li><li><p>type用于自定义一个类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> celsius  <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> fahrenheit <span class="keyword">float64</span></span><br></pre></td></tr></table></figure><p>celsius类型和fahrenheit类型底层类型都是float64，但他们不是同一个类型，和float64也不是同一个类型，他们之间可以通过显示类型转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c celsius</span><br><span class="line"><span class="keyword">var</span> f fahrenheit</span><br><span class="line">c = <span class="number">32.0</span></span><br><span class="line">f = fahrenheit(c)</span><br></pre></td></tr></table></figure><p>显示类型转换需要底层类型相同，只改变类型，不改变值，但类似int和float这种转换，值会被改变。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gpl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="2020/01/31/other/markdown/"/>
      <url>2020/01/31/other/markdown/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><table><thead><tr><th>标记</th><th>语法</th></tr></thead><tbody><tr><td>一级标题</td><td>#text</td></tr><tr><td>四级标题</td><td>####text</td></tr><tr><td>粗体</td><td>**text**</td></tr><tr><td>斜体</td><td>*text*</td></tr><tr><td>斜体加粗</td><td>***text***</td></tr><tr><td>删除线</td><td>~~text~~</td></tr><tr><td>引用</td><td>&gt;text</td></tr><tr><td>图片</td><td>![alt](url “title”)</td></tr><tr><td>超链接</td><td>[baidu](<a href="http://baidu.com/">http://baidu.com</a>)</td></tr><tr><td>无序列表</td><td>- text</td></tr><tr><td>有序列表</td><td>1. text</td></tr><tr><td>表格</td><td>|head1|head2|head3|</td></tr><tr><td></td><td>|:-|:-:|-:|</td></tr><tr><td></td><td>|居左|居中|居右|</td></tr><tr><td>单行代码</td><td>`fmt.Println(“hello world!”)`</td></tr><tr><td>代码块</td><td>```</td></tr><tr><td></td><td>str := “hello world!”</td></tr><tr><td></td><td>fmt.Println(str)</td></tr><tr><td></td><td>```</td></tr></tbody></table><p><strong>MarkDown文件使用VsCode/NotePad++等都可以进行编辑，或者使用专门的MarkDown编辑器：<a href="https://www.typora.io/">Typora</a>,有实时渲染的功能，更加方便编辑。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dos命令</title>
      <link href="2020/01/31/other/dos%E5%91%BD%E4%BB%A4/"/>
      <url>2020/01/31/other/dos%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>切换目录</td><td>cd</td></tr><tr><td>查看目录下的文件</td><td>dir</td></tr><tr><td>创建目录</td><td>md</td></tr><tr><td>创建文件</td><td>cd &gt; 1.txt</td></tr><tr><td>删除目录</td><td>rd/s</td></tr><tr><td>删除文件</td><td>del 1.txt</td></tr><tr><td>创建/重写文件</td><td>echo 666 &gt; 1.txt</td></tr><tr><td>追加文件内容</td><td>ehco 777 &gt;&gt; 1.txt</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> dos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="2020/01/31/other/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2020/01/31/other/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td></tr><tr><td>\.</td><td>匹配’ . ‘这个字符</td></tr><tr><td>\w</td><td>匹配数字/大小写字母/下划线</td></tr><tr><td>\W</td><td>匹配\w的补集</td></tr><tr><td>\d</td><td>匹配整数</td></tr><tr><td>\D</td><td>匹配\d的补集，包括空格</td></tr><tr><td>\s</td><td>匹配空格，制表符，断行</td></tr><tr><td>\S</td><td>匹配\s的补集</td></tr><tr><td>[]</td><td>匹配任一字符</td></tr><tr><td>[abc]</td><td>匹配字符a或字符b或字符c</td></tr><tr><td>[a-z]</td><td>匹配字符a到字符z</td></tr><tr><td>[\u4e00-\u9fa5]</td><td>还可以用unicode码，这里匹配所有汉字</td></tr><tr><td>[]+</td><td>重复匹配一次或多次</td></tr><tr><td>li+</td><td>匹配li lii lii …</td></tr><tr><td>[]*</td><td>重复匹配零次或多次</td></tr><tr><td>[]?</td><td>匹配零次或一次</td></tr><tr><td>[]{a,b}</td><td>重复匹配a-b次</td></tr><tr><td>[]{a,}</td><td>重复匹配a到多次</td></tr><tr><td>[]{a}</td><td>重复匹配a次</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>()</td><td>分组</td></tr></tbody></table><center style="color:orange">    *带'\'的字符应用在具体语言中可能需要转义</center>]]></content>
      
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git ssh</title>
      <link href="2020/01/31/other/Git_ssh/"/>
      <url>2020/01/31/other/Git_ssh/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4>step one：查看本地是否配置过ssh key</h4><p><img src="https://img-blog.csdnimg.cn/20190816213643404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>如果用户目录中的.ssh目录有id_rsa，id_rsa.pub，说明你之前配置过ssh，可以直接跳到第三步。如果没有，我们需要创建一个ssh key。</p><h4>step two：创建ssh key</h4><p><img src="https://img-blog.csdnimg.cn/20190816213705742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>如上图使用<code>ssh-keygen</code>命令，然后一路回车，然后你就可以在.ssh目录看到id_rsa.pub，id_dsa.pub这两个文件了。</p><h4>step three：添加ssh key到github</h4><p><img src="https://img-blog.csdnimg.cn/20190816213723178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20190816213736516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20190816213757989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20190816213809307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>一路下来就成功的添加ssh key了。</p><h4>step four：让我们试试</h4><p><img src="https://img-blog.csdnimg.cn/20190816213823828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/2019081621384124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>到这里，我们已经把本地的https链接换成了ssh链接，现在让我们修改下项目并同步到远程仓库吧！</p><p><img src="https://img-blog.csdnimg.cn/20190816213921762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20190816213936563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>我们修改了本地仓库同步远端，可以看到并没有提示需要验证密码。</p><p>现在我们的ssh已经配置成功了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git three</title>
      <link href="2020/01/31/other/Git_three/"/>
      <url>2020/01/31/other/Git_three/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>先让我们看一下现在我们本地工作区的情况。</p><p><img src="https://img-blog.csdnimg.cn/201908162130222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>上一节我们将b2分支的内容合并到了master分支，并解决了冲突，接着我们删掉了b1 b2两个分支。</p><p>现在请大家考虑一下情况，假如我们的项目需要多个人开发，我们该如何做到项目组的每个人都能实时共享项目的最新状态呢？又或者只有自己一个人做开发，但如果我们自己的电脑炸了，又没有备份该怎么解决呢？这里我们就要提到远程仓库的概念。</p><p>我们可以使用git工具在另一台电脑上创建一个远程的仓库，但很显然这需要我们在准备一台电脑用作仓库使用，但这样做不仅需要成本，而且我们自己的电脑也不稳定，显然这并不是好的选择。我们可以用作项目托管的公司提供的免费的远程仓库，像是github,gitlab,码云等等都可以为我们提供免费的远程仓库。</p><p>下面我以github为例，教大家如何创建一个自己的仓库。</p><h3>1.注册<a href="https://github.com">github</a>账号</h3><p><img src="https://img-blog.csdnimg.cn/20190816213106351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>就正常的填一下用户名，邮箱，密码就好，然后他会给你发个验证邮件，验证之后就注册好了。这里的用户名尽量都用小写的吧，也不是大写不行，就是个人的建议。</p><h3>2.创建新的仓库</h3><p><img src="https://img-blog.csdnimg.cn/20190816213145157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20190816213205648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20190816213220167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>按照上面的流程一步步操作，我们就创建好了自己的远程仓库。上图中https和ssh的区别是前者操作你的仓库的时候需要认证你的github账号密码，后者需要在本地配置ssh再操作仓库就不需要github账号密码了。这里我们先使用https，<a href="https://www.lisuqing.xyz/post/github%E9%85%8D%E7%BD%AEssh/">ssh</a>的配置会在之后发布。</p><p><img src="https://img-blog.csdnimg.cn/20190816213244844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>git remote add name https://</code>命令可以添加一个远程仓库，需要你指定仓库名字和地址。<code>git remote</code>可以查看你添加的远程仓库。<code>git push -u name branch</code>命令第一次同步本地到远端需要指定name：名字和branch：分支。在之后的同步操作只需要<code>git push</code>就可以了。</p><p>现在让我们去github上查看我们的项目是否已经同步到了远端。</p><p><img src="https://img-blog.csdnimg.cn/20190816213319202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>可以看到我们的123.txt文件已经成功的在github上显示出来了。</p><p>假如我们的伙伴小红觉得我们的代码写的非常好，想拿到我们的代码学习一下，那么小红该如何获取我们远程仓库的代码呢？<br><img src="https://img-blog.csdnimg.cn/20190816213351444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>经过小红的一番操作，她终于拿到了项目的代码。<code>git pull</code>命令可以拉取指定仓库指定分支的内容。但小粉觉得小红的操作太复杂了，让我们看看小粉是如何操作的。</p><p><img src="https://img-blog.csdnimg.cn/20190816213418182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>小粉直接使用了<code>git clone https://</code>命令克隆了test仓库到本地，可以在test目录下看到我们的123.txt。</p><p>我们也可以随时删除我们在github上的仓库。</p><p><img src="https://img-blog.csdnimg.cn/20190816213441816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20190816213455391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>github可能还会提示你输入账户和密码，输入后就可以成功删除你的仓库了。</p><p>恭喜你，现在你已经学会git和github的基础使用了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git two</title>
      <link href="2020/01/31/other/Git_two/"/>
      <url>2020/01/31/other/Git_two/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>一.git tag</h3><p>上一节中我们讲到了历史commit节点的回滚操作，如果说每一个commit节点是你项目的一个小版本的话，那么<code>git tag</code>将帮助你标识项目的大版本。</p><p><img src="https://img-blog.csdnimg.cn/20190816212530782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>当前状态中，我们已经对我们的123项目提交了三个小版本，我们使用了<code>git tag v1.0</code>命令标识我们的最后一次提交为v1.0版本。<code>git tag</code>命令可以查看当前项目的所有版本。</p><p><img src="https://img-blog.csdnimg.cn/20190816212549426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>如果我们相对之前的提交记录标记版本，我们可以附上对应提交记录的id，使用<code>git tag v0.1 d9d07a1</code>标记我们的第一次提交为v0.1版本。</p><p><img src="https://img-blog.csdnimg.cn/20190816212606701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>tag标签的好处是，一旦我们的提交记录多起来，我们可以通过<code>git tag</code>命令查看项目大的更新，并且可以使用<code>git checkout v0.1</code>命令回退到我们的v0.1版本。</p><h3>二.git branch</h3><p>我们可以把我们的工作区想象成一颗树，最开始我们的树只有一根主干，而我们可以随时从主干创建一条分支，即branch。<br><img src="https://img-blog.csdnimg.cn/20190816212623883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>git branch</code>查看所有的分支，<code>git branch b1</code>创建一个名为b1的分支，<code>git checkout b1</code>切换到b1分支。或者你可以使用<code>git checkout -b b2</code>创建并切换到b2分支。</p><p><img src="https://img-blog.csdnimg.cn/2019081621264419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>由于我们是在master主分支的v0.1版本切换到b2分支，所以我们在b2分支中看到的123.txt也是我们第一次提交的内容，现在我们在b2分支中基于v0.1版本添加一行文本保存并提交。</p><p><img src="https://img-blog.csdnimg.cn/20190816212700808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>现在我们回到master分支，可以看到123.txt并没有在v0.1版本。而是最新的版本，这是因为我们之前回退到v0.1版本时并没有做任何的修改提交操作，所以当我们再次回到master的时候，123.txt依旧是最新版本。并且我们并没有发现我们在b2分支中添加的”我是b2”内容。</p><p><img src="https://img-blog.csdnimg.cn/20190816212718473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>我们使用<code>git merge b2</code>命令将b2分支合并到当前分支即master主分支中，可以看到git提示我们发生了冲突。被&lt;&lt;&lt;,&gt;&gt;&gt;包围的部分即为冲突部分，这时候需要我们自己手动解决冲突。</p><p><img src="https://img-blog.csdnimg.cn/20190816212739997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>我们手动把冲突解决后，即可正常添加缓存并提交了。</p><p><img src="https://img-blog.csdnimg.cn/20190816212800199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>如果你在合并分支后不想继续保留b1,b2分支，可以使用<code>git branch -D b1 b2</code>来删除b1 b2分支。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git one</title>
      <link href="2020/01/31/other/Git_one/"/>
      <url>2020/01/31/other/Git_one/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>一.Git的安装配置</h3>这里以windows系统为例，如果你的系统是linux，那我默认你已经能够熟练使用或独立安装配置Git工具，如果你的系统是mac，对不起，没有，告辞。<p>32位系统点<a href="https://github.com/git-for-windows/git/releases/download/v2.22.0.windows.1/Git-2.22.0-32-bit.exe">这里</a>，64位系统点<a href="https://github.com/git-for-windows/git/releases/download/v2.22.0.windows.1/Git-2.22.0-64-bit.exe">这里</a>，下载完成后双击打开，你可以自定义Git的安装路径，其余一路默认即可。</p><p>安装完成后，打开控制台，输入<code>git version</code>查看版本，若有类似如下提示，即为安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">git version 2.22.0.windows.1</span><br></pre></td></tr></table></figure><p>你还需要在本地配置好你的昵称和用户名。</p><p><img src="https://img-blog.csdnimg.cn/20190816211415157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>你可以使用<code>git config user.name</code>,<code>git config user.email</code>查看当前的昵称和邮箱。</p><h3>二.Git的素质三连</h3>这一步我默认你了解基本的[Dos命令](http://greensburst.github.com/post/dos命令/)，想要快速上手使用Git你需要知道下面的三个命令。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190816211509168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>git init &lt;文件夹名&gt;</code></p><p>“init”作initialization初始化的简写，该命令会初始化一个git工作区，若不指定文件夹名，则当前所在目录会被初始化为一个git工作区。</p><p>这时控制台会显示你的工作区有修改，在123.txt这个文件中。</p><p><img src="https://img-blog.csdnimg.cn/20190816211529243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>git add &lt;文件名&gt;</code></p><p>该命令可以将文件添加到git缓存区，使用<code>git add -A</code>可将当前目录所有改动同步到缓存区，包括添加修改删除操作，<code>git add .</code>会将当前目录的修改和添加同步到缓存区。</p><p><img src="https://img-blog.csdnimg.cn/20190816211546738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>git commit -m &quot;本次提交的描述信息&quot;</code></p><p>当你觉得自己的项目到了一定的阶段，就可以使用该命令将你的工作区提交到本地仓库，-m参数即为你对本次提交的描述，这个参数是必须要有的。</p><p><img src="https://img-blog.csdnimg.cn/20190816211607371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>git log --oneline</code></p><p>我们继续添加一行内容并保存到我们的本地仓库，使用该命令可以查看我们的历史提交记录，可以看到我们一共做了两次提交，标识名为别为973077d，ba0fca1。</p><p><img src="https://img-blog.csdnimg.cn/20190816211626183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p><code>git checkout &lt;标识名&gt;</code></p><p>该命令体现了git工具的强大之处，我们可以使用这条命令随时回退到我们之前提交的版本，可以看到我们执行<code>type 123.txt</code>已经显示内容只剩下一行”111”，已经成功的回退到我们的第一个版本了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.包管理</title>
      <link href="2020/01/31/linux/7.%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>2020/01/31/linux/7.%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p><strong>dpkg</strong></p><ul><li><code>dpkg -i package.deb</code> 安装包</li><li><code>dpkg -r package</code> 删除包</li><li><code>dpkg -P package</code> 删除包及配置文件</li><li><code>dpkg -L package</code> 列出与该包关联的文件</li><li><code>dpkg -l package</code> 显示该包的版本</li><li><code>dpkg --unpack package.deb</code> 解开deb包的内容</li><li><code>dpkg -S keyword</code> 搜索所属的包内容</li><li><code>dpkg -l</code> 列出当前已安装的包</li><li><code>dpkg -c package.deb</code> 列出deb包的内容</li><li><code>dpkg --configure package</code> 配置包</li></ul></li><li><p><strong>apt-get</strong></p><ul><li><code>apt-get update</code>  更新软件包列表</li><li><code>apt-get install packagename</code> 安装一个新软件包</li><li><code>apt-get remove packagename</code> 卸载一个软件包（保留配置文件）</li><li><code>apt-get -purge remove packagename</code> 卸载一个软件包（删除配置文件）</li><li><code>apt-get autoclean apt</code> linux会把已装已卸的软件都备份在硬盘上，这个命令可以删除已经删掉的软件</li><li><code>apt-get clean</code> 删除安装的软件备份，不过不影响软件使用</li><li><code>apt-get upgrade</code> 更新所有以安装的软件包</li><li><code>apt-get dist-upgrade</code> 将系统升级到新版本</li><li><code>apt-get autoclean</code> 清除已卸载的软件包的.deb文件，而<code>apt-get clean</code>会将已安装软件包的.deb文件也一并删除</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.磁盘分区</title>
      <link href="2020/01/31/linux/6.%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
      <url>2020/01/31/linux/6.%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p><strong>分区的方式</strong></p><ol><li>mbr分区<ul><li>最多支持四个主分区</li><li>系统只能安装在主分区</li><li>扩展分区要占一个主分区</li><li>mbr最大只支持2TB，但拥有最好的兼容性</li></ul></li><li>gpt分区<ul><li>支持无限多个主分区（但操作系统可能显示，比如windows最多128主分区）</li><li>最大支持18EB（1024*1024TB）的大容量</li><li>windows7 x64后以后支持gpt</li></ul></li></ol></li><li><p><strong>linux磁盘分区</strong></p><ol><li><p>linux可以使用挂载（mount）将一个分区和一个目录联系起来，反之成为卸载（umount）</p></li><li><p>硬盘说明：</p><ul><li>linux硬盘分为IDE硬盘和SCSI硬盘，现在基本都是SCSI硬盘</li><li>对于IDE硬盘，驱动器标识符为”hdx<del>“，其中”hd”表明分区所在设备类型，这里指IDE硬盘，”x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），”</del>“代表分区，前四个分区用1-4表示，他们是主分区或扩展分区，从5开始就是逻辑分区。例：hda3表示第一个IDE硬盘上的第三个主分区或扩展分区，hdb2表示第二个IDE硬盘上的第二个主分区或扩展分区</li><li>对于SCSI硬盘则标识为”sdx~”，SCSI硬盘用”sd”表示设备类型，其余和IDE硬盘表示方法一样</li><li><code>lsblk -f</code>可以查看磁盘分区</li></ul></li><li><p>如何添加一块硬盘</p><ol><li><p>虚拟机添加硬盘</p></li><li><p>分区：<code>fdisk /dev/sdb</code></p></li><li><p>格式化：<code>mkfs -t ext4 /dev/sdb1</code></p></li><li><p>挂载：<code>mount /dev/sdb1 /home/newdisk</code></p></li><li><p>设置自动挂载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line">&#x2F;dev&#x2F;sdb1 home&#x2F;newdisk ext4 defaults 0 0</span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure></li><li><p>卸载：<code>umount /dev/sdb1c</code></p></li></ol></li></ol></li><li><p><strong>磁盘情况查询</strong></p><ol><li><p>查询系统整体磁盘使用情况：<code>df -lh</code></p></li><li><p>查询制定目录的磁盘占用情况：<code>du -ach --max-depth=1</code></p><ul><li><code>-s</code>指定目录占用大小汇总</li><li><code>-h</code>带计量单位</li><li><code>-a</code>含文件</li><li><code>--max-depth=1</code>子目录深度</li><li><code>-c</code>列出明细的同时，增加汇总值</li></ul></li><li><p>工作使用指令：</p><ol><li><p>统计/home下文件个数：<code>ls -l /home | grep &quot;^-&quot; | wc -l</code></p><ul><li><code>&quot;^-&quot;</code>以-开头的</li><li><code>wc -l</code>统计</li></ul></li><li><p>统计/home下目录个数：<code>ls -l /home | grep &quot;^d&quot; | wc -l</code></p></li><li><p>统计/home下文件个数，包括子目录里的：<code>ls -lR /home | grep &quot;^-&quot; | wc -l</code></p><ul><li><code>-R</code>递归</li></ul></li><li><p>统计/home下目录个数，包括子目录里的：<code>ls -lR /home | grep &quot;^d&quot; | wc -l</code></p></li><li><p>以树状显示目录结构：<code>tree</code></p></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.进程管理</title>
      <link href="2020/01/31/linux/5.%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2020/01/31/linux/5.%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p><strong>显示系统执行的进程</strong></p><ul><li><p><code>ps</code>命令是用来查看目前系统中有哪些进程正在执行，以及他们执行的状况，可以不加任何参数。</p></li><li><p><code>ps -a</code>显示当前终端所有进程信息</p></li><li><p><code>ps -u</code>以用户的格式显示进程信息</p></li><li><p><code>ps -x</code>显示后台进程运行的参数</p></li><li><p><code>ps -e</code>显示所有进程</p></li><li><p><code>ps -f</code>全格式</p></li><li><p><code>ps -j</code>显示更多的用户信息</p></li><li><p><code>ps aux</code> <code>ps ajx</code> <code>ps -ef</code></p><p><img src="https://img-blog.csdnimg.cn/2019090120112355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/201909012011391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p></li></ul></li></ol><ol start="2"><li><p><strong>终止进程</strong></p><ul><li><code>kill [选项] PID</code>通过进程号杀死进程</li><li><code>killall 进程名</code>通过进程名杀死进程，支持通配符，这在系统因负载过大而变得很慢的很有用</li><li>杀死进程本质上是给进程传递一个信号，使用<code>kill -l</code>查看系统支持的信号</li><li><code>kill -9 pid</code>或<code>kill -SIGKILL pid</code>杀死进程，不推荐用数字，因为不同系统编号可能不一样</li><li>SIGKILL SIGSTOP这两个信号程序内是不可被捕捉的，其他的信号都可以被捕捉，致使信号失效</li><li>任何一个信号都可以杀死进程</li></ul></li><li><p><strong>查看进程树</strong></p><ul><li><code>pstree [选项]</code></li><li><code>-p</code>显示进程PID</li><li><code>-u</code>显示进程所属用户</li></ul></li><li><p><strong>服务管理</strong></p><ul><li>服务的本质就是进程，但是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysql，ssh，防火墙等），因此我们又称为守护进程。</li><li><code>service 服务名 [ start | stop | restart | reload | status ]</code></li><li>查看所有服务：<code>ls /etc/init.d</code></li><li><code>chkconfig</code>可以给每个服务的各个运行级别设置自启动/关闭<ul><li><code>chkconfig --list|grep xxx</code>查看服务</li><li><code>chkconfig 服务名 --list</code></li><li><code>chkconfig --level 5 服务名 on/off</code></li><li>deepin中使用<code>update-rc.d</code>或安装<code>sysv-rc-conf</code></li></ul></li></ul></li><li><p><strong>动态监控进程</strong></p><ul><li><code>top</code>和<code>ps</code>命令很相似，他们都用来显示正在执行的进程，但<code>top</code>在执行一段时间可以更新正在运行的进程。</li><li><code>top [选项]</code></li><li><code>-d 秒数</code>指定top命令每隔几秒更新，默认是三秒</li><li><code>-i</code>使top不显示任何闲置或者僵死进程</li><li><code>-p</code>通过指定监控进程io来仅仅监控某个进程的状态</li><li>交互操作：<ul><li>P：以cpu使用率排序，默认项</li><li>M：以内存使用率排序</li><li>N：以PID排序</li><li>q：退出top</li><li>u：以用户名筛选</li><li>k：kill某个PID</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20190901201150401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzE3MDQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p></li><li><p><strong>监控网络状态</strong></p><ul><li><code>netstat [选项]</code></li><li><code>-an</code>按一定顺序排列输出</li><li><code>-p</code>显示哪个进程在调用</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.任务调度</title>
      <link href="2020/01/31/linux/4.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
      <url>2020/01/31/linux/4.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p><strong>概述</strong></p><ul><li>任务调度：是指系统在某个时间执行特定的命令或程序。</li></ul></li><li><p><strong>基本语法</strong></p><ul><li><code>crontab [选项]</code></li></ul></li><li><p><strong>常用选项</strong></p><ul><li><code>-e</code> 编辑crontab定时任务</li><li><code>-l</code> 查询crontab任务</li><li><code>-r</code> 删除当前用户所有crontab任务</li><li><code>sudo service cron restart</code> 重启任务调度</li><li><code>sudo service cron start</code> 开启任务调度</li><li><code>sudo service cron stop</code> 结束任务调度</li></ul></li><li><p><strong>快速入门</strong></p><ul><li><code>*/1 * * * * ls -l /etc &gt;&gt; /tmp/to.txt</code> 把/etc的文件列表追加到to.txt文件，每分钟执行一次。</li></ul></li><li><p><strong>使用说明</strong></p><ul><li><p>占位符</p><ul><li><p>*：小时中第几分钟（0-59）</p></li><li><p>*：天中第几小时（0-23）</p></li><li><p>*：月中第几天（1-31）</p></li><li><p>*：年中第几月（1-12）</p></li><li><p>*：星期中第几天（0-7,07都是周日）</p></li></ul></li><li><p>特殊符号</p><ul><li><p>“*”：任何时间</p></li><li><p>“,”：不连续时间</p></li><li><p>“-“：连续时间</p></li><li><p>“*/n”：每隔多长时间</p></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.组权限管理</title>
      <link href="2020/01/31/linux/3.%E7%BB%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>2020/01/31/linux/3.%E7%BB%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><p><strong>修改文件所有者</strong></p><p><code>chown username filename</code></p><p><code>chown newowner:newgroup filename</code> 改变用户的所有者和所有组</p><p><code>-R</code> 若是目录，递归执行</p></li><li><p><strong>修改文件所在组</strong></p><p><code>chgrp groupname filename</code></p><p><code>-R</code> 若是目录，递归执行</p></li><li><p><strong>改变用户所在组</strong></p><p><code>usermod -g groupname username</code></p></li><li><p><strong>改变登录初始目录</strong></p><p><code>usermod -d dirname username</code></p></li><li><p><strong>权限介绍</strong></p><p><code>drwxr-xr-x  2(子目录数，硬链接数) greens(用户) greens(组) 4.0K(目录都是4k) 8月  28 17:42(最后修改时间) Desktop</code></p><ul><li><p>文件类型：</p><ol><li>d目录</li><li>-文件</li><li>l软链接</li><li>c字符设备（键盘，鼠标）</li><li>b块文件（硬盘）</li></ol></li><li><p>文件rwx：</p><ol><li>[r]代表可读，可以读取查看。</li><li>[w]代表可写，可以修改但是不可以删除该文件，删除一个文件的前提是对该文件所在目录具有写权限才可以删除该文件。</li><li>[x]代表可执行，可以被执行。</li></ol></li><li><p>目录rwx：</p><ol><li>[r]代表可读，可以查看目录内容。</li><li>[w]代表可写，可以修改，目录内创建+删除+重命名。</li><li>[x]代表可执行，可以进入该目录。</li></ol></li><li><p>注意：如果一个文件权限为077，那么它的所有者对它是没有权限的，即便所有者在同组，如果文件权限是007，所有者也是没有权限操作的，同组成员也没有权限操作</p></li></ul></li><li><p><strong>修改权限</strong></p><p><code>chmod u=rwx,g=rx,o=rx file</code> == <code>chmod 755 file</code></p><p><code>chmod a-r file</code> == <code>chmod 311 file</code></p><p><code>-R</code> 若是目录，递归执行</p></li><li><p>目录和文件的rwx权限</p></li></ol><table><thead><tr><th align="center"></th><th align="center">r</th><th align="center">w</th><th align="center">x</th></tr></thead><tbody><tr><td align="center">文件</td><td align="center">可以查看文件内容(cat,more,head..)</td><td align="center">可以改变文件内容(vim,&gt;,&gt;&gt;)</td><td align="center">可以被执行(./a)</td></tr><tr><td align="center">目录</td><td align="center">可以查看目录内容(ls,tree)</td><td align="center">可以改变目录内容(touch,mkdir,rm,mv..)</td><td align="center">可以进入目录(cd)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.目录</title>
      <link href="2020/01/31/linux/2.%E7%9B%AE%E5%BD%95/"/>
      <url>2020/01/31/linux/2.%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><code>bin</code> 存常用命令，跟windows一样</li><li><code>sbin</code> 存管理员的命令</li><li><code>home</code> 存普通用户</li><li><code>root</code> root用户家目录</li><li><code>boot</code> 存启动时的核心文件</li><li><code>proc</code> 存系统信息，内存中的数据</li><li><code>srv</code> 存服务启动后需要的数据，如www服务需要访问的网页数据存放在/srv/www内</li><li><code>sys</code> 2.6内核的文件系统</li><li><code>tmp</code> 存临时文件</li><li><code>dev</code> 把硬件用文件形式存储</li><li><code>media</code> 挂载U盘光驱等</li><li><code>mnt</code> 临时挂在外部文件系统</li><li><code>opt</code> 存安装包的</li><li><code>usr/local</code> 存软件升级包</li><li><code>var</code> 存经常修改的目录，包括日志文件，数据库文件</li><li><code>selinux</code> 安全子系统</li><li><code>usr</code> unix software resources存放用户程序相关资源目录</li><li><code>dev</code> 存放硬件设备所对应的文件</li><li><code>etc</code> 存放系统配置文件</li><li><code>lib</code> 系统库 用户库</li><li><code>/usr/include</code> 头文件</li><li><code>/usr/lib</code> 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.命令</title>
      <link href="2020/01/31/linux/1.%E5%91%BD%E4%BB%A4/"/>
      <url>2020/01/31/linux/1.%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><strong>开机，重启，登录，注销</strong></li></ol><ul><li><code>shutdown</code><ul><li><code>shutdown -h now</code> 立即关机</li><li><code>shutdown -h l</code> 一分钟后关机</li><li><code>shutdown -r now</code> 立即重启</li></ul></li><li><code>halt</code> 立即关机</li><li><code>reboot</code> 立即重启</li><li><code>sync</code> 把内存的数据同步到磁盘</li><li><code>logout</code> 注销用户，init 3有效</li></ul><ol start="2"><li><strong>用户管理</strong></li></ol><ul><li><code>useradd name </code> 添加用户，-d指定家目录，-g指定用户组</li><li><code>passwd name</code> 修改密码</li><li><code>userdel name</code> 删除用户，-r删除家目录</li><li><code>id name</code> 查询用户</li><li><code>su - name</code> 切换用户，root先设密码</li><li><code>exit</code> 退回上个用户</li><li><code>groupadd name</code> 添加组</li><li><code>groupdel name</code> 删除组</li><li><code>/etc/passwd</code> 用户的配置文件</li><li><code>/etc/shadow</code> 口令的配置文件</li><li><code>etc/group</code> 组的配置文件</li></ul><ol start="3"><li><strong>运行级别</strong></li></ol><ul><li><p>运行级别说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0关机</span><br><span class="line">1单用户【找回丢失密码】</span><br><span class="line">2多用户无网络</span><br><span class="line">3多用户有网络</span><br><span class="line">4保留级别</span><br><span class="line">5图形界面</span><br><span class="line">6重启</span><br></pre></td></tr></table></figure></li><li><p><code>init num</code> 切换运行级别</p></li><li><p>在开机按e可以设置启动时的级别，用单用户模式可以修改root密码，必须在真机上</p></li></ul><ol start="4"><li><strong>帮助指令</strong></li></ol><ul><li><code>command --help</code> 指定命令查询帮助信息</li><li><code>man command</code> 获取命令帮助文档<ul><li>卷1：命令的帮助信息</li><li>卷2：系统调用（操作系统提供给上层应用的函数接口）的帮助信息</li><li>卷3：库函数</li><li>卷5：文件格式：如：/etc/passwd <code>man 5 passwd</code></li></ul></li><li><code>help command</code> 获取命令帮助文档</li></ul><ol start="5"><li><strong>文件目录类</strong></li></ol><ul><li><p><code>pwd</code> 显示当前目录绝对路径</p></li><li><p><code>ls</code> 查看当前目录有所内容</p><ul><li><code>-a</code> 显示所有文件和目录，包括隐藏的</li><li><code>-d</code> 查看目录本身属性</li><li><code>-F</code> 查看文件提示符 /目录 |管道 *可执行文件 =套接字</li><li><code>-h</code> 人类可读</li><li><code>-i</code> 查看文件inode 或使用stat，如：<code>stat filename</code></li><li><code>-l</code> 以列表方式显示</li><li>文件属性 硬链接计数 文件所有者 文件所有组 文件大小(默认单位字节，对于目录文件是实际占用磁盘存储的大小，4k的整数倍) 时间 文件名</li></ul></li><li><p><code>cd</code> 切换目录,无参数切换到家目录</p></li><li><p><code>cd -</code> 切换到上一次的目录</p></li><li><p><code>mkdir</code> 创建目录</p><ul><li><code>-p</code> 创建多级目录</li></ul></li><li><p><code>rmdir</code> 删除空目录</p></li><li><p><code>touch</code> 创建空文件</p></li><li><p><code>cp</code> 拷贝文件到指定目录</p><ul><li><code>-r</code> 递归复制整个文件夹</li><li><code>-a</code> 递归并且保留文件原有属性，比如不会修改文件创建时间</li><li><code>\cp</code> 强制覆盖不提示</li></ul></li><li><p><code>rm</code> 删除文件或目录</p><ul><li><code>-r</code> 递归删除整个文件夹</li><li><code>-f</code> 强制删除不提示</li><li><code>-i</code> 提示是否删除</li></ul></li><li><p><code>mv</code> 移动文件与目录或重命名</p></li><li><p><code>cat</code> 查看文件内容</p><ul><li><code>-n</code> 显示行号</li><li><code>tac</code> 倒序显示文件内容</li></ul></li><li><p><code>more</code> 全屏显示文件内容</p><ul><li>space向下翻一页</li><li>enter向下翻一行</li><li>q离开</li><li>(ctrl+)f向下滚动一屏</li><li>(ctrl+)b返回上一屏</li><li>=输出当前行号</li><li>:f输出文件名和当前行行号</li></ul></li><li><p><code>less</code> 分屏查看文件内容，动态加载，对于显示大型文件效率较高</p><ul><li>space向下翻一页</li><li>pagedown向下翻一页</li><li>pageup向上翻一页</li><li>/string向下寻找字串，n向下，N向上</li><li>?string向上寻找字串，n向上，N向下</li><li>q离开</li></ul></li><li><p><code>&gt;</code> 输出重定向 <code>&gt;&gt;</code> 追加</p><ul><li>ls -l &gt; 123.txt</li><li>cat 123.txt &gt; 456.txt</li><li>echo 666 &gt; 789.txt</li><li>cal &gt; rili.txt</li></ul></li><li><p><code>echo</code> 输出内容到控制台</p><ul><li>echo $PATH 输出环境变量</li></ul></li><li><p><code>head</code> 查看文件开头，默认10行</p><ul><li><code>-n</code> 指定查看几行</li></ul></li><li><p><code>tail</code> 查看文件末尾，默认10行</p><ul><li><code>-n</code> 指定查看几行</li><li><code>-f</code> 实时追踪文档更新</li></ul></li><li><p><code>ln</code> 软链接</p><ul><li><code>ln -s [原文件或目录] [软链接名]</code></li></ul></li><li><p><code>history</code> 查看历史指令，后面可以跟数字，表示显示后几个</p><ul><li><code>!num</code> 执行编号为num的指令</li></ul></li></ul><ol start="6"><li><strong>时间日期类</strong></li></ol><ul><li><code>date</code> 显示当前时间<ul><li><code>date +%Y</code> 显示当前年</li><li><code>date +%m</code> 显示当前月</li><li><code>date +%d</code> 显示当前日</li><li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 显示年月日时分秒</li></ul></li><li><code>date -s &quot;2019-8-28 12:02:00&quot;</code> 设置系统时间</li><li><code>cal</code> 显示本月月历<ul><li><code>cal 2019</code> 显示2019年历</li></ul></li></ul><ol start="7"><li><strong>搜索查找类</strong></li></ol><ul><li><p><code>find [搜索范围] [选项]</code> 从指定目录递归遍历，将满足条件的显示在终端</p><ul><li><code>-name</code> 按文件名查找</li><li><code>-user</code> 按所属用户名查找</li><li><code>-size</code> 按文件大小查找<ul><li><code>-size +20M</code> 查找大于20M</li><li><code>-size -20M</code> 查找小于20M</li><li><code>-size 20M</code> 查找等于20M</li><li><code>-size +1k -size -5k</code> 查找1k-5k之间</li><li>不加单位，默认单位是扇区，一个扇区512B</li><li>k小写，M大写</li></ul></li><li><code>-type</code> 按文件类型查找<ul><li>f文件(不是-) d目录 l软链接 b块文件 c字符文件 p管道 s套接字</li></ul></li><li><code>-maxdepth</code> 指定搜索层级深度<ul><li><code>find / -maxdepth 1 -type f</code></li></ul></li><li><code>-exec</code> 对搜索结果执行命令<ul><li><code>find / -type f -exec ls -l &#123;&#125; \;</code> 这里末尾是个转义分号</li></ul></li><li><code>xargs</code> 借助|对搜索结果执行命令<ul><li><code>find / -type f | xargs ls -l</code><ul><li>问题：当有一个名字含空格的文件时，会报错</li></ul></li><li><code>find / -type f -print0 | xargs -0 ls -l</code><ul><li>find默认会有-print参数，以空格分隔结果</li><li>这里改成用’\0’分隔结果，也就是数字0</li></ul></li></ul></li><li><code>-mtime</code> 按文件更改时间来查找文件<ul><li>-n指n天以内，+n指n天以前，下面两个一样</li></ul></li><li><code>-atime</code> 按文件访问时间来查找文件</li><li><code>-ctime</code> 按文件创建时间来查找文件</li><li><code>-amin</code> 查找在系统中最后N分钟访问的文件</li><li><code>-mmin</code> 查找在系统中最后N分钟里修改过的文件</li><li><code>-cmin</code> 查找在系统中最后N分钟创建的文件</li></ul></li><li><pre><code>updatedb    //创建locate数据库locate hello.c    //快速定位#deepin好像不行  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;grep&#96; 过滤查找 &#96;|&#96; 将前一个命令处理结果传递给后面的命令处理</span><br><span class="line"></span><br><span class="line">  - &#96;-n&#96; 显示匹配行及行号</span><br><span class="line">  - &#96;-i&#96; 忽略字母大小写</span><br><span class="line">  - 实例：&#96;cat hello.c | grep -ni yes&#96;</span><br><span class="line"></span><br><span class="line">  - 查找内容包含某个关键字的文件</span><br><span class="line">    - &#96;grep -r&#x2F;-R &quot;关键字&quot; 目录位置&#96;</span><br><span class="line">  - 也可以和find一起使用</span><br><span class="line">    - &#96;find &#x2F; -name &quot;*.c&quot; | xargs grep &quot;return&quot; -n&#96;</span><br><span class="line"></span><br><span class="line">- &#96;which&#96; 查找某个指令的位置</span><br><span class="line"></span><br><span class="line">8. **解压和压缩类**</span><br><span class="line"></span><br><span class="line">- &#96;gzip&#x2F;gunzip&#96;</span><br><span class="line"></span><br><span class="line">  - &#96;gzip hello.c&#96; 压缩文件为hello.c.gz文件，hello.c不保留</span><br><span class="line">  - &#96;gunzip hello.c.gz&#96; 解压缩文件，hello.c.gz不保留</span><br><span class="line"></span><br><span class="line">- &#96;zip&#x2F;unzip&#96;</span><br><span class="line"></span><br><span class="line">  - &#96;zip [选项] xxx.zip 将要压缩的内容&#96; 压缩文件和目录</span><br><span class="line">    - &#96;-r&#96; 递归压缩，即压缩目录</span><br><span class="line">  - &#96;unzip [选项] xxx.zip&#96; 解压缩文件</span><br><span class="line">    - &#96;-d&#96; 指定解压后文件存放的目录</span><br><span class="line"></span><br><span class="line">- &#96;tar&#96; 打包指令，最后打包成*.tar.gz文件</span><br><span class="line"></span><br><span class="line">  - &#96;tar [选项] xxx.tar.gz 打包的内容&#96;</span><br><span class="line"></span><br><span class="line">    - &#96;-c&#96; 产生.tar打包文件</span><br><span class="line">    - &#96;-v&#96; 显示详细信息</span><br><span class="line">    - &#96;-f&#96; 指定压缩后的文件名</span><br><span class="line">    - &#96;-z&#96; 打包同时压缩，使用gzip压缩</span><br><span class="line">    - &#96;-j&#96; 打包同时压缩，使用bzip2压缩</span><br><span class="line">    - &#96;-x&#96; 解包.tar文件</span><br><span class="line"></span><br><span class="line">  - 实例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>    tar -zcvf abc.tar.gz a.txt b.txt c.txt    //打包文件    tar -zcvf myhome.tar.gz /home/            //打包目录    tar -zxvf abc.tar.gz                    //解压到当前目录    tar -zxvf myhome.tar.gz -C /opt/        //解压到/opt目录,这个目录得存在    ```- gzip和bzip2是linux特有的压缩方式，4G以下的小文件不明显，但是大文件越大，bzip2压缩比越大，bzip2的后缀通常写为.tar.bz2</code></pre></li></ul><ol start="9"><li><strong>shell命令使用技巧</strong></li></ol><ul><li>ctrl+a:光标移动到最前端</li><li>ctrl+e:光标移动到最后端</li><li>ctrl+u:清空已输入命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>malloc与new</title>
      <link href="2020/01/31/C++/malloc%E4%B8%8Enew/"/>
      <url>2020/01/31/C++/malloc%E4%B8%8Enew/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>malloc 不会调用构造函数，而 new 会</p><p>free 不会调用析构函数，而 delete 会</p><p>不要用void*接收new出来的对象，delete时会失败</p><p>new数组的时候，delete[]释放</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚函数表与vptr指针</title>
      <link href="2020/01/31/C++/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8Evptr%E6%8C%87%E9%92%88/"/>
      <url>2020/01/31/C++/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8Evptr%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li>当类中声明虚函数时，编译器会在类中生成一个虚函数表</li><li>虚函数表是一个存储类成员函数指针的数据结构</li><li>虚函数表是由编译器自动生成与维护的</li><li>virtual成员函数会被编译器放入虚函数表中</li><li>存在虚函数时，每个对象都有一个指向虚函数表的指针（vptr指针） </li></ol><p>说明：</p><ol><li>通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要寻址操作才能<br>确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。</li><li>处于效率考虑，没有必要将所有成员函数都声明为虚函数</li><li>C++编译器，执行run函数，不需要区分是子类对象还是父类对象，而是直接通过p的VPTR指针<br>所指向的对象函数执行即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void run(Parent *p) &#123;</span><br><span class="line">    p -&gt; func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重载重写重定义</title>
      <link href="2020/01/31/C++/%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%87%8D%E5%AE%9A%E4%B9%89/"/>
      <url>2020/01/31/C++/%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%87%8D%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>重载</strong>（添加）：</p><ol><li>相同的作用域</li><li>函数名字相同</li><li>参数个数/参数顺序/参数类型不同</li><li>和函数返回值没有关系</li><li>参数的const属性也可作为重载条件</li><li>virtual关键字可有可无</li></ol><p><strong>重写</strong>（覆盖）：</p><ol><li>不同的范围，分别位于基类和派生类中</li><li>函数的名字相同</li><li>函数返回值，函数名字，函数参数必须和基类虚函数一致</li><li>基类函数必须有virtual关键字</li></ol><p><strong>重定义</strong>（隐藏）：</p><ol><li>如果派生类的函数和基类的函数同名，但是参数不同，此时不论有无virtual，基类的函数被隐藏</li><li>如果派生类的函数和基类的函数同名，并且参数也相同，但是基类的函数没有virtual，此时基类的函数被隐藏 </li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态联编与动态联编</title>
      <link href="2020/01/31/C++/%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E4%B8%8E%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96/"/>
      <url>2020/01/31/C++/%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E4%B8%8E%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>1.联编是指一个程序模块，代码之间互相关联的过程。</p><p>2.静态联编是程序的匹配，连接在编译阶段实现，也称为早期匹配。重载函数使用静态联编。 </p><p>3.动态联编是指程序联编推迟到运行时进行，所以又称为晚期联编（迟绑定）。<br>switch和if是动态联编的例子。 </p><p>C++与C相同，是静态编译型语言</p><p>在编译时，编译器自动根据指针的类型判断指向的是一个什么样的对象，所以编译器认为父类指针指向的是父类对象<br>由于程序没有运行，所以不知道父类指针指向的具体是父类对象还是子类对象，处于程序安全的角度，<br>编译器假设父类指针只指向父类对象，因此编译的结果为调用父类的成员函数。这种特性就是静态联编。<br>多态的发生是动态联编，是在程序执行的时候判断具体父类指针应该调用的方法。 </p><h3 id="静态多态-静态联编-：地址早绑定"><a href="#静态多态-静态联编-：地址早绑定" class="headerlink" title="静态多态(静态联编)：地址早绑定"></a>静态多态(静态联编)：地址早绑定</h3><ul><li>运算符重载</li><li>函数重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物叫\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;喵喵喵\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animalSpeak</span><span class="params">(Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">  animal.speak(); <span class="comment">//地址早绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat cat;</span><br><span class="line">animalSpeak(cat); <span class="comment">//动物叫</span></span><br></pre></td></tr></table></figure><h3 id="动态多态-动态联编-：地址晚绑定"><a href="#动态多态-动态联编-：地址晚绑定" class="headerlink" title="动态多态(动态联编)：地址晚绑定"></a>动态多态(动态联编)：地址晚绑定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物叫\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">//这里加不加virtual都行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;喵喵喵\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animalSpeak</span><span class="params">(Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">  animal.speak(); <span class="comment">//地址晚绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat cat;</span><br><span class="line">animalSpeak(cat); <span class="comment">//喵喵喵</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.类型转换</title>
      <link href="2020/01/31/C++/17.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2020/01/31/C++/17.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="类型转换的问题"><a href="#类型转换的问题" class="headerlink" title="类型转换的问题"></a>类型转换的问题</h3><ul><li>子类是大于等于父类的</li><li>父转子(向下类型转换)会有风险，子类指针的寻址范围大于等于父类的有效寻址范围，有可能造成越界<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat* cat = (Cat*)animal;</span><br></pre></td></tr></table></figure></li><li>子转父(向上类型转换)属于安全转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat* cat = <span class="keyword">new</span> Cat();</span><br><span class="line">Animal* animal = (Animal*)cat;</span><br></pre></td></tr></table></figure></li><li>如果发生了多态，那么转换总是安全的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> Cat();<span class="comment">//开辟的时候是按大范围开辟的，所以不会有问题</span></span><br><span class="line">Cat* cat = (Cat*)animal;</span><br></pre></td></tr></table></figure></li></ul><h3 id="C-风格类型转换"><a href="#C-风格类型转换" class="headerlink" title="C++风格类型转换"></a>C++风格类型转换</h3><ol><li>静态类型转换<ul><li>允许内置数据类型转换</li><li>允许父子之间的指针或引用转换(两个非父子类不行)，但向下转换依旧是不安全的</li></ul></li><li>动态类型转换<ul><li>是一种严格的转换，不允许有风险</li><li>所以不能做内置类型转换(比如double转int会损失精度)</li><li>可以子转父</li><li>父转子需要发生多态才可以</li></ul></li><li>常量转换<ul><li>可以卸掉或加上const修饰</li><li>只能用作指针或引用的转换</li><li>const int a = 1;是在符号表上，int a = 1;是在栈上，所以不行</li></ul></li><li>重解释转换<ul><li>最不安全的一种</li><li>什么都能转，建议不要用</li></ul></li></ol><p><strong>静态转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C++风格类型转换</span></span><br><span class="line"><span class="comment">static_cast 静态类型转换</span></span><br><span class="line"><span class="comment">reinterpreter_cast 重新解释类型转换</span></span><br><span class="line"><span class="comment">dynamic_cast 子类和父类之间的多态类型转换</span></span><br><span class="line"><span class="comment">const_cast 去掉const属性转换 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态的类型转换：</span></span><br><span class="line"><span class="comment">//在编译的时候进行基本类型的转换</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pi);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父子转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dog~&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dohome</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;kanjia&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cat~&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dohome</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;zhualaoshu&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Animal *base = <span class="literal">NULL</span>;</span><br><span class="line">base = <span class="keyword">new</span> Cat();</span><br><span class="line">base -&gt; cry();</span><br><span class="line"></span><br><span class="line">Dog * pdog = <span class="keyword">dynamic_cast</span>&lt;Dog*&gt;(base);</span><br><span class="line"><span class="keyword">if</span>(pdog != <span class="literal">NULL</span>) &#123;</span><br><span class="line">pdog -&gt; cry();</span><br><span class="line">pdog -&gt; dohome();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat *pcat = <span class="keyword">dynamic_cast</span>&lt;Cat*&gt;(base);</span><br><span class="line"><span class="keyword">if</span>(pcat != <span class="literal">NULL</span>) &#123;</span><br><span class="line">pcat -&gt; cry();</span><br><span class="line">pcat -&gt; dohome(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> A a = &#123;<span class="number">200</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A a1 = const_cast&lt;A&gt;(a);</span></span><br><span class="line"><span class="comment">//a1.data = 300;</span></span><br><span class="line"></span><br><span class="line">A &amp;a2 = <span class="keyword">const_cast</span>&lt;A&amp;&gt;(a);</span><br><span class="line">a2.data = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.data &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a2.data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">A *a3 = <span class="keyword">const_cast</span>&lt;A*&gt;(&amp;a);</span><br><span class="line">a3 -&gt; data = <span class="number">400</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.data &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a3 -&gt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;x1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(x);</span><br><span class="line">x1 = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *x2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;x);</span><br><span class="line">*x2 = <span class="number">400</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *x2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重解释转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为</span></span><br><span class="line"><span class="comment">数据的二进制形式重新解释，但是不改变其值 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dog~&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dohome</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;kanjia&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cat~&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dohome</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;zhualaoshu&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printP</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;book&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Animal *base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//1.可以把子类指针赋给父类指针，但是反过来是不可以的，需要如下转换</span></span><br><span class="line"><span class="comment">//Dog *pdog = base;</span></span><br><span class="line">Dog *pdog = <span class="keyword">static_cast</span>&lt;Dog*&gt;(base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.把base转换成其他非动物相关的err</span></span><br><span class="line"><span class="comment">//Book *book = static_cast&lt;Book*&gt;(base);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.reinterpret_cast可以强制类型转换</span></span><br><span class="line">Book *book = <span class="keyword">reinterpret_cast</span>&lt;Book*&gt;(base); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.模板与泛型</title>
      <link href="2020/01/31/C++/16.%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B/"/>
      <url>2020/01/31/C++/16.%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>函数模板</strong></p><ul><li>使用模板的两种方式<ul><li>自动类型推导：必须能推出一致的类型</li><li>显示指定类型</li></ul></li><li>模板必须确定出T的类型才可以使用</li><li>普通函数和函数模板区别<ul><li>普通函数可以发生隐式类型转换</li><li>函数模板<ul><li>自动类型推导不会发生隐式类型转换</li><li>显示指定类型可以发生隐式类型转换</li></ul></li></ul></li><li>调用规则<ul><li>如果普通函数和函数模板都可以匹配，优先使用普通函数</li><li>如果想强制调用函数模板，需要加空模板参数列表 fun&lt;&gt;(a);</li><li>函数模板也可以发生函数重载</li><li>如果函数模板可以产生更好的匹配，那么优先使用函数模板</li></ul></li><li>函数模板机制<ul><li>函数模板并不是万能，对于自定义类型数据，有些情况不能够正常使用</li><li>通过函数模板产生的函数，我们称为模板函数</li><li>两次编译：对函数模板进行第一次编译，检查语法错误，对调用时替换T之后生成的模板函数，做第二次编译<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数模板的实例：</span></span><br><span class="line"><span class="comment">调用过程：先将函数模板实例化为函数，然后再发生函数调用 </span></span><br><span class="line"><span class="comment">函数模板只适用于参数个数相同而类型不同且函数体相同的情况，如果个数不同则不能用函数模板 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">T t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">myswap(x,y);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">myswap&lt;<span class="keyword">int</span>&gt;(x,y);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">myswap(a,b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">myswap&lt;<span class="keyword">char</span>&gt;(a,b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>函数模板与函数重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">T t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;模板函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">char</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;普通函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">myswap(c,i);</span><br><span class="line"><span class="comment">//myswap(i,c);</span></span><br><span class="line"><span class="comment">//myswap&lt;int&gt;(c,i);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int Max(int a, int b)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T Max(T a, T b)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T Max(T a, T b, T c)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> Max(Max(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Max(a,b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Max&lt;&gt;(a,b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Max(<span class="number">3.0</span>,<span class="number">4.0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Max(<span class="number">5.0</span>,<span class="number">6.0</span>,<span class="number">7.0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Max(<span class="string">&#x27;a&#x27;</span>,<span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//模板不允许隐式类型转换 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板</strong></p><ul><li>类模板使用时，不可以用自动类型推导，只能显示指定类型</li><li>模板中也可以使用默认参数，这样调用时就不用显示指定了<ul><li>template&lt;class A, class B = int&gt;</li><li>T<string> t(“Tom”,18);    //使用</li></ul></li><li>类模板中成员函数并不是一开始创建，而是在替换T后才会生成</li><li>类模板做函数参数的三种方式<ul><li>传入指定类型 fun(A<int>&amp; a);</li><li>将参数模板化 template<class T> fun(A<T>&amp; a);</li><li>将类模板化 template<class T> fun(T&amp; a);</li></ul></li><li>子类在继承时，必须确定出父类的T的数据类型，否则无法给T分配内存空间</li><li>类模板的成员函数的分文件编写(头文件写类的定义，源文件写函数实现)<ul><li>类模板成员函数并不是一开始创建，导致直接包含头文件，链接不到</li><li>解决方法<ul><li>直接包含源文件(不推荐)</li><li>将类模板中的声明和实现都写到一个文件中<br>，后缀名改为.hpp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类模板与函数模板的定义和使用类似，我们已经进行了介绍，有时有两个或多个类，</span></span><br><span class="line"><span class="comment">其功能是相同的，仅仅是数据类型不同，所以将类中的类型进行泛化 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//template &lt;class T&gt;也可以</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(T t) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; t = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T &amp;<span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T t;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个对象时，要明确此类所泛化的具体类型</span></span><br><span class="line"><span class="function">A&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.getT() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>模板类派生</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(T a) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; a = a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板类派生普通类</span></span><br><span class="line"><span class="comment">//结论：子类从模板类继承的时候，需要让编译器知道，父类的数据类型具体是什么</span></span><br><span class="line"><span class="comment">//数据类型的本质：固定大小内存块的别名 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : A&lt;<span class="keyword">int</span>&gt;(a) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板类派生模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C(T a, T c) : A&lt;T&gt;(a) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; c = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T c;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>友元函数写在类中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream &amp;os, Complex &amp;c) &#123;</span><br><span class="line">os &lt;&lt; c.a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Complex(T a, T b) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; a = a;</span><br><span class="line"><span class="keyword">this</span> -&gt; b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printComplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+ (Complex &amp;another) &#123;</span><br><span class="line"><span class="function">Complex <span class="title">temp</span><span class="params">(a + another.a, b + another.b)</span></span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a, b;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;<span class="comment">//让模板类具体化是为了告诉编译具体的大小，分配内存</span></span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">a.printComplex();</span><br><span class="line">Complex&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">c = a + b;</span><br><span class="line">c.printComplex();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数写在类外</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先让编译器看到Person类声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先让编译器看到函数模板 printPerson的存在</span></span><br><span class="line">template&lt;class T1, class T2&gt; void printPerson(Person&lt;T1, T2&gt;&amp; p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);<span class="comment">//不写&lt;&gt;就是个普通函数，写才是函数模板声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;p(<span class="string">&quot;Tom&quot;</span>, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">printPerson(p);</span><br><span class="line">printPerson2(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数体写在类外</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> A&lt;T&gt;::fun() &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板类静态变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> T s_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量需要在类的外部初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T A&lt;T&gt;::s_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; a1,a2,a3;</span><br><span class="line">A&lt;<span class="keyword">char</span>&gt; b1,b2,b3;</span><br><span class="line"></span><br><span class="line">a1.s_value = <span class="number">10</span>;</span><br><span class="line">b1.s_value = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a1.s_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b1.s_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">a1.s_value++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a2.s_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a3.s_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">b1.s_value++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b2.s_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b3.s_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.抽象类</title>
      <link href="2020/01/31/C++/15.%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>2020/01/31/C++/15.%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><ul><li>纯虚函数和抽象类：<ol><li>纯虚函数是在一个基类中说明的虚函数，在基类中没有定义，要求任何派生类都定义自己的版本</li><li>纯虚函数为各派生类提供一个公共界面（接口的封装和设计，软件的模块功能划分） </li><li>一个具有纯虚函数的基类称为抽象类 </li></ol></li></ul><ol><li>含有纯虚函数的类，称为抽象基类，不可实例化。存在的意义就是被继承，提供族类的公共接口</li><li>纯虚函数只有声明，没有实现，被“初始化”为 0</li><li>如果一个类中声明了纯虚函数，而在派生类中没有对该函数定义，则该虚函数在派生类中仍为纯虚函数，派生类仍为纯虚基类 </li><li>纯虚函数还有一层意义就是强制派生类重写虚函数，不然连对象都创建不了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//面向抽象类编程（面向一套预先定义好的接口编程）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> &#123;</span><span class="comment">//抽象类 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//阅读一个统一的接口，让子类使用，让子类必须去实现 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Figure &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Circle(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; a = a;</span><br><span class="line"><span class="keyword">this</span> -&gt; b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">3.14</span> * a * a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tri</span> :</span> <span class="keyword">public</span> Figure &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Tri(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; a = a;</span><br><span class="line"><span class="keyword">this</span> -&gt; b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a * b / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">area_func</span><span class="params">(Figure *base)</span> </span>&#123;</span><br><span class="line">base -&gt; getArea();<span class="comment">//会发生多态 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Figure F; 抽象类不能被实例化</span></span><br><span class="line">Figure *base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Tri <span class="title">t</span><span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">area_func(&amp;c);</span><br><span class="line">area_func(&amp;t); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><h3 id="抽象类和多继承"><a href="#抽象类和多继承" class="headerlink" title="抽象类和多继承"></a>抽象类和多继承</h3><ul><li>抽象类在多继承中的应用<ol><li>绝大多数面向对象语言都不支持多继承，绝大多数面向对象语言都支持接口的概念</li><li>C++没有接口的概念，C++可以使用纯虚函数实现接口</li><li>接口类中只有函数原型定义，没有任何数据的定义 </li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> Interface1, <span class="keyword">public</span> Interface2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child::print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Child c;</span><br><span class="line">c.print();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c.add(<span class="number">3</span>,<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c.sub(<span class="number">4</span>,<span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Interface1 *i1 = &amp;c;</span><br><span class="line">Interface2 *i2 = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i1 -&gt; add(<span class="number">7</span>,<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i2 -&gt; add(<span class="number">7</span>,<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构引入"><a href="#虚析构引入" class="headerlink" title="虚析构引入"></a>虚析构引入</h3><ul><li>delete父类指针，只会调用父类析构函数</li><li>子类若有动态分配内存，则会造成内存泄漏<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">~Animal() &#123;<span class="comment">//这里声明为virtual就可以解决这个问题了</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Animal()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;喵喵喵\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Cat()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal* cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="keyword">delete</span> cat;<span class="comment">// 打印结果：~Animal()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul><li>构造函数不能是虚函数，建立一个派生类对象时，必须从类层次的根开始，</li><li>沿着继承路径逐个调用基类的构造函数。</li><li>析构函数可以是虚的，虚析构函数用于指引delete运算符正确析构动态对象 </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;obja&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~A() &#123;<span class="comment">//有virtual析构是~C ~B ~A，没有virtual析构是~A</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;~A()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B() &#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;objb&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;~B()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C() &#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;objc&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;C()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">~C() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;~C()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针，把所有子类对象的析构函数都执行一遍</span></span><br><span class="line"><span class="comment">//通过父类指针，释放所有的子类资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">howtodelete</span><span class="params">(A *base)</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span> base;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">C *myC = <span class="keyword">new</span> C;</span><br><span class="line"><span class="comment">//delete myC; 直接通过子类对象释放资源，不需要写virtual</span></span><br><span class="line">howtodelete(myC); <span class="comment">//通过父类指针调用释放子类的资源 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h3><ul><li>纯虚析构函数除了要有定义，还必须要在类外实现</li><li>和虚析构函数的区别是，类中有了纯虚析构函数也算是抽象类</li><li>其他方面就没有什么区别了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~Animal() = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal::~Animal() &#123;<span class="comment">//不实现会报错的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Animal()\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.多态</title>
      <link href="2020/01/31/C++/14.%E5%A4%9A%E6%80%81/"/>
      <url>2020/01/31/C++/14.%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>前置知识：<a href="/post/%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E4%B8%8E%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96">动态联编与静态联编</a></p><blockquote><p>自己发现的一点，补充一下。多态如Animal* animal = new Cat();    animal是访问不到Cat中的成员的，只是调用虚函数的时候会走Cat的</p></blockquote><h3 id="赋值兼容（多态实现的前提）"><a href="#赋值兼容（多态实现的前提）" class="headerlink" title="赋值兼容（多态实现的前提）"></a>赋值兼容（多态实现的前提）</h3><ul><li>赋值兼容原则是指在需要基类对象的任何地方都可以使用公有派生类的对象来替代。</li><li>赋值兼容是一种默认行为，不需要任何的显示的转化步骤。</li><li>赋值兼容规则中所指代的替代包括以下的情况：<ol><li>派生类的对象可以赋值给基类对象</li><li>派生类的对象可以初始化基类的引用</li><li>派生类对象的地址可以赋给指向基类的指针</li></ol></li><li>在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。 </li></ul><h3 id="多态：同样的调用语句有多种不同的表现形态"><a href="#多态：同样的调用语句有多种不同的表现形态" class="headerlink" title="多态：同样的调用语句有多种不同的表现形态"></a>多态：同样的调用语句有多种不同的表现形态</h3><ul><li>本节所指皆为动态多态</li><li>C++中通过virtual关键字对多态进行支持</li><li>使用virtual声明的函数被重写后即可展现多态特性 </li></ul><h3 id="多态工程的意义："><a href="#多态工程的意义：" class="headerlink" title="多态工程的意义："></a>多态工程的意义：</h3><ol><li>封装：突破了C语言函数的概念</li><li>继承：代码复用，复用原来写好的代码</li></ol><h3 id="多态成立的条件："><a href="#多态成立的条件：" class="headerlink" title="多态成立的条件："></a>多态成立的条件：</h3><ol><li>要有继承</li><li>要有虚函数重写</li><li>要有父类指针（父类引用）指向子类对象 </li></ol><h3 id="多态实现原理："><a href="#多态实现原理：" class="headerlink" title="多态实现原理："></a>多态实现原理：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物叫\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">//这里加不加virtual都行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;喵喵喵\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal* cat = <span class="keyword">new</span> Cat();<span class="comment">//引用指向cat也是可以的</span></span><br><span class="line">cat -&gt; speak();<span class="comment">//喵喵喵，多态实现 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(Animal);<span class="comment">//无virtual是1，有virtual是8(gcc), 4(vc)</span></span><br></pre></td></tr></table></figure><ul><li>当类中声明了虚函数，类内会维护一个虚函数(表)指针</li><li>虚函数指针指向虚函数表</li><li>虚函数表内部记录虚函数的函数入口地址</li><li>当子类重写父类虚函数后，那么子类继承来的虚函数表入口地址发生覆盖</li><li>通过虚函数表指针调用重写函数是在程序运行时进行的，因此需要寻址操作才能 确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。</li></ul><p><strong>cat中不重写speak()</strong></p><p><img src="/photo/%E5%A4%9A%E6%80%811.png" alt="多态1" loading="lazy"></p><p><strong>cat中重写speak()</strong></p><p><img src="/photo/%E5%A4%9A%E6%80%812.png" alt="多态2" loading="lazy"></p><p><strong>注意：如果想要寻址调用函数的话，使用的是__cdecl，但是C++默认是__stdcall，需要在函数指针强转的部分加上__stdcall，好像是因为gcc中的vbptr和vfptr与vc里的不一样，所以一样的代码在gcc里不能运行</strong></p><h3 id="多态例子"><a href="#多态例子" class="headerlink" title="多态例子"></a>多态例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroFighter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">ackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdvHeroFighter</span> :</span> <span class="keyword">public</span> HeroFighter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">ackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> HeroFighter::ackPower() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enemyFighter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destoryPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objPk</span><span class="params">(HeroFighter *hf, enemyFighter *enemyF)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(hf -&gt; ackPower() &gt; enemyF -&gt; destoryPower()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;英雄胜利&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;英雄牺牲&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HeroFighter hf;</span><br><span class="line">enemyFighter ef;</span><br><span class="line"></span><br><span class="line">objPk(&amp;hf,&amp;ef);</span><br><span class="line"></span><br><span class="line">AdvHeroFighter advhf;</span><br><span class="line">objPk(&amp;advhf,&amp;ef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用多态实现计算器"><a href="#利用多态实现计算器" class="headerlink" title="利用多态实现计算器"></a>利用多态实现计算器</h3><ul><li><p>不用多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(<span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码想要继续添加功能只能修改类的代码</p></li><li><p>开闭原则：对扩展进行开放，对修改进行关闭</p></li><li><p>多态好处：代码组织结构清晰，提高可读性，提高可扩展性</p></li><li><p>多态实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没什么用，这里可以声明为纯虚函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">addCalc</span>:</span> <span class="keyword">public</span> Calc &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用多态实现开闭原则，以后需要增加功能，只需要增加类即可</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.继承</title>
      <link href="2020/01/31/C++/13.%E7%BB%A7%E6%89%BF/"/>
      <url>2020/01/31/C++/13.%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><ul><li>不写则默认为私有继承<br><img src="/photo/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.png" alt="继承方式" loading="lazy"></li></ul><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;<span class="comment">//继承到了c，但是由于编译器保护，因此访问不到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(B);<span class="comment">// = 16</span></span><br></pre></td></tr></table></figure><h3 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h3><ul><li>当创建子类对象时，先调用父类构造函数，在调用子类中其他类对象成员构造函数，在调用子类自身构造函数，析构顺序相反</li><li>父类中有些函数子类是不会继承的，即编译器默认实现的四个函数<ol><li>构造</li><li>拷贝构造</li><li>析构</li><li>operator=</li></ol></li></ul><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><ul><li>两个父类有同名成员，子类调用必须加作用域</li></ul><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><ul><li>即菱形继承问题的解决方案，以动物-&gt;羊/驼-&gt;羊驼为例</li><li>通过virtual关键字，羊类和驼类自动物类继承来的不是age属性，而是虚基类指针，指向各自虚基类表</li><li>虚基类表上有记录偏移量，虚基类指针加上偏移量就能找到唯一的age<br><img src="/photo/%E8%99%9A%E7%BB%A7%E6%89%BF.png" alt="虚继承原理" loading="lazy"></li><li>若不使用虚继承，菱形继承的对象模型如下</li></ul><p><img src="/photo/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.png" alt="菱形继承" loading="lazy"></p><ul><li>虚继承时通过偏移量寻找到age，然而这些代码在gcc并不能运行，懒得下vc了…<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span><span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo&#123;&#125;;</span><br><span class="line"></span><br><span class="line">SheepTuo st;</span><br><span class="line">st.m_Age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Sheep找到偏移量</span></span><br><span class="line"><span class="comment">//*(int *)&amp;st 找到了vbtable@Sheep,这个表里从0到1步长也是4，所以转成int*：(int*)*(int *)&amp;st，再+1，找到偏移量的地址，在解引用就是偏移量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sheep的偏移量： &quot;</span> &lt;&lt; *((<span class="keyword">int</span>*)*(<span class="keyword">int</span> *)&amp;st + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Tuo找到偏移量</span></span><br><span class="line"><span class="comment">//*((int *)(&amp;st) + 1) 找到 vbtable</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuo的偏移量： &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)*((<span class="keyword">int</span> *)(&amp;st) + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Sheep的偏移量 获取到具体m_Age</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; *((<span class="keyword">int</span> *)((<span class="keyword">char</span> *)&amp;st + (*((<span class="keyword">int</span>*)*(<span class="keyword">int</span> *)&amp;st + <span class="number">1</span>)))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; ((Animal *)((<span class="keyword">char</span> *)&amp;st + (*((<span class="keyword">int</span>*)*(<span class="keyword">int</span> *)&amp;st + <span class="number">1</span>))))-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">全盘接收，除了构造器和析构器。基类有可能会造成派生类的成员冗余，所有基类是需要设计的。</span></span><br><span class="line"><span class="comment">派生类有了自己的个性，使派生类有了意义。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span>:</span><span class="keyword">public</span> Student &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student2(<span class="built_in">string</span> n, <span class="keyword">int</span> a, <span class="keyword">char</span> s, <span class="keyword">float</span> f) &#123;</span><br><span class="line">name = n; age = a; sex = s; score = f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student::dis();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>权限</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    publicprotectedprivate</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">公有继承publicprotected不可见</span></span><br><span class="line"><span class="comment">保护继承protectedprotected不可见</span></span><br><span class="line"><span class="comment">私有继承privateprivate不可见 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> pub;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> pro;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> pri;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dirve</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pub = <span class="number">10</span>;</span><br><span class="line">pro = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base b;</span><br><span class="line">b.pub = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型兼容</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代，通过公有继承</span></span><br><span class="line"><span class="comment">派生类得到了基类中除构造函数，析构函数之外的所有成员。这样，公有派生类实际就具备了基类的</span></span><br><span class="line"><span class="comment">所有功能，凡是基类能解决的问题，公有派生类都可以解决。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子类对象可以当作父类对象使用</span></span><br><span class="line"><span class="comment">子类对象可以直接赋值给父类对象</span></span><br><span class="line"><span class="comment">子类对象可以初始化父类对象</span></span><br><span class="line"><span class="comment">父类指针可以直接指向子类对象</span></span><br><span class="line"><span class="comment">父类引用可以直接引用子类对象 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printP</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;parent...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span><span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;child...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">(Parent *p)</span> </span>&#123;</span><br><span class="line">p -&gt; printP();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(Parent &amp;p)</span> </span>&#123;</span><br><span class="line">p.printP();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Child c1;</span><br><span class="line">c1.printC();</span><br><span class="line"></span><br><span class="line">Parent *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//可以用父类指针指向子类对象</span></span><br><span class="line">p = &amp;c1;</span><br><span class="line">p -&gt; printP(); <span class="comment">//执行父类函数</span></span><br><span class="line"></span><br><span class="line">Child c2;</span><br><span class="line">Parent p2;</span><br><span class="line">print1(&amp;p2);</span><br><span class="line">print1(&amp;c2);<span class="comment">//父类指针指向子类对象 </span></span><br><span class="line">print2(p2);</span><br><span class="line">print2(c2);<span class="comment">//父类引用指向子类对象 </span></span><br><span class="line"></span><br><span class="line">Child c3;</span><br><span class="line">Parent p3 = c3; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承构造析构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化</span></span><br><span class="line"><span class="comment">在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子类对象在创建时会首先调用父类的构造函数</span></span><br><span class="line"><span class="comment">父类构造函数执行结束后，执行子类的构造函数</span></span><br><span class="line"><span class="comment">当父类的构造函数有参数时，需要在子类的初始化列表中显示调用</span></span><br><span class="line"><span class="comment">析构函数调用的先后顺序与构造函数相反 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; s = s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent()&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Parent() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Parent()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Child(<span class="keyword">int</span> a):Parent(<span class="string">&quot;Parameter from Child!&quot;</span>) &#123;<span class="comment">//利用初始化列表的方式显示调用父类中其他构造函数，不写是调用父类默认构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child()---1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt; a = a;</span><br><span class="line">&#125;</span><br><span class="line">Child(<span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">char</span> *s) : Parent(s) &#123;<span class="comment">//这里也可以搭配默认参数使用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child()---2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt; a = a;</span><br><span class="line">&#125;</span><br><span class="line">~Child() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Child()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Child <span class="title">child</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//Child child(10,&quot;Parament form child...&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承组合并存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承和组合并存，构造和析构原则：</span></span><br><span class="line"><span class="comment">先构造父类，再构造成员变量，最后构造自己</span></span><br><span class="line"><span class="comment">先析构自己，再析构成员变量，最后析构父类 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Object(<span class="keyword">const</span> <span class="keyword">char</span>* s) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object()&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Object() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Object()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span><span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">const</span> <span class="keyword">char</span>* s) : Object(s) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent()&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Parent() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Parent()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Child():o2(<span class="string">&quot;o2&quot;</span>),o1(<span class="string">&quot;o1&quot;</span>),Parent(<span class="string">&quot;Parameter from Child!&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Child() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Child()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Object o1;</span><br><span class="line">Object o2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Child child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多继承可能导致的问题：派生类中可能包含多个基类副本</span></span><br><span class="line"><span class="comment">class A&#123;&#125;; class B:public A&#123;&#125;;</span></span><br><span class="line"><span class="comment">class C:public A,protected B&#123;&#125;;</span></span><br><span class="line"><span class="comment">C中有A和B，B中又有A，而且两个A访问控制还不一样</span></span><br><span class="line"><span class="comment">这个时候就需要虚继承了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bed</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Bed()&#123;</span><br><span class="line">&#125;;</span><br><span class="line">~Bed()&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Sofa()&#123;</span><br><span class="line">&#125;;</span><br><span class="line">~Sofa()&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sit&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SofaBed</span> :</span> <span class="keyword">public</span> Bed, <span class="keyword">public</span> Sofa &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SofaBed()&#123;</span><br><span class="line">&#125;</span><br><span class="line">~SofaBed()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Sofa s;</span><br><span class="line">s.sit();</span><br><span class="line">Bed b;</span><br><span class="line">b.sleep();</span><br><span class="line"></span><br><span class="line">SofaBed sb;</span><br><span class="line">sb.sit();</span><br><span class="line">sb.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虚继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虚继承：</span></span><br><span class="line"><span class="comment">1.如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，</span></span><br><span class="line"><span class="comment">则在对该基类中声明的名字进行访问时，可能产生二义性 </span></span><br><span class="line"><span class="comment">2.如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，</span></span><br><span class="line"><span class="comment">这个公共基类就会在派生类的对象中产生多个基类子对象</span></span><br><span class="line"><span class="comment">3.要使这个公共基类在派生类中只产生一个对象，必须对这个基类声明为虚继承，</span></span><br><span class="line"><span class="comment">使这个基类成为虚基类</span></span><br><span class="line"><span class="comment">4.虚继承声明使用关键字 virtual </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B1上B的副本只有一个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B2上B的副本只有一个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先继承B1保存一个B副本，再继承B2就不再保存第二个B副本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B1, <span class="keyword">public</span> B2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">C cc;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cc.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cc.B1::b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cc.B2::b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//这三个访问的都是一个东西，如果不是虚继承的话，第一个无法访问，后两个是两个不同的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数覆盖与二义性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于非静态同名成员变量也是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span>:</span><span class="keyword">public</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Point pt;</span><br><span class="line">Point3D pt3d;</span><br><span class="line"></span><br><span class="line">pt.Print(); <span class="comment">//1</span></span><br><span class="line">pt3d.Print(); <span class="comment">//2</span></span><br><span class="line">pt3d.Point::Print(); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">pt3d.Print(<span class="number">3</span>);<span class="comment">//识别不了，子类会覆盖父类所有同名函数，重载了也不行</span></span><br><span class="line">pt3d.Point::Print(<span class="number">3</span>);<span class="comment">//可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态同名函数也基本一样</span></span><br><span class="line"><span class="comment">// 就是比非静态多个通过类名访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> B::a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b.a;<span class="comment">//2</span></span><br><span class="line">b.A::a;<span class="comment">//1</span></span><br><span class="line">B::a;<span class="comment">//2</span></span><br><span class="line">B::A::a;<span class="comment">//1第一个::代表通过类名访问，第二个::代表父类作用域</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.智能指针</title>
      <link href="2020/01/31/C++/12.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2020/01/31/C++/12.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="智能指针的引入"><a href="#智能指针的引入" class="headerlink" title="智能指针的引入"></a>智能指针的引入</h3><ul><li>堆区创建对象，有可能会忘记释放内存<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">T t = <span class="keyword">new</span> T();</span><br><span class="line"><span class="keyword">delete</span> T;<span class="comment">// 因为T有析构函数，可能会忘记这一步</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="智能指针的定义"><a href="#智能指针的定义" class="headerlink" title="智能指针的定义"></a>智能指针的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T *t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">smartPointer(T *t) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; t = t;</span><br><span class="line">&#125;</span><br><span class="line">~smartPointer() &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> -&gt; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span> -&gt; t;</span><br><span class="line"><span class="keyword">this</span> -&gt; t = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">smartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br><span class="line">sp.t -&gt; x;<span class="comment">// 可以这样访问t，不方便，所以需要重载操作符</span></span><br></pre></td></tr></table></figure><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span> -&gt; t;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> -&gt; t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sp -&gt; x;<span class="comment">//现在可以这样使用，本来应该是sp-&gt;-&gt;x，但是编译器做了优化，就不能写-&gt;-&gt;了</span></span><br><span class="line">(*sp).x;<span class="comment">//也可这样，虽然这里sp不是指针，但是操作符重载了</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解引用 与 智能指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">new或malloc出来的堆空间都需要手动delete或free，C++有一种机制，无需释放</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dis&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">p -&gt; dis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dis&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PMA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">PMA(A *p) : _p(p) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~PMA() &#123;</span><br><span class="line"><span class="keyword">delete</span> _p;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line"><span class="keyword">return</span> *_p;</span><br><span class="line">&#125;</span><br><span class="line">A* <span class="keyword">operator</span>-&gt; () &#123;</span><br><span class="line"><span class="keyword">return</span> _p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A *_p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2020-5-18补充"><a href="#2020-5-18补充" class="headerlink" title="2020.5.18补充"></a>2020.5.18补充</h3><p>c++中文文档: <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%e9%a6%96%e9%a1%b5</a></p><blockquote><p>为了更容易（同时也更安全的管）的使用动态内存，新的标准库（C++11）提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似于常规指针。重要的区别是它负责自动释放所指向的对象。新标准提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。</p><p>week_ptr -&gt; 管理shared_ptr</p><p>auto_ptr  -&gt; c++17</p><p><strong>智能指针也是模板。</strong></p></blockquote><ul><li><p>头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>一般格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;  <span class="comment">//指向string的shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2;   <span class="comment">//指向int的shared_ptr</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-1-shared-ptr"><a href="#1-1-shared-ptr" class="headerlink" title="1.1 shared_ptr"></a>1.1 shared_ptr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 使用智能指针和一块内存进行管联, 这块内存就有一个引用计数, 关联一次引用计数+1</span></span><br><span class="line"><span class="comment">// 当内存引用计数减为 0 时候, 内存就被指针指针删除了</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>shared_ptr 允许有多个指针指向同一个对象</strong>, <strong>我们可以认为每个share_ptr都有一个关联的计数器，通常称为引用计数（reference count）。无论何时我们拷贝一个shared_ptr，计数器都会递增。</strong><font color="red">一旦某个对象的引用计数变为0，这个对象会被自动删除。</font></p><p>例如这些都会使所关联的计数器<strong>递增</strong>：</p><p><strong>（1）当用一个shared_ptr初始化另外一个shared_ptr</strong></p><p><strong>（2）将它作为参数传递给另外一个函数</strong></p><p><strong>（3）作为函数的返回值</strong></p><p>例如这些操作会使计数器都会<strong>递减：</strong></p><p><strong>（1）给share_ptr赋新的值</strong></p><p><strong>（2）share_ptr被销毁</strong></p><p><strong>（3）局部的share_ptr离开作用域</strong></p></blockquote><ul><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 shared_ptr 的构造函数，可以让 shared_ptr 对象托管一个 new 运算符返回的指针</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T)</span></span>;  <span class="comment">// T 可以是 int、char、类等各种类型</span></span><br><span class="line"><span class="comment">// 使用make_shared函数分配一个对象并初始化它，make_shared函数返回一个指向此对象的shared_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">make_shared</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">// 通过另一个智能指针初始化</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; ptr = ptr1;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">ptr</span><span class="params">(ptr1)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>查看引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>返回存储的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>重置管理的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">( Y* ptr )</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>删除器 -&gt; 回调函数 -&gt; 删除智能指针管理的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认, 删除器函数, 会自动调用</span></span><br><span class="line">default_delete()</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>), default_delete&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"><span class="comment">// share_ptr 的 默认删除器, 不能删除new的数组内存, 需要自己指定删除器函数</span></span><br><span class="line"><span class="comment">// 通过share_ptr的构造函数, 在构造函数的第二个参数的位置上, 指定回调函数</span></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line">[](args)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *<span class="built_in">array</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">delete</span>[]<span class="built_in">array</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> A[<span class="number">10</span>], [](A* a) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">delete</span> []a;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"><span class="comment">// 规律:</span></span><br><span class="line">删除器函数需要一个参数, 参数类型: 智能指针管理的内存地址的类型, 函数体中进行内存释放</span><br><span class="line">删除器函数别智能指针调用的时候, 会将<span class="keyword">new</span>得到的内存地址, 传递给删除器函数的参数</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-unique-ptr"><a href="#1-2-unique-ptr" class="headerlink" title="1.2 unique_ptr"></a>1.2 unique_ptr</h2><blockquote><p><strong>unique_ptr独占所指向的对象。</strong>同一时刻只能有一个 unique_ptr 指向给定对象(通过禁止拷贝语义, 只有移动语义来实现)</p></blockquote><ul><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T)</span></span>;  <span class="comment">// T 可以是 int、char、类等各种类型</span></span><br><span class="line"><span class="comment">// 使用make_unique</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>unique_ptr 支持对数组内存管理</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.运算符重载</title>
      <link href="2020/01/31/C++/11.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>2020/01/31/C++/11.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="问题1：参数必须是常引用么？"><a href="#问题1：参数必须是常引用么？" class="headerlink" title="问题1：参数必须是常引用么？"></a>问题1：参数必须是常引用么？</h3><ol><li>可以不是引用，但会产生对象拷贝动作，降低效率</li><li>可以不是常引用，但无法限制函数内部对参数的修改</li><li>可以使用指针，但是与常规数学公式使用方法不符 例如：a + &amp;b</li></ol><h3 id="问题2：返回值必须是类对象么？返回引用是否可行？"><a href="#问题2：返回值必须是类对象么？返回引用是否可行？" class="headerlink" title="问题2：返回值必须是类对象么？返回引用是否可行？"></a>问题2：返回值必须是类对象么？返回引用是否可行？</h3><ol><li>可以返回引用，但必须是全局对象或通过参数传递进去的，不能引用函数内部的局部变量</li></ol><h3 id="问题3：运算符必须重载为成员函数么？"><a href="#问题3：运算符必须重载为成员函数么？" class="headerlink" title="问题3：运算符必须重载为成员函数么？"></a>问题3：运算符必须重载为成员函数么？</h3><ol><li>不，可以重载为类的友元函数或普通函数。注意：普通函数无法访问类的私有成员</li><li>重载为类的成员函数少一个参数(隐含this，表示二元表达式的左参数或一元表达式的参数)</li><li>重载为类的友元函数没有隐含this参数</li><li>一般全局常用操作符(关系操作符，逻辑操作符，流操作符)重载为友元函数，设计对象特殊运算的操作符重载为成员函数</li><li>一般单目操作符重载为成员函数，双目操作符重载为友元函数</li><li>部分双目操作符不能重载为友元函数：”=”,”()”,”[]”,”-&gt;”</li><li>类型转换操作符只能重载为成员函数</li></ol><h3 id="问题4：哪些操作符不可重载？"><a href="#问题4：哪些操作符不可重载？" class="headerlink" title="问题4：哪些操作符不可重载？"></a>问题4：哪些操作符不可重载？</h3><ol><li>“::”, “?:”, “.”, “.*”, “sizeof”, “#”, “##”, “typeid”</li></ol><h3 id="2020-3-15-再学新增"><a href="#2020-3-15-再学新增" class="headerlink" title="2020.3.15 再学新增"></a>2020.3.15 再学新增</h3><ol><li>本质调用：<ul><li>成员函数：T t3 = t1.operator+(t2);</li><li>全局函数：T t3 = operator+(t1,t2);</li></ul></li><li>简化调用：<ul><li>T t3 = t1 + t3;</li></ul></li><li>运算符重载是可以发生函数重载的</li><li>如果想重载&lt;&lt;运算符用作输出，那么成员只能做到t &lt;&lt; cout，使用全局函数才可以做到cout &lt;&lt; t</li><li>不建议重载&amp;&amp; || 无法实现短路特性</li></ol><p><strong>复数类重载+运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">float</span> x = <span class="number">0</span>, <span class="keyword">float</span> y = <span class="number">0</span>):_x(x), _y(y) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line"><span class="keyword">const</span> Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;another);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;友元函数重载&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> Complex(c1._x + c2._x, c1._y + c2._y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;another) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成员函数重载&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> Complex(<span class="keyword">this</span> -&gt; _x + another._x, <span class="keyword">this</span> -&gt; _y + another._y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Complex c1(2,3), c2(3,4);</span><br><span class="line">c1.dis();</span><br><span class="line">c2.dis();</span><br><span class="line">Complex c3 = c1 + c2;</span><br><span class="line"><span class="comment">//Complex c4 = operator+(c1,c2);</span></span><br><span class="line">c3.dis();</span><br><span class="line">c4.dis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复数类重载+=运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">float</span> x = <span class="number">0</span>, <span class="keyword">float</span> y = <span class="number">0</span>):_x(x), _y(y) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex&amp; <span class="keyword">operator</span>+= (<span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; _x += c._x;</span><br><span class="line"><span class="keyword">this</span> -&gt; _y += c._y;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">(a += b) += c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Complex a1(10,0), b1(20,0), c1(30,0);</span><br><span class="line">(a1 += b1) += c1;</span><br><span class="line">a1.dis();</span><br><span class="line">b1.dis();</span><br><span class="line">c1.dis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复数类重载前++运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>) : x(xx), y(yy) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>++(Complex&amp; c) &#123;</span><br><span class="line">c.x++;</span><br><span class="line">c.y++;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">c.dis();</span><br><span class="line">Complex c2 = ++c;</span><br><span class="line">c2.dis();</span><br><span class="line">c.dis();</span><br><span class="line">c2 = ++++c;</span><br><span class="line">c2.dis();</span><br><span class="line">c.dis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复数类重载后++运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>) : x(xx), y(yy) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Complex <span class="keyword">operator</span>++(Complex&amp; c, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Complex <span class="keyword">operator</span>++(Complex&amp; c, <span class="keyword">int</span>) &#123;<span class="comment">//这里的占位int是为了让编译器识别出这是后++不是前++</span></span><br><span class="line"><span class="function">Complex <span class="title">t</span><span class="params">(c.x, c.y)</span></span>;<span class="comment">//注意这里，前++返回引用且不创建新对象，所以for循环时用++i效率更高</span></span><br><span class="line">c.x++;</span><br><span class="line">c.y++;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">10.10</span>)</span></span>;</span><br><span class="line">c.dis();</span><br><span class="line">Complex c2 = c++;</span><br><span class="line">c2.dis();</span><br><span class="line">c.dis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复数类重载 &gt;&gt; &lt;&lt; 运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>) : x(xx), y(yy) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须使用此格式，以与流的连续书写特性保持一致</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="keyword">const</span> Complex&amp; c);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream &amp;is, Complex &amp;c);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">os &lt;&lt; c.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream &amp;is, Complex &amp;c) &#123;</span><br><span class="line">is &gt;&gt; c.x&gt;&gt; c.y;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元还是成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一个操作符的左右操作数不一定是相同类型的对象，这就涉及到将该操作符函数定义为谁的友元谁的成员问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一个操作符函数，被声明为哪个类的成员，取决于该函数的调用对象（通常是左值）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一个操作符函数，被声明为哪个类的友元，取决于该函数的参数对象（通常是右值） </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mail</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sender</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Sender(<span class="built_in">string</span> s):addr(s) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Sender&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="keyword">const</span> Mail&amp; mail);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mail</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Mail(<span class="built_in">string</span> t,<span class="built_in">string</span> c) : title(t), content(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> Sender&amp; Sender::<span class="keyword">operator</span>&lt;&lt; (<span class="keyword">const</span> Mail&amp; mail);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> title;</span><br><span class="line"><span class="built_in">string</span> content;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sender&amp; Sender::<span class="keyword">operator</span>&lt;&lt; (<span class="keyword">const</span> Mail&amp; mail) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; addr &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mail.title &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mail.content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Sender <span class="title">sender</span><span class="params">(<span class="string">&quot;123@gmail.com&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Mail <span class="title">mail</span><span class="params">(<span class="string">&quot;note&quot;</span>,<span class="string">&quot;hah&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Mail <span class="title">mail2</span><span class="params">(<span class="string">&quot;tour&quot;</span>,<span class="string">&quot;666&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">sender &lt;&lt; mail &lt;&lt; mail2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>赋值运算符重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">赋值运算符重载</span></span><br><span class="line"><span class="comment">1.系统默认提供的赋值运算符重载，一经实现，不复存在</span></span><br><span class="line"><span class="comment">2.系统提供的也是等位拷贝，也就是浅拷贝</span></span><br><span class="line"><span class="comment">3.要实现深拷贝，必须自定义</span></span><br><span class="line"><span class="comment">4.自定义面临三个问题：自赋值（A = A），内存泄漏，重析构 </span></span><br><span class="line"><span class="comment">5.返回引用，且不能用const修饰，目的是实现连等 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; another) &#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>下标运算符[]重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下表运算符需要重载两个版本，数组成员有可能是常量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">v = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">size = n;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">vector</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] v;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="keyword">return</span> v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span>* v;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span> <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>括号运算符()重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sqr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> d * d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Sqr sqr;</span><br><span class="line"><span class="keyword">int</span> i = sqr(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">double</span> d = sqr(<span class="number">5.5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.友元</title>
      <link href="2020/01/31/C++/10.%E5%8F%8B%E5%85%83/"/>
      <url>2020/01/31/C++/10.%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">友元函数是可以直接访问类的私有成员的非成员函数，他是定义在类外的普通函数，需要加上friend关键字 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy) &#123;</span><br><span class="line">x = xx;</span><br><span class="line">y = yy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getxy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::Getxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> dx = a.x - b.x;</span><br><span class="line"><span class="keyword">double</span> dy = a.y - b.y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Point p1(3.0,4.0), p2(6.0,8.0);</span><br><span class="line">p1.Getxy();</span><br><span class="line">p2.Getxy();</span><br><span class="line"><span class="keyword">double</span> d = Distance(p1, p2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类成员函数作友元函数 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>;</span><span class="comment">//前向声明，是一种不完全型声明，只需提供类名，仅可用于声明指针和引用。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManagerPoint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy) &#123;</span><br><span class="line">x = xx;</span><br><span class="line">y = yy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getxy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">ManagerPoint::Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::Getxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ManagerPoint::Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> dx = a.x - b.x;</span><br><span class="line"><span class="keyword">double</span> dy = a.y - b.y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Point p1(3.0,4.0), p2(6.0,8.0);</span><br><span class="line">p1.Getxy();</span><br><span class="line">p2.Getxy();</span><br><span class="line">ManagerPoint mp;</span><br><span class="line"><span class="keyword">float</span> d = mp.Distance(p1,p2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息</span></span><br><span class="line"><span class="comment">当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">friend class ClassName;</span></span><br><span class="line"><span class="comment">ClassName必须是一个已经定义过的类，例如以下语句说明B是A的友元类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class A &#123;</span></span><br><span class="line"><span class="comment">... </span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">friend class B;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">友元总结：</span></span><br><span class="line"><span class="comment">声明位置：友元声明以关键字friend开始，只能出现在类定义中，因为友元不是授权类的成员，所以它不受其所在类的声明区域的影响，</span></span><br><span class="line"><span class="comment">通常我们把所有友元声明组织在一起放在类头之后。</span></span><br><span class="line"><span class="comment">友元的利弊：友元不是类成员，但可以访问类中私有成员，提高了运行效率但是破坏了封装性和隐藏性。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">友元不能被继承</span></span><br><span class="line"><span class="comment">友元关系是单向的，不具有交换性</span></span><br><span class="line"><span class="comment">友元关系不具有传递性，若B是A友元，C是B友元，C不一定是A友元 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.this指针</title>
      <link href="2020/01/31/C++/9.this%E6%8C%87%E9%92%88/"/>
      <url>2020/01/31/C++/9.this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C++ 类对象中的成员变量和成员函数是分开存储的，C语言中的内存四区模型仍然有效 </span></span><br><span class="line"><span class="comment">C++ 中类的普通成员函数都隐式的包含一个指向当前对象的this指针</span></span><br><span class="line"><span class="comment">静态成员函数，成员变量属于类</span></span><br><span class="line"><span class="comment">静态成员函数与普通函数的区别</span></span><br><span class="line"><span class="comment">静态成员函数不包含指向具体对象的指针</span></span><br><span class="line"><span class="comment">普通成员函数包含一个指向具体对象的指针 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; a = a;<span class="comment">//若类的成员函数的形参和类的属性名字相同，通过this指针来解决 </span></span><br><span class="line"><span class="keyword">this</span> -&gt; b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">()</span> </span>&#123;<span class="comment">//类的成员函数可以通过const修饰 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//不写this编译器也会自动加上的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; b &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">t.printT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是如果传进去的this指针为NULL，调用成员程序会崩掉</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test *t = <span class="literal">NULL</span>;</span><br><span class="line">t -&gt; printT();<span class="comment">//会崩，因为NULL -&gt; a</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.静态成员</title>
      <link href="2020/01/31/C++/8.%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
      <url>2020/01/31/C++/8.%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C++ 中，静态成员是属于整个类的，而不是某个对象</span></span><br><span class="line"><span class="comment">使用静态成员实现多个对象之间的数据共享，不会破坏隐藏的原则，保证了安全性并节省内存 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">声明在类内部</span></span><br><span class="line"><span class="comment">static int n; </span></span><br><span class="line"><span class="comment">初始化在类外部 </span></span><br><span class="line"><span class="comment">int ClassName::n = 0;</span></span><br><span class="line"><span class="comment">调用</span></span><br><span class="line"><span class="comment">ClassName::n</span></span><br><span class="line"><span class="comment">Obj.n </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static 成员变量实现了同类对象间信息共享</span></span><br><span class="line"><span class="comment">static 成员类外存储，求类大小时不包含在内</span></span><br><span class="line"><span class="comment">static 成员是命名空间属于类的全局变量，储存在data区</span></span><br><span class="line"><span class="comment">static 成员只能类外初始化</span></span><br><span class="line"><span class="comment">可以通过类名访问，无对象生成时亦可，也可以通过对象访问 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Box(<span class="keyword">int</span> l, <span class="keyword">int</span> w) : length(l),width(w) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> length * width * height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Box::height = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Box::height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function">Box <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b.height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b.volume() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态成员函数</span></span><br><span class="line"><span class="comment">声明：static 函数声明</span></span><br><span class="line"><span class="comment">调用：类名::函数调用类对象.函数调用 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态成员函数的意义不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装</span></span><br><span class="line"><span class="comment">静态成员函数只能访问静态数据成员，原因：非静态成员函数，在调用this指针被当作参数传进，而静态成员函数属于类不属于对象，没有this指针 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student(<span class="keyword">int</span> n,  <span class="keyword">int</span> a, <span class="keyword">float</span> s):num(n),age(a),score(s) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">total</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">sum += score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">average</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum / count;<span class="comment">//貌似写里面也行 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">float</span> score;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> sum;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Student::sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Student::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float Student::average() &#123;</span></span><br><span class="line"><span class="comment">//return sum/count;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student stu[<span class="number">3</span>] = &#123;</span><br><span class="line">Student(<span class="number">1001</span>,<span class="number">14</span>,<span class="number">70</span>),</span><br><span class="line">Student(<span class="number">1002</span>,<span class="number">15</span>,<span class="number">34</span>),</span><br><span class="line">Student(<span class="number">1003</span>,<span class="number">16</span>,<span class="number">90</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">stu[i].total();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Student::average() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.初始化列表</title>
      <link href="2020/01/31/C++/7.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
      <url>2020/01/31/C++/7.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="初始化列表的目的与意义"><a href="#初始化列表的目的与意义" class="headerlink" title="初始化列表的目的与意义"></a>初始化列表的目的与意义</h3><ol><li>在构造对象时，同步构造内部对象</li><li>部分成员（常量与引用）只能初始化，不能赋值</li><li>部分成员（类的对象）如果赋值，将导致两次构造<ol><li>在分配内存时，调用缺省构造函数构造，然后执行构造函数体内的赋值语句再次构造，效率不佳</li><li>若类没有缺省构造函数，则会导致问题</li></ol></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>成员初始化按照成员定义顺序，而不是初始化列表顺序</li><li>必须保持初始化列表和成员定义的顺序一致性，但允许跳过部分成员，否则后续成员可能不会正确初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> a) &#123;</span><br><span class="line">x = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> b):y(b),obja(<span class="number">30</span>),m(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//类和const或引用都需要列表初始化 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">A obja;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">A <span class="title">obja</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">objb</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objb.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; objb.obja.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; objb.m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.构造析构</title>
      <link href="2020/01/31/C++/6.%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84/"/>
      <url>2020/01/31/C++/6.%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul><li>在对象创建时自动调用</li><li>无返回值，默认无参，可以重载</li><li>一经实现，默认不复存在</li><li>只能由系统在创建对象时自动调用，程序其他部分不能直接调用</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>对象销毁时，自动调用</li><li>无参，不可以重载与默认参数 </li><li>不是删除对象，而是对象销毁前完成一些清理的工作</li><li>可以由系统在对象销毁时自动调用，也可以由程序其他部分调用，但二者工作原理不同</li><li>每个类只能有一个析构函数</li></ul><h3 id="默认提供"><a href="#默认提供" class="headerlink" title="默认提供"></a>默认提供</h3><ul><li>默认无参构造函数：如果没有定义构造函数(有参或无参或拷贝)，会默认提供一个无参构造函数，函数体为空</li><li>默认拷贝构造函数：如果没有定义拷贝构造函数，默认提供一个，简单的进行成员变量的值复制，即等位拷贝/浅拷贝 </li><li>默认赋值构造函数：如果没有定义赋值构造函数，默认提供一个，简单的进行成员变量的值复制，即等位拷贝/浅拷贝 </li><li>默认析构函数：若未定义，系统会自动产生一个缺省析构函数，无参无具体实现</li><li>浅拷贝：指针也会拷贝过去，也就是两个都指向一块空间，其中一个析构了，另一个就非法了 </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test() &#123;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">Test(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">a = x;</span><br><span class="line">b = y;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">Test(<span class="keyword">const</span> Test &amp;another) &#123;<span class="comment">//这里必须是引用，不是的话就会递归调用拷贝构造，因为值传递本身就是拷贝的过程</span></span><br><span class="line">a = another.a;</span><br><span class="line">b = another.b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line">~Test() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Test p)</span> </span>&#123;<span class="comment">//会执行拷贝操作 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(t2)</span></span>;</span><br><span class="line">Test t3 = t1;<span class="comment">//这个也是拷贝构造的形式 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t2.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t2.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t1.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t1.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t3.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t3.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">func(t1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要使用括号法调用无参构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">()</span></span>;<span class="comment">//应该用Person p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//这是个函数声明，跟上面长得一样</span></span><br><span class="line"></span><br><span class="line">Person p = Person();<span class="comment">//这样也行，显示构造</span></span><br><span class="line">Person p;<span class="comment">//这样也行</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">18</span>)</span></span>;<span class="comment">//有参构造是可以的</span></span><br><span class="line"></span><br><span class="line">Person();<span class="comment">//单写称为匿名对象，本行执行完毕立即释放</span></span><br><span class="line">Person(p1);<span class="comment">//不能这样调用拷贝构造匿名对象，编译器会认为是Person p1; 造成重定义</span></span><br><span class="line">Person p = Person(p1);<span class="comment">//但是这样是可以的</span></span><br><span class="line"></span><br><span class="line">Person p = <span class="number">18</span>;<span class="comment">//编译器会隐式转换为Person p = Person(18);</span></span><br><span class="line">Person p = p1;<span class="comment">//隐式转换为Person p = Person(p1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数调用总结："><a href="#构造函数调用总结：" class="headerlink" title="构造函数调用总结："></a>构造函数调用总结：</h3><ol><li>括号法：<ul><li>Person p(18);</li><li>Person p(p1);</li></ul></li><li>显示法：<ul><li>Person p = Person();</li><li>Person p = Person(18);</li><li>Person p = Person(p1);</li></ul></li><li>隐式转换法：<ul><li>Person p = 18;</li><li>Person p = p1;</li></ul></li><li>匿名对象：<ul><li>Person();</li><li>Person(18);</li></ul></li></ol><h3 id="拷贝构造函数的调用时机："><a href="#拷贝构造函数的调用时机：" class="headerlink" title="拷贝构造函数的调用时机："></a>拷贝构造函数的调用时机：</h3><ol><li>正常传递一个已存在的对象给拷贝构造函数</li><li>函数的值传递</li><li>函数的值返回（有时候编译器会做优化，函数调用前创建，传给函数引用，这样就没有了拷贝的过程）</li></ol><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>A类中有B类，构造A类时会先构造B类，析构A类是会先析构A类</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">A(<span class="keyword">int</span> a):a(a) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A()\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">int</span> a) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator=\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a = <span class="number">0</span>;<span class="comment">//A()</span></span><br><span class="line">a = <span class="number">1</span>;<span class="comment">//operator=</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.函数指针</title>
      <link href="2020/01/31/C++/5.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
      <url>2020/01/31/C++/5.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PFUNC1)</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PFUNC2)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">PFUNC1 p = func;</span><br><span class="line">c = p(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">PFUNC2 q = func;</span><br><span class="line">c = q(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数指针语法总结：</span></span><br><span class="line"><span class="comment">方法1：</span></span><br><span class="line"><span class="comment">声明一个函数类型</span></span><br><span class="line"><span class="comment">typedef void (F)(int a,int b);</span></span><br><span class="line"><span class="comment">定义一个函数指针</span></span><br><span class="line"><span class="comment">F *p = NULL; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法2：</span></span><br><span class="line"><span class="comment">声明一个函数指针类型</span></span><br><span class="line"><span class="comment">typedef void (*F)(int a,int b);</span></span><br><span class="line"><span class="comment">F p = NULL;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法3：</span></span><br><span class="line"><span class="comment">定义一个函数指针变量</span></span><br><span class="line"><span class="comment">void (*F)(int a,int b); </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.函数参数</title>
      <link href="2020/01/31/C++/4.%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
      <url>2020/01/31/C++/4.%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">(<span class="keyword">float</span> length,<span class="keyword">float</span> weight = <span class="number">4</span>,<span class="keyword">float</span> high = <span class="number">5</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> length * weight * high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> v1 = volume(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">float</span> v2 = volume(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">float</span> v3 = volume(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">只有参数列表后面的参数才可以提供默认参数值</span></span><br><span class="line"><span class="comment">一旦开始使用默认参数值，后面都要使用默认参数值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数的声明和实现只能一个有默认参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//func(1, 2); 必须把占位参数补上 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; func1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以默认参数占位参数一起使用 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; func2(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.内联函数</title>
      <link href="2020/01/31/C++/3.%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>2020/01/31/C++/3.%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="宏函数的缺陷："><a href="#宏函数的缺陷：" class="headerlink" title="宏函数的缺陷："></a>宏函数的缺陷：</h2><ol><li>需要加小括号保证运算完整性<ul><li>#define ADD(x,y) x+y</li><li>ret = ADD(1,2) * 3</li></ul></li><li>即使加了括号有些情况依然与预期不符<ul><li>#define CMP(x,y) (((a)&lt;(b))?(a):(b))</li><li>a = 10, b = 20</li><li>ret = CMP(++a,b)    // 12</li></ul></li></ol><h2 id="内联函数使用的注意事项"><a href="#内联函数使用的注意事项" class="headerlink" title="内联函数使用的注意事项"></a>内联函数使用的注意事项</h2><ol><li>在函数定义前添加inline关键字，仅在函数原型前使用此关键字无效，定义和实现都要写</li><li>编译器必须能看见内联函数的代码才能在编译期展开，因而内联函数必须实现在头文件中</li><li>在类定义中给出函数体的成员函数自动成为内联函数</li><li>函数体代码量大，或包含循环，不要使用内联</li><li>构造函数和析构函数有可能隐含附加操作，慎用内联</li><li>对于编译器来说，内联函数仅仅是建议，编译器会自主选择是否使用内联函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">func(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：避免调用函数时的额外开销（入栈出栈操作）</span></span><br><span class="line"><span class="comment">代价：会在代码段中出现多个副本，会增加代码空间</span></span><br><span class="line"><span class="comment">本质：以牺牲代码段空间的代价提高程序的运行时间的效率</span></span><br><span class="line"><span class="comment">使用场景：函数体很小且被频繁使用 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.引用</title>
      <link href="2020/01/31/C++/2.%E5%BC%95%E7%94%A8/"/>
      <url>2020/01/31/C++/2.%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">*p = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">b = <span class="number">14</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> &amp;a;</span><br><span class="line"><span class="keyword">int</span> &amp;b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(Teacher) %d\n&quot;</span>,<span class="keyword">sizeof</span>(Teacher));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.引用在C++内部实现是一个常指针</span></span><br><span class="line"><span class="comment">Type&amp; name  === Type* const name</span></span><br><span class="line"><span class="comment">2.引用是占内存空间的，与指针相同 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//printf(&quot;%p\n&quot;,&amp;a);</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;a = getA();</span><br><span class="line"><span class="comment">//printf(&quot;%p\n&quot;,&amp;a);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈值作为右值在内存上是非法的，但是上面这个可以编译</span></span><br><span class="line"><span class="comment">取消掉注释就不行了，真·黑盒编程~~！！！ </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTeacher</span> <span class="params">(Teacher* &amp;myp)</span> </span>&#123;</span><br><span class="line">myp = (Teacher *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Teacher));</span><br><span class="line"><span class="keyword">if</span> (myp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">myp -&gt; age = <span class="number">36</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FreeTeacher</span> <span class="params">(Teacher *pT1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pT1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(pT1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Teacher *pT1 = <span class="literal">NULL</span>;</span><br><span class="line">getTeacher(pT1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pT1 -&gt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">FreeTeacher(pT1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">40</span>; <span class="comment">//a在符号表中 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;m = <span class="number">43</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int tmp = 43;</span></span><br><span class="line"><span class="comment">const int &amp;m = tmp; </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对数组的引用"><a href="#对数组的引用" class="headerlink" title="对数组的引用"></a>对数组的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//1、直接建立引用</span></span><br><span class="line"><span class="keyword">int</span>(&amp;pArr)[<span class="number">5</span>] = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、先定义数组类型，再通过类型定义数组的引用</span></span><br><span class="line">typedef int(ARRAY_TYPE)[5];</span><br><span class="line">ARRAY_TYPE &amp; pArr2 = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、 先定义数组引用类型，再通过类型定义引用</span></span><br><span class="line">typedef int(&amp;ARRAY_TYPE_REF)[5];</span><br><span class="line">ARRAY_TYPE_REF pArr3 = arr;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;ref = fun();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当函数返回值是引用时候，那么函数的调用可以作为左值存在</span></span><br><span class="line">fun() = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;b = <span class="number">10</span>; <span class="comment">//非法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">10</span>; <span class="comment">//编译器将代码修改为 ：  int temp = 10;  const int &amp;b = temp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//b = 100;//失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span> *)&amp;b;</span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//20</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.命名空间</title>
      <link href="2020/01/31/C++/1.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>2020/01/31/C++/1.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h3><ol><li>作用：解决名称冲突</li><li>命名空间下可以存放：变量，函数，结构体，类</li><li>命名空间必须声明在全局作用域</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时向空间下添加新成员</li><li>命名空间是可以匿名的</li><li>命名空间可以起别名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> B::C::Teacher;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,B::a);</span><br><span class="line"></span><br><span class="line">Teacher t = &#123;<span class="string">&quot;Li&quot;</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t.name = %s\nt.age = %d\n&quot;</span>,t.name,t.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本语法元素</title>
      <link href="2020/01/30/C++/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/"/>
      <url>2020/01/30/C++/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>三种程序设计形态</strong></p><ol><li>结构化程序设计</li><li>面向对象程序设计</li><li>泛型编程<br> 标准模板库：迭代器、容器、抽象算法</li></ol><p><strong>gcc and g++</strong></p><ul><li>gcc是各种语言编译器的合集，根据扩展名调用不同的编译器</li><li>g++是gcc的C++编译器<br>  g++ -o hello helloworld.cpp</li></ul><p><strong>程序设计的基本流程</strong></p><ol><li>编辑：源文件、头文件</li><li>编译：目标文件</li><li>链接：(目标文件、函数库文件) -&gt; 可执行文件</li><li>测试：可执行文件</li></ol><p><strong>数据类型</strong></p><ol><li>整数类型<br> <strong>int</strong>:32位程序中，表示-21亿～21亿，目前主流编译器都是32位的，作为普通应用程序32位已经足够</li></ol><p><strong>变量的四大基本特征(VANT)</strong></p><ol><li><strong>value</strong>:变量总是具有值</li><li><strong>address</strong>:变量总是与内存中的地址相对应</li><li><strong>name</strong>:变量总是具有名称</li><li><strong>type</strong>:变量总是具有确定的类型</li></ol><p><strong>文字</strong></p><ul><li>整数类型文字<ol><li>十进制表示：普通整数表示</li><li>十六进制表示：以0x或0X开头的0~9，A/a～F/f序列</li><li>八进制表示：以0开头的0~7序列</li></ol></li><li>浮点类型文字<ol><li>一般形式：由整数部分、小数点与小数部分组成，如3.14</li><li>指数形式：由尾数部分、字符E/e与指数部分组成，如3.14e3 = 3.14*10^3</li></ol></li><li>字符串类型文字<br>  双引号引起来的字符序列，如”Programming in C++”</li></ul><p><strong>常量</strong></p><ol><li>常量的定义:程序执行期间其值不可改变的量<br> <code>const double π = 3.14;</code></li><li>常量的意义:解决直接出现的文字无法解释其意义的问题</li><li>常量与变量<ul><li>常量不可改变值，其他与变量相同</li><li>定义常量时必须进行初始化</li><li>常量初始值必须能够在编译期间计算出来</li></ul></li></ol><p><strong>程序设计风格</strong></p><ol><li>注释</li><li>命名规范</li><li><a href="https://www.runoob.com/note/12963">宏与常量</a><br> #define指令:预处理命令，如 <code>#define PI 3.14</code>,预处理做单纯的文本替换<br> 一旦定义，可以代替常量使用，宏定义不是常量，程序中应优先使用常量而不是宏</li><li>赋值语句的简写形式</li><li>源代码排版</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thuC++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="2020/01/08/algo/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>2020/01/08/algo/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>范围：[0, n-1]，将最大值推到arr[n-1]<ul><li>arr[0] &gt; arr[1] ? swap() : continue;</li><li>arr[1] &gt; arr[2] ? swap() : continue;</li><li>……</li><li>arr[n-2] &gt; arr[n-1] ? swap() : continue;</li></ul></li><li>范围：[0, n-2]，将最大值推到arr[n-2]<ul><li>……</li><li>arr[n-3] &gt; arr[n-2] ? swap() : continue;</li></ul></li><li>……</li><li>范围：[0, 0]，排序结束</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：$O(N^2)$</li><li>额外空间复杂度：$O(1)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小和问题</title>
      <link href="2020/01/08/algo/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>2020/01/08/algo/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和，求一个数组的小和。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>[1,3,4,2,5]</li><li>1左边比1小的数：无</li><li>3左边比3小的数：1</li><li>4左边比4小的数：1、3</li><li>2左边比2小的数：1</li><li>5左边比5小的数：1、3、4、2</li><li>数组小和为：1+1+3+1+1+3+4+2=16</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反向思考就是寻找每个数i后面大于它的数量n，最后的结果即所有的i*n的和。本题使用归并排序，在merge的过程中找出n的值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tinysum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">sort(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tinysum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L == R) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">sort(arr, L, mid);</span><br><span class="line">sort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line"><span class="comment">// 只有这一行在原有的归并排序代码上做了改动，arr[p1] * (R-p2+1)即为i*n</span></span><br><span class="line">help[i++] = arr[p1] &lt; arr[p2] ? tinysum += arr[p1] * (R-p2+<span class="number">1</span>), arr[p1++] : arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">help[i++] = arr[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">help[i++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= R-L; ++j) &#123;</span><br><span class="line">arr[L+j] = help[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逆序对</title>
      <link href="2020/01/08/algo/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>2020/01/08/algo/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个数组中，左边的数如果比右边的大，则这两个数构成一组逆序对，要求打印出所有的逆序对。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和小和问题是一个类型的题目，这个是找出每个数右边比他小的数，同样使用归并排序。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>[1,3,4,2,5]</li><li>逆序对为：[3,2]、[4,2]</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">sort(arr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L == R) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">sort(arr, L, mid);</span><br><span class="line">sort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 相比于归并排序，改变在这个while，这里是降序排</span></span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[p1] &gt; arr[p2]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = p2; k &lt;= R; k++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, arr[p1], arr[k]);</span><br><span class="line">&#125;</span><br><span class="line">help[i++] = arr[p1++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">help[i++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">help[i++] = arr[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">help[i++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= R-L; ++j) &#123;</span><br><span class="line">arr[L+j] = help[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵</title>
      <link href="2020/01/08/algo/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>2020/01/08/algo/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="螺旋矩阵问题"><a href="#螺旋矩阵问题" class="headerlink" title="螺旋矩阵问题"></a>螺旋矩阵问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个n*m的矩阵，从(0,0)位置开始顺时针输出整个矩阵。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先从矩阵的边框考虑，给定左上和右下两个点就很容易遍历出整个边框的数，然后再将边框缩小一圈。（代码没有比换方向好多少，但是思路很清晰，像是原地旋转矩阵这种问题也可以通过这种思路求解）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">arr = [</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line"> ]</span><br><span class="line">ans = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edge</span>(<span class="params">a,b,x,y</span>):</span></span><br><span class="line">i = a</span><br><span class="line">j = b</span><br><span class="line">flag1 = <span class="number">0</span></span><br><span class="line">flag2 = <span class="number">0</span></span><br><span class="line">ans.append(arr[i][j])</span><br><span class="line"><span class="keyword">while</span> j &lt; y:</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">ans.append(arr[i][j])</span><br><span class="line"><span class="keyword">while</span> i &lt; x:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">ans.append(arr[i][j])</span><br><span class="line">flag1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &gt; b <span class="keyword">and</span> flag1:<span class="comment"># 只有向下走过才能再向左走，要不就一行再左走重复了</span></span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line">ans.append(arr[i][j])</span><br><span class="line">flag2 = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt; a+<span class="number">1</span> <span class="keyword">and</span> flag2:<span class="comment"># 防止回到起点多读一次，并且只有向左走过才能向上走</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">ans.append(arr[i][j])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix</span>(<span class="params">n, m</span>):</span></span><br><span class="line">a = <span class="number">0</span>; b = <span class="number">0</span>; x = n - <span class="number">1</span>; y = m - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt;= x <span class="keyword">and</span> b &lt;= y:</span><br><span class="line">edge(a,b,x,y)</span><br><span class="line">a += <span class="number">1</span>; b += <span class="number">1</span>; x -= <span class="number">1</span>; y -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">matrix(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">print(i, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>差值问题</title>
      <link href="2020/01/08/algo/%E5%B7%AE%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>2020/01/08/algo/%E5%B7%AE%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="差值问题"><a href="#差值问题" class="headerlink" title="差值问题"></a>差值问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，求排序之后，相邻两数的最大差值，要求时间复杂度O(N)，且要求不能用非基于比较的排序。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用桶的思想，将N个数分散到N+1个桶中，则至少有一个空桶，即最大差值不会出现在同一桶中，但结果不一定会跨越空桶。例如：[10-19]、[20-29]、[30-39]、[40-49]四个桶中的值分别为19、空、30、49，则最大差值为49-30。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tub</span>(<span class="params">num, length, minn, maxx</span>):</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">int</span>((num-minn)*length / (maxx-minn))<span class="comment"># 把一组数分散为0 ~ length</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">maxx = <span class="built_in">max</span>(arr)</span><br><span class="line">minn = <span class="built_in">min</span>(arr)</span><br><span class="line">length = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">being = [<span class="number">0</span>]*(length+<span class="number">1</span>)<span class="comment"># 将样本分成length+1分，这样一定有一个桶是空的，最大差值不会出现在一个桶内</span></span><br><span class="line">maxs  = [<span class="number">0</span>]*(length+<span class="number">1</span>)</span><br><span class="line">mins  = [<span class="number">0</span>]*(length+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">idx = tub(arr[i], length, minn, maxx)</span><br><span class="line"><span class="keyword">if</span> being[idx]:</span><br><span class="line">maxs[idx] = <span class="built_in">max</span>(maxs[idx], arr[i])</span><br><span class="line">mins[idx] = <span class="built_in">min</span>(mins[idx], arr[i])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">maxs[idx] = arr[i]</span><br><span class="line">mins[idx] = arr[i]</span><br><span class="line">being[idx] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">premax = maxs[<span class="number">0</span>]</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> being[i]:</span><br><span class="line">ans = <span class="built_in">max</span>(ans, mins[i]-premax)</span><br><span class="line">premax = maxs[i]</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>荷兰国旗</title>
      <link href="2020/01/08/algo/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/"/>
      <url>2020/01/08/algo/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h1><ul><li>补充：荷兰国旗问题可以用于求解数组中第k小或第k大数的问题，时间复杂度为O(N).</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设置L，R，cur三个指针，初始L = -1，R = n，cur = 0，cur遍历数组，如果arr[cur] &lt; num，swap(arr[L+1], arr[cur])，cur++，L++；如果arr[cur] = num，cur++；如果arr[cur] &gt; num，swap(arr[R-1], arr[cur])，R–；当cur = R，流程结束。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dutch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur = L + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cur &lt; R) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[cur] &lt; num) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[cur]; arr[cur] = arr[L+<span class="number">1</span>]; arr[L+<span class="number">1</span>] = tmp;</span><br><span class="line">++cur;</span><br><span class="line">++L;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[cur] == num) &#123;</span><br><span class="line">++cur;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[cur]; arr[cur] = arr[R<span class="number">-1</span>]; arr[R<span class="number">-1</span>] = tmp;</span><br><span class="line">--R;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">dutch(arr, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>给定一个链表list，和一个整数num，使其按照小于、等于、大于分成三部分排列，要求额外空间复杂度为O(1)。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>遍历链表，把每个节点按照小于、等于、大于分别串到三个链表上，遍历完成再把三个链表接起来，三个链表的头是第一次符合条件节点拷贝来的，余下都是指向原链表的节点，还需再设置三个链表尾用来追加链表，需要注意的是可能三个链表中有链表长度为零。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>manacher</title>
      <link href="2020/01/08/algo/manacher/"/>
      <url>2020/01/08/algo/manacher/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="manacher算法"><a href="#manacher算法" class="headerlink" title="manacher算法"></a>manacher算法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设置一个回文右边界，如果i&gt;R，暴力寻找；如果i&lt;=R，设ii为i的对称位：(1)ii回文在半径内，r[i]=r[ii]，(2)ii回文在半径外，r[i]=R-i，(3)ii回文压边界，从R+1开始暴力寻找。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> idx, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L &gt;= <span class="number">0</span> &amp;&amp; R &lt; <span class="built_in">strlen</span>(s) &amp;&amp; s[L] == s[R]) &#123;</span><br><span class="line">        --L;</span><br><span class="line">        ++R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R-idx<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = <span class="string">&quot;babad&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); ++i) &#123;</span><br><span class="line">        str[i*<span class="number">2</span>+<span class="number">1</span>] = s[i];</span><br><span class="line">        str[i*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> midx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; R) &#123;</span><br><span class="line">            ans[i] = foo(str, i, i<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ii = <span class="number">2</span>*C - i;</span><br><span class="line">            <span class="keyword">if</span>(ans[ii] &lt; R-i) &#123;</span><br><span class="line">                ans[i] = ans[ii];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ans[ii] &gt; R-i) &#123;</span><br><span class="line">                ans[i] = R-i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = foo(str, i, <span class="number">2</span>*i-R<span class="number">-1</span>, R+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]+i &gt; R) &#123;</span><br><span class="line">            R = ans[i]+i;</span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; maxx) &#123;</span><br><span class="line">            maxx = ans[i];</span><br><span class="line">            midx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> ret[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = midx-maxx; i &lt;= midx+maxx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret[j++] = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kmp</title>
      <link href="2020/01/08/algo/kmp/"/>
      <url>2020/01/08/algo/kmp/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h1><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>即每一位之前的字符串的前缀与后缀相等且长度不等于全长的最长的长度。</p><h2 id="优化过程"><a href="#优化过程" class="headerlink" title="优化过程"></a>优化过程</h2><p>如果匹配到某一位不等，那么从前缀的下一位开始继续比较。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>] = str[<span class="number">0</span>] == str[<span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = next[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[a] == str[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                next[i] = a + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    a = next[a];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">char</span>* str1, <span class="keyword">char</span>* str2, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="built_in">strlen</span>(str1) &amp;&amp; j &lt; <span class="built_in">strlen</span>(str2)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i] == str2[j]) &#123;</span><br><span class="line">            ++i, ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(next[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="built_in">strlen</span>(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="built_in">strlen</span>(str2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str1 = <span class="string">&quot;mississippi&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* str2 = <span class="string">&quot;pi&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    kmp(str2, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = index(str1, str2, next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序总结</title>
      <link href="2020/01/08/algo/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>2020/01/08/algo/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>数组中相同元素在排序前后的相对次序保持不变即为稳定性，例如在”姓名-班级-成绩”组中先按照成绩排序，接着使用稳定排序方法对班级进行排序，则在班级相同的情况下，成绩是排好序的，如果使用不稳定的排序方法对班级排序，那么在班级相同的情况下，成绩是乱序的。</p><ul><li>快速排序、选择排序、堆排序是无法做到稳定的</li></ul><h2 id="综合排序"><a href="#综合排序" class="headerlink" title="综合排序"></a>综合排序</h2><p>如果数组中元素为基本数据类型，使用快速排序；如果数组中元素为自定义数据类型，使用归并排序（稳定且快）；如果样本数量小于60，使用插入排序（常数项小）；所以对样本量大的数据先做快速排序或归并排序，当递归到某一部分样本量小于60时，使用插入排序。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>归并排序的额外空间复杂度可以降到$O(1)$，但是非常难，不需要掌握，也不需要知道，搜索关键字”归并排序 内部缓存法”</li><li>快速排序可以做到稳定性，但是非常难，不需要掌握，也不需要知道，搜索关键字”01 stable sort”</li></ol><h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><ul><li>桶排序、计数排序、基数排序</li><li>计数排序、基数排序是桶排序的实现</li></ul><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="2020/01/08/algo/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>2020/01/08/algo/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>范围：[0, n-1]，选出最小值与arr[0]交换</li><li>范围：[1, n-1]，选出最小值与arr[1]交换</li><li>……</li><li>范围：[n-1, n-1]，排序结束</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：$O(N^2)$</li><li>额外空间复杂度：$O(1)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mini = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">mini = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">mini = arr[j] &lt; arr[mini] ? j : mini;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[mini];</span><br><span class="line">arr[mini] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="2020/01/08/algo/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>2020/01/08/algo/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>范围：[1, n-1]，arr[1]不断与前一个数交换向前走，直到遇到比他小的数或走到尽头停止</li><li>范围：[2, n-1]，arr[2]…</li><li>…</li><li>范围：[n-1, n-1]，排序结束</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>最好时间复杂度：$O(N)$</li><li>最坏时间复杂度：$O(N^2)$</li><li>额外空间复杂度：$O(1)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>]; --j) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2020/01/08/algo/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/01/08/algo/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>堆是个二叉树，可以使用数组构建，i的父亲是(i-1)/2，i的左右子是2i+1，2i+2，大堆指堆的任意子树，根节点值最大，小堆类似。遍历数组构造大堆，然后不断让交换arr[0]与arr[size-1]，size–接着再使缩减后的堆成为大堆(heapify)，直到size为0，排序结束。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：$O(N*log N)$</li><li>额外空间复杂度：$O(1)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">arr, i</span>):</span></span><br><span class="line">parent = <span class="built_in">int</span>((i-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span> arr[i] &gt; arr[parent]:</span><br><span class="line">arr[i], arr[parent] = arr[parent], arr[i]</span><br><span class="line">i = parent</span><br><span class="line">parent = <span class="built_in">int</span>((i-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">arr, i, size</span>):</span></span><br><span class="line">left = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; size:<span class="comment"># 进入则表示i不是叶子节点</span></span><br><span class="line">right = i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> arr[left] &lt; arr[right] <span class="keyword">and</span> right &lt; size:</span><br><span class="line">largest = right</span><br><span class="line"><span class="keyword">else</span>: largest = left<span class="comment"># 此处largest为更大child的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arr[i] &lt; arr[largest]:</span><br><span class="line">arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">i = largest</span><br><span class="line">left = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap</span>(<span class="params">arr</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">insert(arr, i)</span><br><span class="line">size = <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">while</span> size:</span><br><span class="line">arr[<span class="number">0</span>], arr[size-<span class="number">1</span>] = arr[size-<span class="number">1</span>], arr[<span class="number">0</span>]</span><br><span class="line">size -= <span class="number">1</span></span><br><span class="line">heapify(arr, <span class="number">0</span>, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">heap(arr)</span><br></pre></td></tr></table></figure><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="2020/01/08/algo/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>2020/01/08/algo/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>经典快排<ul><li>取arr[n-1]作为basic，令arr左边全部小于等于basic，右边全部大于basic，中间一个basic，接着递归操作basic左右两部分。</li><li>优化<ul><li>使用荷兰国旗问题的思想稍作改进，取arr[n-1]为basic，令arr左边全部小于basic，右边全部大于basic，中间全部等于basic，接着递归操作左右部分。</li><li>相比于经典快排一次只搞定一个数，优化快排避免了左部分有basic的情况。</li></ul></li></ul></li><li>随机快排<ul><li>经典快排取的basic是arr[R]，因此最差时间复杂度可以达到$O(N^2)$，采用随机选取basic的方式可以在一定程度上避免这个问题。</li></ul></li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：$O(N*log N)$（随机快排的长期期望）<ul><li>虽然快排的时间复杂度也是$O(N*log N)$，但是它的常数项是优于其他排序算法的</li><li>经典快排时间复杂度最差$O(N^2)$</li></ul></li><li>额外空间复杂度：$O(log N)$（随机快排的长期期望）<ul><li>空间浪费在断点的保存</li><li>如果是经典快排，额外空间复杂度最差可以达到$O(N)$</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dutch</span>(<span class="params">arr, L, R</span>):</span></span><br><span class="line"><span class="comment"># basic = arr[R]; # 经典快排</span></span><br><span class="line">basic = arr[random.randint(L,R)];<span class="comment"># 随机快排</span></span><br><span class="line">cur = L;</span><br><span class="line">L = L - <span class="number">1</span>;</span><br><span class="line">R = R + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> cur &lt; R:</span><br><span class="line"><span class="keyword">if</span> arr[cur] &lt; basic:</span><br><span class="line">arr[cur], arr[L+<span class="number">1</span>] = arr[L+<span class="number">1</span>], arr[cur]</span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line">L += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> arr[cur] &gt; basic:</span><br><span class="line">arr[cur], arr[R-<span class="number">1</span>] = arr[R-<span class="number">1</span>], arr[cur]</span><br><span class="line">R -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> L,R</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">arr, L, R</span>):</span></span><br><span class="line"><span class="keyword">if</span> L &lt; R:</span><br><span class="line">a,b = dutch(arr,L,R)</span><br><span class="line">quick(arr,L,a);</span><br><span class="line">quick(arr,b,R);</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>];</span><br><span class="line">quick(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="2020/01/08/algo/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>2020/01/08/algo/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>把arr[0, n-1]分成arr1[0, mid]，arr2[mid+1, n-1]，另其分别有序</li><li>开辟辅助数组，遍历arr1与arr2，使其在辅助数组中[0, n-1]范围上有序</li><li>将排序后的辅助数组写回arr，整个过程采用递归的思想</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：有$T(N) = 2T(\frac N2) + O(N)$可得$O(N*log N)$</li><li>额外空间复杂度：$O(N)$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">sort(arr, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L == R) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">sort(arr, L, mid);</span><br><span class="line">sort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">help[i++] = arr[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">help[i++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= R-L; ++j) &#123;</span><br><span class="line">arr[L+j] = help[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>窗口最大值</title>
      <link href="2020/01/08/algo/%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>2020/01/08/algo/%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="窗口最大值问题"><a href="#窗口最大值问题" class="headerlink" title="窗口最大值问题"></a>窗口最大值问题</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有一个数组arr，下标L，R初始都为-1，L和R只能增大不能减小，问窗口在滑动的过程中，每一次的窗口最大值是多少？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设置一个双端队列，R走一格i，如果队列右端大于对应的值大于arr[i]那么右端插入i，如果不大于，右端弹出，直到队列为空或遇到比他大的，插入i。L走一格，判断队列左端的下标值有没有过期，如果过期了弹出，直到遇到没有过期的下标值。整个过程中，双端队列保持从左到右降序。</p><h2 id="应用题目"><a href="#应用题目" class="headerlink" title="应用题目"></a>应用题目</h2><ul><li>给一个数组arr，一个num，问arr有多少个子数组，其最大值和最小值的差小于num？</li><li>如果子数组A满足条件，那么A的所有子数组都满足条件，范围大于A的所有子数组都不满足条件。</li><li>初始L=0，R向右走，直到R+1位置不满足条件，停止，则以0开始的子数组有R-L+1个满足条件。</li><li>然后令L=1，R尝试向右走，然后算出以1开始所有满足条件的子数组。</li><li>整个窗口不断滑动，直到求出所有，在判断满足条件时，需要维护两个双端队列，用来求最大最小值，L在增加时需要更新双端数组。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="2020/01/08/algo/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>2020/01/08/algo/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="字典树-前缀树"><a href="#字典树-前缀树" class="headerlink" title="字典树/前缀树"></a>字典树/前缀树</h1><ul><li>路径可以用map表示，比如说map&lt;char, node*&gt;</li><li>字母放在边上，存储的信息放在节点上<br><img src="/photo/trie.png" alt="trie" loading="lazy"></li></ul>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希</title>
      <link href="2020/01/08/algo/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
      <url>2020/01/08/algo/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h1><p>假设现在有一个服务器，然后有一个集群数据库，服务器接收数据，计算hash值key，然后根据key向某个数据库索取数据。现在11.11来临，需要增加数据库的数量，这时候需要把所有的数据重新计算hash，重新分配到不同数据库上。</p><p>一致性hash将可能的hash值围成一圈，将不同数据库计算得到的hash值映射到圈上，服务器接到一条数据计算hash后，顺时针寻找最近的数据库，如果需要添加数据库，则映射数据库服务器主机名的hash，映射到圈上，这样只需要将原本分管该区域上的数据库的部分数据迁移到新增数据库上即可。</p><p>这样做的缺点在于，如果数据库比较少，hash的均衡性无法体现，有可能几个数据库的负载是不均衡的。其次新增服务器也会导致负载变得不均衡。通过虚拟节点计数可以解决这两个问题。即我们不用数据库的主机名或ip计算hash，而是给每个数据库分配n个值，通过这n个值去计算hash，这样数据库在圈上就有了n个虚拟节点，让所有的虚拟节点抢到的数据交给物理机处理，这样子虚拟节点数多了，hash的计算也就趋于均衡了。虚拟节点和物理机之间建立路由表，可以通过虚拟节点找到物理机，也可以通过物理机找到它的虚拟节点。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="2020/01/08/algo/%E9%80%92%E5%BD%92/"/>
      <url>2020/01/08/algo/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="master公式"><a href="#master公式" class="headerlink" title="master公式"></a>master公式</h2><ul><li>用于估算递归行为时间复杂度</li><li>$a$:函数A中调用函数A的次数，不考虑展开</li><li>$\frac N2$:函数A中调用函数A时的样本数量</li><li>$O(N^d)$:函数A中除了递归调用之外的时间复杂度</li><li>master只适用于样本数量均分的递归行为</li></ul><p>$T(N) = a*T(\frac N2) + O(N^d)$</p><p>$log_b a &gt; d:O(N^{log_b a})$</p><p>$log_b a = d:O(N^d*log N)$</p><p>$log_b a &lt; d:O(N^d)$</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li>利用递归计算数组最大值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> max1 = recursion(arr, l, m);</span><br><span class="line"><span class="keyword">int</span> max2 = recursion(arr, m, r);</span><br><span class="line"><span class="keyword">return</span> max(max1, max2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>本例中$a = 2$，$b = 2$，$d = 0$</li><li>$T(N) = 2*T(\frac N2) + O(1)$</li><li>由于$log_b a &gt; d$，所以时间复杂度为$O(N)$</li></ul><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>morris</title>
      <link href="2020/01/08/algo/morris/"/>
      <url>2020/01/08/algo/morris/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="morris遍历"><a href="#morris遍历" class="headerlink" title="morris遍历"></a>morris遍历</h1><p>时间复杂度O(N)，额外空间复杂度O(1)</p><ul><li><p>当前节点记为cur，从head开始</p></li><li><p>如果cur无左子，cur = cur.right</p></li><li><p>如果cur有左子，找到cur左子树最右节点，记为mostright</p><ul><li>如果mostright.right == null<ul><li>mostright.right = cur, cur = cur.left</li></ul></li><li>如果mostright.right == cur<ul><li>mostright.right = null, cur = cur.right</li></ul></li></ul></li><li><p>后序：每次只关注能第二次走到的节点（即左子不空的节点），逆序遍历该节点左子树右边界</p></li><li><p>先序：第一次走到cur就打印该节点</p></li><li><p>中序：无论cur左子空或不空，走完流程打印cur</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表相交</title>
      <link href="2020/01/08/algo/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"/>
      <url>2020/01/08/algo/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="链表相交问题"><a href="#链表相交问题" class="headerlink" title="链表相交问题"></a>链表相交问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在本题中，单链表（只有一个next指针）可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交，请实现一个函数，如果两个链表相交，返回相交的第一个节点，如果不相交，返回null。要求：如果链表1的长度为N，链表2的长度为M，时间复杂度要求O(N+M)，额外空间复杂度要求O(1)。（有时候不提示链表有环无环的问题）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>如何判断单链表有环还是无环？</li></ol><ul><li>用set结构，遍历节点存set，当遍历到某个节点发现已经在set中，该节点就是入环的节点。</li><li>不用set的话，可以用快慢指针，快指针一次走两步，慢指针一次走一步，如果快指针走到null，说明无环。如果快慢指针相遇，说明有环，相遇后，快指针回到起点，改为一次走一步，再次相遇的节点就是入环节点。</li></ul><ol start="2"><li>如何判断两个无环单链表第一个相交的节点？</li></ol><ul><li>用set结构，遍历head1存set，再遍历head2，如果某个节点在set中，说明是相交节点。</li><li>不用set，遍历head1和head2，拿到len1、len2、tail1、tail2，如果tail1和tail2地址不同，则两个链表不相交。如果相同，长链表先走到剩下部分和短链表一样长，然后两条链表一起走，寻找相交节点。</li></ul><ol start="3"><li>一个链表有环一个链表无环？</li></ol><ul><li>两个单链表的话，不可能相交。</li></ul><ol start="4"><li>如何判断两个有环单链表第一个相交的节点？<ul><li>⚪⚪<ul><li>入环节点地址不同。</li><li>入环节点1继续向下走，一圈走完没遇到入环节点2即为该拓扑结构。</li></ul></li><li>&gt;–⚪或&gt;⚪<ul><li>入环节点地址相同可以确定为该拓扑结构。</li><li>把入环节点的next当作null，复用2方法就能找到第一个相交节点。</li></ul></li><li>=⚪<ul><li>入环节点地址不同。</li><li>入环节点1继续向下走，一圈走完前遇到入环节点2即为该拓扑结构。</li><li>两个入环节点都可以算是两个链表的第一个相交节点。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心问题</title>
      <link href="2020/01/08/algo/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/"/>
      <url>2020/01/08/algo/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="字符串组合"><a href="#字符串组合" class="headerlink" title="字符串组合"></a>字符串组合</h2><ul><li>给定一组字符串，要求将他们拼接在一起，使结果字典序最小。</li><li>写一个比较器，a+b &gt; b+a : a在前 : b在前;排序后将他们连接在一起，就是最小的结果。</li></ul><h2 id="切金条"><a href="#切金条" class="headerlink" title="切金条"></a>切金条</h2><ul><li>一块金条切成两半，需要花费与长度相等的铜板，比如要切长度20的金条，不论切出的两半多大，都花费20个铜板，问一群人要分一块金条，怎么分最省铜板？</li><li>例如给出数据[10,20,30]代表一共三个人，整块金条长度60，金条分成10，20，30三个部分，如果是(10,(20,30))这么分需要60+50=110，但如果是((10,20),30)这么分需要60+30=90。</li><li>解决思路：赫夫曼树+堆，每次从堆取出两个最小的，在把两个加和放回去。</li></ul><h2 id="最大效益"><a href="#最大效益" class="headerlink" title="最大效益"></a>最大效益</h2><ul><li>给出起步资金数组和利润数组，表示各种项目的起步资金和利润，初始有一定创业资金，可以做N个项目，项目不能同时去做，问怎样做能有最大收益。</li><li>先按起步资金建小根堆，然后把小于创业资金的项目拿出来，按利润建大根堆，每次创业资金+=大根堆头，然后继续从小根堆中拿可做的项目到大根堆。</li></ul><h2 id="开会"><a href="#开会" class="headerlink" title="开会"></a>开会</h2><ul><li>有n个会议，一个会议室，给出各个会议开始结束时间，求出会议室一天内最多可进行多少场次会议？</li><li>按结束时间来，结束早的优先。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2020/01/08/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2020/01/08/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="递归和动态规划"><a href="#递归和动态规划" class="headerlink" title="递归和动态规划"></a>递归和动态规划</h1><h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>就是把n-1个从from拿到help上，然后第n个从from拿到to上，然后help上的n-1个拿到to上，递归进行</p><h2 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h2><p>找出一个字符串的所有子序列，递归每一个位置，要或者不要该位置上的字符，递归进行</p><h2 id="母牛生崽"><a href="#母牛生崽" class="headerlink" title="母牛生崽"></a>母牛生崽</h2><p>一开始有一个母牛，母牛每年生一个母牛，母牛第四年开始可以生母牛，F(n) = F(n-1) + F(n-3)</p><h2 id="递归转dp"><a href="#递归转dp" class="headerlink" title="递归转dp"></a>递归转dp</h2><p>从递归的终止条件开始，确定dp表，往上推</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="2020/01/08/algo/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>2020/01/08/algo/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h2><p>一个数组arr，求每一个元素左右离他最近的且比他大的元素。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>开辟一个栈s，保证栈底到栈顶是降序的，添加一个元素i，检查栈顶元素是否小于i，如果是，那么栈顶元素的右结果为i，左结果为它下面的元素。如果栈顶元素大于i，把i添加到栈中，如果i等于栈顶元素，那么让他们两个在栈中重合，下标可以通过链表记录。如果arr没有元素添加了，依次出栈，右结果为null，左结果为它下面的元素。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表拷贝</title>
      <link href="2020/01/08/algo/%E9%93%BE%E8%A1%A8%E6%8B%B7%E8%B4%9D/"/>
      <url>2020/01/08/algo/%E9%93%BE%E8%A1%A8%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="链表拷贝问题"><a href="#链表拷贝问题" class="headerlink" title="链表拷贝问题"></a>链表拷贝问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，链表节点具有两个指针域，一个指向下一个节点，一个指向链表中某一个节点，要求对链表做拷贝操作。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>点在于节点有不确定的指针域，使用map&lt;old,new&gt;，new1节点next和rand的指向即为mp[mp[old1].next]与mp[mp[old1].rand]。</li><li>第二种思路先依次拷贝构造出old1 -&gt; new1 -&gt; old2 -&gt; new2 …长链表，它们的next的指针已经被设置好，每次拿出一对old和new，new.rand即为old.rand.next，当整个长链表的next和rand都设置好后，在将链表分离成old和new两个链表。</li></ol>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="2020/01/08/algo/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>2020/01/08/algo/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><ul><li>假设为一个搜索引擎实现一个功能，有一个黑名单，数据量很大，我们对搜索结果判断是否在黑名单中，如果是返回ture，不是返回false。</li><li>首先我们可以想到使用hashset来解决这个问题，但是这样空间浪费很大。</li><li>如果系统允许发生小概率的失误，则可以考虑使用布隆过滤器，这里的失误指的是把好人认作坏人，而非把坏人认作好人。</li></ul><p>布隆过滤器是个bit map，一条数据经过k个hash函数，算出k个数，对应k个位置的bit被标记，k个数可能会有重复。判断一条数据是否在黑名单，就依次计算k个hash函数，如果有一个所对应的bit位没有被标记，说明它一定不在黑名单；若所有值对应的bit位都被标记，那么认为它在黑名单中（虽然有可能被冤枉了）。</p><p>布隆过滤器用基本类型数组实现，然后通过位运算取到每一位，过滤器的bit数量越大，hash函数越多，则失误率越低</p><p>设样本量为n，预期失误率为p，bit数量为m，hash函数数量为k，真实失误率为P，则$m = -\frac {n*ln p}{ln^2 2}$，$k = ln 2 * \frac mn$，$P = (1-e^{- \frac {nk}{m}})^k$</p><script type="text/javascript" id="MathJax-script" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js"></script><script>MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\(', '\\)']]  }};</script><script id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bfprt</title>
      <link href="2020/01/08/algo/bfprt/"/>
      <url>2020/01/08/algo/bfprt/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="BFPRT"><a href="#BFPRT" class="headerlink" title="BFPRT"></a>BFPRT</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用于求解数组中第k小元素，复杂度为O(N)，这个问题可以用荷兰国旗求解，复杂度也是O(N)，但是不稳定，因为每次选取的basic是随机的，而BFPRT的优化就是在basic的选取上。首先把数组5个一组分成N/5组，每组组内排序，取中位数。第一次中位数数组长度为N/5时，这个数组内有N/10个元素比数组中位数大，然后这N/10个数各自组内还有两个数比中位数数组中位数大，所以整个数组有至少3N/10个元素比中位数大，以这个中位数为basic，看所求元素是否在中间区域，不在就继续递归。</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>variadic-templates</title>
      <link href="2020/01/08/C++/variadic-templates/"/>
      <url>2020/01/08/C++/variadic-templates/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当args为空时，模板函数无法被调用</span></span><br><span class="line"><span class="comment">// 这个函数是为了处理边界使用的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">const</span> T&amp; first, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    echo(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 该函数模板不会被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    echo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11小东西</title>
      <link href="2020/01/08/C++/cpp11%E5%B0%8F%E4%B8%9C%E8%A5%BF/"/>
      <url>2020/01/08/C++/cpp11%E5%B0%8F%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一些C-2-0的小东西"><a href="#一些C-2-0的小东西" class="headerlink" title="一些C++2.0的小东西"></a>一些C++2.0的小东西</h1><h2 id="Space-in-Template-Expressions"><a href="#Space-in-Template-Expressions" class="headerlink" title="Space in Template Expressions"></a>Space in Template Expressions</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; 在每个版本都适用</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;  c++<span class="number">11</span>后可以</span><br></pre></td></tr></table></figure><h2 id="nullptr-and-std-nullptr-t"><a href="#nullptr-and-std-nullptr-t" class="headerlink" title="nullptr and std::nullptr_t"></a>nullptr and std::nullptr_t</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11之后指针可以用 nullptr代替 0 or NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line">f(<span class="number">0</span>); <span class="comment">// call f(int)</span></span><br><span class="line">f(<span class="literal">NULL</span>); <span class="comment">// call f(int) if NULL is 0 ambiguous</span></span><br><span class="line">f(<span class="literal">nullptr</span>); <span class="comment">// call f(void*)</span></span><br></pre></td></tr></table></figure><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #1 c++11 you can declare a var or an object without specifiying type by using auto</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> d = f();</span><br><span class="line"><span class="comment">// #2 auto用于2种情况 第一种是type太长 另一种是复杂的表达式 lambda</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// vector&lt;int&gt;::iterator pos;</span></span><br><span class="line"><span class="comment">// pos = v.begin();</span></span><br><span class="line"><span class="keyword">auto</span> pos = v.begin();</span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Uniform-Initialization"><a href="#Uniform-Initialization" class="headerlink" title="Uniform Initialization"></a>Uniform Initialization</h2><p>原理: 编译器看到大括号 {t1,t2,tn}变做出一个Initializer_list他关联到一个array&lt;T,n&gt; 调用ctor的时候array内的元素被编译器被逐一赋值给ctor(构造函数)。但如果参数参数是个Initializer_list那就将参数打包直接发给函数。</p><p>使用{}初始化，在有潜在风险的情况下，编译器会给warning或error，例如说int a{1.0};</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如何初始化一个对象或变量，c++11 之前 新手很容易困惑 初始化可能发生在() &#123;&#125; =操作符</span></span><br><span class="line"><span class="comment">// c++11 后统一一个方法 用&#123;&#125;</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; city &#123;</span><br><span class="line">  <span class="string">&quot;New York&quot;</span>, <span class="string">&quot;London&quot;</span>, <span class="string">&quot;Beijing&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">comlex&lt;<span class="keyword">int</span>&gt; c&#123;<span class="number">4.0</span>, <span class="number">3.0</span>&#125;; <span class="comment">// 等价于 c(4.0, 3.0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ 11 之前</span></span><br><span class="line">Rect r1 = &#123;<span class="number">3</span>,<span class="number">7</span>,&amp;area&#125;;</span><br><span class="line"><span class="function">Rect <span class="title">r1</span><span class="params">(<span class="number">3</span>,<span class="number">7</span>,&amp;area)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="explict"><a href="#explict" class="headerlink" title="explict"></a>explict</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">T</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T t = <span class="number">0</span>;<span class="comment">// 报错，但如果不写explicit是会做隐式调用构造函数的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>initializer-list</title>
      <link href="2020/01/08/C++/initializer-list/"/>
      <url>2020/01/08/C++/initializer-list/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h1><p>使函数支持接受任意个数的参数，<code>vector&lt;int&gt; v&#123;1,2,3,4,5,6&#125;;</code>的实现原理就是将{1,2,3,4,5}包装成initializer_list调用参数是initializer_list的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = vals.begin(); p != vals.end(); ++p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * p &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    P(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P(int a,int b) = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    P(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; initlist) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P(initializer_list&lt;int&gt;) =&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : initlist) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;); <span class="comment">//1 2 3 4 5 6 7</span></span><br><span class="line"></span><br><span class="line">    <span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;  <span class="comment">// P(int a,int b) = 77 5</span></span><br><span class="line">    P q&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;  <span class="comment">// P(initializer_list&lt;int&gt;) = 77 5</span></span><br><span class="line">    P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">23</span>&#125;;   <span class="comment">// P(initializer_list&lt;int&gt;) = 77 5 23</span></span><br><span class="line">    P s = &#123;<span class="number">77</span>, <span class="number">5</span>&#125;;  <span class="comment">// P(initializer_list&lt;int&gt;) = 77 5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;));    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
